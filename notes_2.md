############################
# NOTES 2 FILE
############################

# INDEX

- NOTES 1 FILE
  - JAVASCRIPT
  - WEB
  - NETWORK
  - PATTERN
  - DATABASE
  - SECURITY
  - HARDWARE
  
- NOTES 2 FILE
  - JAVA
  - UNIX-LIKES

- NOTES 3 FILE
  - OTHERS: diğer başlıklara eklenemeyenler

- NOTES 4 FILE
  - MOBIL
  - GIT
  - MATH

############################

############################
# JAVA
############################

###########################

# queryDSL
build sırasında code generation'ı yapararak, birçok java kütüphanesi için ek query sağlayan kütüphanedir. desteklediği kütüphaneler:

- jpa
- sql
- Mongodb
- Collections

jpa için örnek olarak kullanımına bakalım:

```xml
<dependencies>
    
    <dependency>
        <!-- this is for code generation on build time. so it is on provided scope which means this library exist only on build phase. -->
        <groupId>com.querydsl</groupId>
        <artifactId>querydsl-apt</artifactId>
        <version>${querydsl.version}</version>
        <scope>provided</scope>
    </dependency>
 
    <dependency>
        <!-- burada kullanmak istediğimiz java modülünü eklememiz şart -->
        <groupId>com.querydsl</groupId>
        <artifactId>querydsl-jpa</artifactId>
        <version>${querydsl.version}</version>
    </dependency>
 
</dependencies>

<plugin>
    <!-- this is for code generation on build time. -->
    <groupId>com.mysema.maven</groupId>
    <artifactId>apt-maven-plugin</artifactId>
    <version>1.1.3</version>
    <executions>
        <execution>
            <goals>
                <goal>process</goal>
            </goals>
            <configuration>
                <outputDirectory>target/generated-sources/java</outputDirectory>
                <processor>com.querydsl.apt.jpa.JPAAnnotationProcessor</processor>
            </configuration>
        </execution>
    </executions>
</plugin>
```

Java kodumuzda User isimli bir entity varsa; "mvn compile" komutunu çalıştırdığımızda QUser isimli bir sınıf generate edilecektir. QUser içerisinde birçok query yapabilmemizi sağlayan metod mevcuttur. örnek kullanım:

```java
EntityManagerFactory emf = Persistence.createEntityManagerFactory(); // default JPA class
EntityManager em = entityManagerFactory.createEntityManager(); // default JPA class

JPAQueryFactory queryFactory = new JPAQueryFactory(em); // com.querydsl.jpa.impl.JPAQueryFactory

QUser user = QUser.user; // QUser is auto-generated by querydls library. QUser includes a default instance of QUser as static.

// simple get example
User c = queryFactory.selectFrom(user)
                              .where(user.login.eq("David"))
                              .fetchOne();

// order example
List<User> c = queryFactory.selectFrom(user)
                                  .orderBy(user.login.asc())
                                  .fetch();

// update example
queryFactory.update(user)
  .where(user.login.eq("Ash"))
  .set(user.login, "Ash2")
  .set(user.disabled, true)
  .execute();

// delete example
queryFactory.delete(user)
  .where(user.login.eq("David"))
  .execute();
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Apache Lucene
İlk başta sadece java için tasarlanan fakat daha sonra birçok programlama için geliştirilen indexleme ve arama motoru kütüphanesidir.

Bir dökümanı (database, list, text file...) parçalara böler, indexler ve daha sonra da arama yapılabilmesini sağlar. bunların tümü için ayrı ayrı programlama dillerine API'ler yazılmıştır. Lucene sunucu gibi kendi başına çalışmaz.

querydsl'in Lucene'nin query (arama) tarafı için desteği vardır.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Spring Boot Actuator
Actuator kelime anlamı: 1. işletici, çalıştırıcı 2. uyarıcı

spring'e dependency olarak eklendiğinde, o spring uygulaması için rest endpoint'leri açıyor ve bu endpoint'ler üzerinden health check, disk usage, heap dump gibi bilgiler dışarıya veriyor.

# Micrometer
JVM uygulamaları için facade kütüphanesidir. Bu kütüphane JVM based uygulamamız dışarı spring-actuator gibi bilgi vermektedir. spring-actuator bilgileri dışarı açarken belli bir formatta/standartta sunmaz. oysa Micrometer birçok monitörüng toola destek verecek şekilde bunları dışarı açar.

Micrometer'ın support ettiği monitoring tool'lar:

AppOptics, Azure Monitor, Netflix Atlas, CloudWatch, Datadog, Dynatrace, Elastic, Ganglia, Graphite, Humio, Influx/Telegraf, JMX, KairosDB, New Relic, Prometheus, SignalFx, Google Stackdriver, StatsD, and Wavefront.

Micrometer JVM uygulamalrında spring-actuator ile de entegreli çalışabilir. eğer istenirse spring-actuator'sız, saf java projesinde de çalışabilir.

# Grafana
Elasticsearch, Prometheus, Graphite, InfluxDB gibi veritabanlarından verileri çekerek, kendisinin sunduğu web arayüzünden visualize eder. belli event'lerde oto notify/email sistemi gibi ek özelliklerde sunar.

# Prometheus
bir servis olarak ayağa kalkar. önceden her servisin healt (örneğin spring'deki actuator endpoint'leri) url'si promotheus'a tanıtılır. promotheus bu url'lere giderek düzenli olarak data çeker ve kendi db'sine kaydeder.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Maven

# pom.xml

her pom.xml bir superpom'dan türer. süper pom'da default değerler yer alır. bu değerler, runtime sırasında pom.xml'i okuyan ve işleyecek olan program (eclipse maven eklentisi gibi) süper pom'u oluşturur. bu değerleri saklamakta yarar vardır. zira sonraki maven sürümlerinde değişen değerler olabilir. super pom'da bulanabilecek örnek değerler: dependency repository url, password, username + source code resource directory, soruce code directory, test resource directory, test code directories + clean, install and other plugins and settings...

# maven tanımları

büyükten küçüğe:

__lifecycle --> build phase --> goal__

__execution__ tanımı goal ile aynı seviyede. execution aşağda anlatılmaktadır.

# lifecycles

- clean
- default
- site

her lifecycles içinde birçok phase vardır. liste şu şekilde: (kaynak: http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#Lifecycle_Reference )

clean lifecycle phases:

| Phase      | Description                                                   |
|------------|---------------------------------------------------------------|
| pre-clean  | execute processes needed prior to the actual project cleaning |
| clean      | remove all files generated by the previous build              |
| post-clean | execute processes needed to finalize the project cleaning     |

default lifecycle phases:

| Phase                   | Description                                                                                                                                                                   |
|-------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| validate                | validate the project is correct and all necessary information is available.                                                                                                   |
| initialize              | initialize build state, e.g. set properties or create directories.                                                                                                            |
| generate-sources        | generate any source code for inclusion in compilation.                                                                                                                        |
| process-sources         | process the source code, for example to filter any values.                                                                                                                    |
| generate-resources      | generate resources for inclusion in the package.                                                                                                                              |
| process-resources       | copy and process the resources into the destination directory, ready for packaging.                                                                                           |
| compile                 | compile the source code of the project.                                                                                                                                       |
| process-classes         | post-process the generated files from compilation, for example to do bytecode enhancement on Java classes.                                                                    |
| generate-test-sources   | generate any test source code for inclusion in compilation.                                                                                                                   |
| process-test-sources    | process the test source code, for example to filter any values.                                                                                                               |
| generate-test-resources | create resources for testing.                                                                                                                                                 |
| process-test-resources  | copy and process the resources into the test destination directory.                                                                                                           |
| test-compile            | compile the test source code into the test destination directory                                                                                                              |
| process-test-classes    | post-process the generated files from test compilation, for example to do bytecode enhancement on Java classes. For Maven 2.0.5 and above.                                    |
| test                    | run tests using a suitable unit testing framework. These tests should not require the code be packaged or deployed.                                                           |
| prepare-package         | perform any operations necessary to prepare a package before the actual packaging. This often results in an unpacked, processed version of the package. (Maven 2.1 and above) |
| package                 | take the compiled code and package it in its distributable format, such as a JAR.                                                                                             |
| pre-integration-test    | perform actions required before integration tests are executed. This may involve things such as setting up the required environment.                                          |
| integration-test        | process and deploy the package if necessary into an environment where integration tests can be run.                                                                           |
| post-integration-test   | perform actions required after integration tests have been executed. This may including cleaning up the environment.                                                          |
| verify                  | run any checks to verify the package is valid and meets quality criteria.                                                                                                     |
| install                 | install the package into the local repository, for use as a dependency in other projects locally.                                                                             |
| deploy                  | done in an integration or release environment, copies the final package to the remote repository for sharing with other developers and projects.                              |

Site Lifecycle phases:

| Phase       | Description                                                                                  |
|-------------|----------------------------------------------------------------------------------------------|
| pre-site    | execute processes needed prior to the actual project site generation                         |
| site        | generate the project's site documentation                                                    |
| post-site   | execute processes needed to finalize the site generation, and to prepare for site deployment |
| site-deploy | deploy the generated site documentation to the specified web server                          |

# örnek komutlar:

- mvn clean deploy --> clean lifecycle'ı ve ardından deploy fazı çağrılır. deploy fazına gelene kadarki tüm fazları çağırır.

- mvn maven-compiler-plugin:2.5.1:compile --> compile plugin'inin goal'unu çağırır. maven, ilgili goal'e gelen kadarki tüm goal'leri çağırır. diğer lifecycle içerisindeki fazları çağırmaz. 

# örnek goal tanımlama
1 goal birden fazla faz tarafından çağrılabilir.

goal tanımlamak için plugin şart. her plugin'in goal'leri var. aşağıdaki xml config'inde görüldüğü gibi bir pluginin hangi fazlarda çalışacağı ve hangi goal'lerin o fazlarda olduğu belirtilmektedir.

Eğer bir goal hiçbir faza dahil edilmezse, o zaman sadece o goal'i tek başına komut satırından tetikleyebiliriz.

```xml
<build>
  <plugins>
          <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-antrun-plugin</artifactId>
            <version>1.1</version>
            <executions>
                  <execution>
                          <id>id.validate</id>
                          <phase>validate</phase>
                          <goals>
                              <goal>run</goal>
                          </goals>
                          <configuration>
                              <tasks>
                                  <echo>in validate phase (the first phase of build lifecycle)</echo>
                              </tasks>
                          </configuration>
                  </execution>
```

# execution
execution bir goal'in farklı konfigürasyonlarda çalışmasını sağlamak için yaratılmıştır. her execution'ın bir id si var. her execution'ın bir configi var. her execution farklı goal'lere yada fazlara atayabiliriz.

# sık karşılaşılan maven komut satırı hataları

- ## mvn build
"mvn build" komutu hata verir. çünkü böyle bir faz yada goal yoktur.

eclipse'in M2Eclipse plugini maven entegrasyonu sağlamaktadır. bu plugin yüklü iken, bir maven projesine sağ tıklandığında "maven build" seçeneği görülecektir. bu seçenek, daha önce çalıştırılmış olan bir maven build configürasyonunu run edecektir. eğer birden fazla config var ise, hangisini çalıştırmak istediğimizi soracaktır. yeni config yaratmak veya eskilerini düzenlemek için "maven build ..." seçeneğine tıklanmalıdır.

- ## "mvn clean install" vs "mvn install"
"mvn install" komutu "clean" ayrı bir lifecycle olmadığından target dizinini silmez. clean olmadığı için ve install çalıştırdığımız için şu hatayı alabiliriz: eğer bir plugin build sırasında source code generate ediyor ise, target'ta zaten o source'lar varolduğundan dublicate tarzı bir hata alabiliriz.

yani; sırası ile:

> mvn clean install
> mvn install

çalıştırırsak, pluginlerlere bağlı olarak hata alma durumumuz olabilir.

aynı sebepten:

> mvn clean install
> mvn deploy

komutu da hata verebilir.

# target vs source jdk version

target sürümü uygulamanın minimum hangi versiyon jdk üzerinde çalıştırılacağı anlamına geliyor. target jar/war dosyası o jdk sürümününe uyumlu class'ları üretiyor.

source ise; uygulamanın kodlarının hangi versiyon ile derleneceğini belirtiyor. uygulama yeni teknolojide çalışabilir fakat kodların eski sürümler ile kontrol edilmesi istenebilir. bunun birkaç sebebi olabilir;

1- ilerdeki zamanlarda projenin eski sürüm java'larda çalışması istenebilir. o zaman sadece target'ı düşürmek yeterli olacaktır.

2- kontrol amaçlı.

3- proje'nin target ve source versiyonu aynı olduğunu varsayalım. fakat spesifik olarak sadece benim sistemin için derleme yapmak istiyorum. benim sistemim çok güncel. güncel bir java'ya göre derlenen daha hızlı çalışacağından, sadece tagre versiyonunu yükseltip derleme yapabiliriz.

# dependency

her dependency'de ayrı ayrı scope değeri belirtilirtilebilir. scope asagidaki degerler olabilir:

- test: bu kütüphanenin sadece test execution'larında kullanılacağı anlamına gelir.

- provided: kütüphanen sadece derleme aşamasına olacağı ve output (target) klasöründeki jar/war dosyasına konmayacağı anlamına gelir. örnek weblogic içerisinde olan bir libary'yi scope=provided yapmak gereklidir.

- system: bu kütüphanenin path'inin maven repolarında olmayacağı ve local dizinde olacağı anlamına gelir. bu sebeple local bşr dizin variablesi de atamak gereklidir. örneğin C:\Libs\abc.jar gibi. canlı ve IDE-developer ortamında aynı dizin kullanılmaktadır. compile sırasında bu jar kullanılır ama bu dizin manifest'te class-path'e eklenir. bu durumda; scope'u provided'a benzemiş olur.

- runtime: sadece runtime sırasında bu jar targetta bulunur.

- compile: default scope'tur. hem compile hemde targetta bu libler bulunurlar.

- import: sadece dependencyManagement içerisinde olabilir.

# profiles

profiller ile; derleme sırasında, belirtilen dinamik dizin (aşağıdaki örnekte directory), javadaki "resource" klasörünün root'una kopyalanır.

```xml
<profiles>
  <profile>
   <id>test</id>
   <activation>
        <activeByDefault>true</activeByDefault>
   </activation>
   <build>
   <resources>
        <resource>
            <directory>src/main/resources/profiles/test</directory>
        </resource>
   </resources>
   </build>
  </profile>
```

profiller ile aynı zamanda her profilin farklı reposu, eklentisi, dependency gibi seçenekleri olması da ayarlanabilmektedir.

# plugin-management vs plugin

plugin management içerisinde plugin'ler, projenin alt modülündeki yada ilgili proje için sadece bir tanımdır. bunların kullanıp kullanılmayacağına her projenin pom'u kendi karar verir. kullanılmak istenen eklenti build-plugins içerisinde belirtilmesi yeterlidir. eğer override eidlmesi gereken parametreler var ise onlar mutlaka geçilmelidir.

```xml
 <build>
   ...
   <pluginManagement>
     <plugins>
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-jar-plugin</artifactId>
         <version>2.6</version>
         <executions>
             <execution>
```

# dependency-management

plugin-management'e benzer yapıda dependency'leri yönetebilmek içinde bir kullanım mevcuttur. örneğin spring frameworkü her sürümü için ayrı ayrı dependency-management içerisinde tüm spring kütüphanelerini içeren pom'lar yaratmıştır. istediğimiz bir versiyon'u dependency-management 'a ekleyerek sadece kullanacağımız kütüphaneleri dependency kısmına eklememiz yeterlidir. hiçbir dependency için sürüm belirtmek zournda kalmayız.

# maven wrapper

pom.xml IDE tarafından okunur ve ilgili işlemlerin koşması sağlanır. fakat maven IDE'siz de çalıştırılabilir. maven default command-line uygulaması mevcut. BU IDE 'lerin içine de gömülebilir, işletim sistemine de kurulabilir. maven wrapper basit bir script'tir. bu script projenin root'unda pom.xml in yanında bulunur. bu script işletim sisteminin komut satırında çalıştırıldığında maven'ı işletim sistemi path'inde arar, yoksa download eder ve maven komutlarını çalıştırmamızı sağlar. portabilite kazandırır. IDE den bağısmzlığı getirir. pom.xml'e uygun maven sürümünü bulmaya çalışır. her işletim sistemi için farklı script dosyası olmalıdır, çünkü her OS'un kendi sciprt dili vardır.

piyasada bir çok maven-wrapper dosyası oluşturan yazılımlar vardır.

maven-wrapper'ların maven eklnetileri de olabiliyor. bu maven eklentileri ile lifecycle içeirisinde maven-wrapper script dosyalarını oluşturulması sağlanıyor.

maven-wrapper maven standartlarında belirtilmiş bir şey değildir.

# effective pom.xml

"effective pom.xml" 'imizi görmek istediğimizde bit tool (örnek IDE) bize pom.xml'imizden "effective pom.xml" otomatik generade eder.

örnek source code dizini nerde olduğu pom.xml'de yazmaz. fakat effective pom.xml'da yazar. effective pom.xml tüm detayları içerir. bu dosyayı backup alıp, soruce code içine koymakta yarar olabilir.

effective pom.xml'i pom.xml'e komple yaıştırırsak hiçbir şey değişmez. yine projemiz çalışmaya devam eder.

# Archetype

türkçe kelime anlamı: prototip

mvn komutu ile yeni proje oluşturduğumuzda, oluşan dosyaların ve pom.xml'de neler yazacağı gibi bilgilerin olduğu template'e verilen isimdir. kullanılan Archetype'a göre altmodüller de açılabilir. birçok Archetype mevcuttur. sadece basit java projesi için bile birçok farklı kaynaktan Archetype bulabiliriz.

Archetype bilgisi (hangi Archetype'ı seçtiğimiz) effective pom.xml'da dahi yazmaz. çünkü Archetype sadece pom.xml'i ve dizinleri (/src, /test...) oluşturur.

Maven ile oluşturulan projelerin dizin yapısı burada belirtilmiştir: https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html. Örneğin source dizinleri effective-pom.xml içerisinde yazmaktadır, fakat pom.xml'de belirtilmek zorunda diildir. çünkü bu değerler default'tur. eğer default haricinde bir dizin source olacak ise; pom.xml'de belirtilmek zorundayız.

# SNAPSHOT

Bu suffix genelde sürüm numaralarının sonuna atılmaktadır. Bu maven'ın hayat döngüsünü değiştirebilen bir suffix'tir. 

örneğin; oluşturudğumuz artifact'ı nexus'a deploy ettiğimizde, eğer SNAPSHOT prefixi var ise, nexus bu paketi varolan SNAPSHOT ile günceller. oysa SNAPSHOT prefixi yoksa (eğer nexus config'lerinden özellikle aksi ayarlanmadığı sürece) ve aynı sürüm de paket deploy etmeyi denediysek, nexus bizi reddedecektir. bu nexus'un bir ayarıdır, maven'ın diil.

fakat; maven'ın sadece SNAPSHOT dependency'leri güncellemesi için bir komutu vardır. Dolayısı ile SNAPSHOT prefix'i hem nexu starafında hemde maven tarafından tanınmaktadır. özel bir suffix'tir.

Maven release'leri güncellemez. Çünkü release'ler eğer numara verilmişse değiştirilmemelidirler diye kabul eder.

Eclipse maven eklentisi release'leri güncelle gibi bir özellik sunar: "Force Update of Snapshots/Releases". Maven SNAPSHOT olan'ları hash kontrolü yaparak paketin değişip değişmediğini kontrol eder. SNAPSHOT olmayanlarda ise sürüm'lerini kontrol eder. Eclipse burada snapshot'ları ve aynı zamanda release paketleri için hash kontrolü yapıyor. eğer değişmiş varsa onları güncelliyor.

# maven plugins

A Maven plugin is a group of goals.

bazı plugin'ler "build", bazıları ise "reporting" xml tag'i içine alınıyor (neden bu şekilde bir mimari uygulanmış bulanamadım). Bu durum ile ilgili kurallar burada belirtilmiştir: https://maven.apache.org/guides/mini/guide-configuring-plugins.html#Using_the_reporting_Tag_VS_build_Tag

Özetle:

- clean ve default hayat döngüsünde olan plugin'ler mutlaka "build" xml tag'i içine alınmalıdır. site hayat döngüsündeki plugin'ler ise "reporting" ve "build" içerisine alınabilir.
- build içerisine alınan site plugin'lerinin configürasyonları ignore edilir.
- eğer elle "P" plugin'in "G" goal'ini çağrırsak; önce reporting tag'indeki configürasyonları okur. eğer yok ise build içerisine alınan "P" plugin'in configürasyonlarını okur.

Aşağıda maven projesi tarafından desteklenen resmi plugin'lerin listesi verilmiştir.

kaynak: https://maven.apache.org/plugins/

| Plugin                      | Description                                                                                                            |
|-----------------------------|------------------------------------------------------------------------------------------------------------------------|
| ** Core plugins **          | ** Plugins corresponding to default core phases (ie. clean, compile). They may have multiple goals as well.**          |
| clean                       | Clean up after the build.                                                                                              |
| compiler                    | Compiles Java sources.                                                                                                 |
| deploy                      | Deploy the built artifact to the remote repository.                                                                    |
| failsafe                    | Run the JUnit integration tests in an isolated classloader.                                                            |
| install                     | Install the built artifact into the local repository.                                                                  |
| resources                   | Copy the resources to the output directory for including in the JAR.                                                   |
| site                        | Generate a site for the current project.                                                                               |
| surefire                    | Run the JUnit unit tests in an isolated classloader.                                                                   |
| verifier                    | Useful for integration tests - verifies the existence of certain conditions.                                           |
| ** Packaging types/tools ** | ** These plugins relate to packaging respective artifact types. **                                                     |
| ear                         | Generate an EAR from the current project.                                                                              |
| ejb                         | Build an EJB (and optional client) from the current project.                                                           |
| jar                         | Build a JAR from the current project.                                                                                  |
| rar                         | Build a RAR from the current project.                                                                                  |
| war                         | Build a WAR from the current project.                                                                                  |
| app-client/acr              | Build a JavaEE application client from the current project.                                                            |
| shade                       | Build an Uber-JAR from the current project, including dependencies.                                                    |
| source                      | Build a source-JAR from the current project.                                                                           |
| jlink                       | Build Java Run Time Image.                                                                                             |
| jmod                        | Build Java JMod files.                                                                                                 |
| ** Reporting plugins**      | ** Plugins which generate reports, are configured as reports in the POM and run under the site generation lifecycle.** |
| changelog                   | Generate a list of recent changes from your SCM.                                                                       |
| changes                     | Generate a report from an issue tracker or a change document.                                                          |
| checkstyle                  | Generate a Checkstyle report.                                                                                          |
| doap                        | Generate a Description of a Project (DOAP) file from a POM.                                                            |
| docck                       | Documentation checker plugin.                                                                                          |
| javadoc                     | Generate Javadoc for the project.                                                                                      |
| jdeps                       | Run JDK's JDeps tool on the project.                                                                                   |
| jxr                         | Generate a source cross reference.                                                                                     |
| linkcheck                   | Generate a Linkcheck report of your project's documentation.                                                           |
| pmd                         | Generate a PMD report.                                                                                                 |
| project-info-reports        | Generate standard project reports.                                                                                     |
| surefire-report             | Generate a report based on the results of unit tests.                                                                  |
| ** Tools **                 | ** These are miscellaneous tools available through Maven by default. **                                                |
| antrun                      | Run a set of ant tasks from a phase of the build.                                                                      |
| archetype                   | Generate a skeleton project structure from an archetype.                                                               |
| assembly                    | Build an assembly (distribution) of sources and/or binaries.                                                           |
| dependency                  | Dependency manipulation (copy, unpack) and analysis.                                                                   |
| enforcer                    | Environmental constraint checking (Maven Version, JDK etc), User Custom Rule Execution.                                |
| gpg                         | Create signatures for the artifacts and poms.                                                                          |
| help                        | Get information about the working environment for the project.                                                         |
| invoker                     | Run a set of Maven projects and verify the output.                                                                     |
| jarsigner                   | Signs or verifies project artifacts.                                                                                   |
| jdeprscan                   | Run JDK's JDeprScan tool on the project.                                                                               |
| patch                       | Use the gnu patch tool to apply patch files to source code.                                                            |
| pdf                         | Generate a PDF version of your project's documentation.                                                                |
| plugin                      | Create a Maven plugin descriptor for any mojos found in the source tree, to include in the JAR.                        |
| release                     | Release the current project - updating the POM and tagging in the SCM.                                                 |
| remote-resources            | Copy remote resources to the output directory for inclusion in the artifact.                                           |
| scm                         | Execute SCM commands for the current project.                                                                          |
| scm-publish                 | Publish your Maven website to a scm location.                                                                          |
| stage                       | Assists with release staging and promotion.                                                                            |
| toolchains                  | Allows to share configuration across plugins.                                                                          |

# MojoHaus (yada eski adı:Mojo@Codehaus.org)
maven eklentileri geliştiren projedir. geliştirilen plugin'lerin listesi: https://www.mojohaus.org/plugins.html

# Mojo (yada Maven plain Old Java Object)
MojoHaus ismi buradan türemiştir. Each mojo is an executable goal in Maven, and a plugin is a distribution of one or more related mojos. maven plugin developer'larının bildiği bir terimdir. maven kullanan developer'ların bildiği bir terim diildir. kaynak: http://maven.apache.org/plugin-developers/index.html (archive date: 03/01/2020)

# maven-deploy-plugin vs nexus-staging-maven-plugin
maven-deploy-plugin nexus sunucusuna deploy yapabiliyor. fakat nexus-staging-maven-plugin, sadece nexus sunucusuna özgü ek özellikler de barındırıyor (örnek: staging özelliği). opsiyonel olarak tercih edilebilir.

# sık kullanılan bazı plugin'ler

- spring-boot-maven-plugin

  - Actuator tarafından kullanılmak üzere "build-info" generate edebiliyor.
  - maven komutları ile projeyi start edebilmemizi sağlıyor.

- maven-source-plugin

  source code'un jar veya war'ın içine attach edilebilmesini sağlıyor. böylece uygulamamızı jar olarak dependency ekleyen projeler, projemizin kodlarını debug edebiliyor.

- build-helper-maven-plugin

  build aşaması için eksra özellikler içeriyor (bazıları maven-compiler-plugin ile de yapılabiliyor). örnek:

  - build aşamasında bazı directory'leri soruce kod olarak set edebilmemizi sağlıyor (örnek src/extra/java 'nında kod dizini olarak tanımlanmasını sağlıyor)

# -DskipTests vs -Dmaven.test.skip=true
-DskipTests test kodlarını compile eder fakat testleri koşmaz.

-Dmaven.test.skip=true hem test kodlarını derlemiyor hemde testleri koşmuyor.

# BOM
Bill Of Materials'in kısaltmasıdır. BOM'lar sadece dependency yönetimini sağlamak için oluşturulmuş projelerdir. 2 şekilde BOM'ları projemize import edebiliriz:
- dependency management'e import ederek:

```xml
<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>baeldung</groupId>
            <artifactId>Baeldung-BOM</artifactId>
            <version>0.0.1-SNAPSHOT</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
    </dependencies>
</dependencyManagement>
```

- parent vererek:

```xml
<parent>
    <groupId>baeldung</groupId>
    <artifactId>Baeldung-BOM</artifactId>
    <version>0.0.1-SNAPSHOT</version>
</parent>
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# discovery server

micro-sunucular (servisler) ana bir servise kendilerini register ederler. istenilen sayıda makine ona register olur ve son kullanıcı (yazılım geliştirici) buradan tüm servisleri monitör eder. bu ana sunucuya "discovery server" denilir. discovery server'a örnek olarak açık kaynaklı "Eureka server" verilebilir. Eureka server'ın client API'leri mevcut. bu apiler ile register işlemleri çok kolay şekilde yapılabilmektedir. Alternatif discovery'ler: Consul, Zookeeper, etcd.

Zookeeper ve etcd aslında key/value bir storage manager'dır. fakat geliştiriciler, açık olan web servisleri Zookeeper storage'sinde tutup, Zookeeper'ı bir servis discovery olarak kullanmaktadırlar.

- # eureka node types

    - # eureka server
      
      diğer instance'laeın locationlarını tutan ve listesini tutan node'dur.

    - # eureka service vs eureka instance

      eureka servvice aynı isimdeki servisleri temsil etmek için kullanılan bir referenastır. her 'eureka servis', birer 'servise id' ile temsil edilmektedir. bir adet 'eureka service'i, birden fazla instance'a denk gelebilir. instance'lar gerçek node'lara denk gelmektedir. örneğin; "order-servise" isimli eureka service'ine ait, 10 adet eureka instance'ı olabilir.

    - # eureka client

      any application can discover services. kendisini servis(instance) olarak tanıtmak zorunda değildir.

- # eureka config

  Eureka'da her tipte yazılım için ayrı config'ler vadır. bunlar:

  - Eureka server config: org.springframework.cloud.netflix.eureka.server.EurekaServerConfigBean that implements com.netflix.eureka.EurekaServerConfig. All properties are prefixed by "eureka.server".

  - Eureka client config: org.springframework.cloud.netflix.eureka.EurekaClientConfigBean that implements com.netflix.discovery.EurekaClientConfig. All properties are prefixed by "eureka.client".

  - Eureka instance config: org.springframework.cloud.netflix.eureka.EurekaInstanceConfigBean that implements (indirectly) com.netflix.appinfo.EurekaInstanceConfig. All properties are prefixed by "eureka.instance".

- # eureka config properties

  - eureka.client.registerWithEureka
  
    eureka server dahi kendisi bir client barındırır. ve client'ın kendi instance'ındaki server'a (kendi kendine) register olmasını istemiyorsak bu değeri eureka server'da false'a çekmeliyiz. bu değer true olursa; node, server'a kendini instance olarak tanıtmaktadır. 

  - eureka.client.fetchRegistry = true

    eureka sunucusundan, ona bağlı tüm servislerin bilgilerini çekmemize yarar. bunu yapan her node, instance olmak zorunda değildir (yani başkaları tarafından servis olarak algılanabilmek/erişilebilmek zorunda diildir.)

  - eureka.client.shouldDisableDelta = true

    fetchRegistry işleminde sadece değişikliklerin çekilmesi istenir. böylece network bandwith'den kar edilmiş olur.

  - eureka.client.registryFetchIntervalSeconds = 30s

    fetchRegistry işlemi diğer işlemlerden bağımsızdır ve her 30 saniyede bir yapılır.

  - eureka.client.cacheRefreshExecutorExponentialBackOffBound

    fetchRegistry isteği, cacheRefreshExecutorExponentialBackOffBound*registryFetchIntervalSeconds süresi kadar başarısız olursa, artık node istek atmayı durdurur.

  - eureka.instance.leaseRenewalIntervalInSeconds = 30s

    instance olan her node, server'a 30 saniyede 1 heartbeat isteği atmaktadır.

  - eureka.instance.leaseExpirationDurationInSeconds = 90s

    eğer 90 saniye içinde instance'den heartbeat gelmez ise, server o node'u listeden kaldırırı ve erişilemez yapar.

  - eureka.client.initialInstanceInfoReplicationIntervalSeconds = 40s
  
    com.netflix.appinfo.InstanceInfo değerinde instance hakkında birçok metadata vardır. bu metadata'lar sunucuya sürekli düzenli yollamnır. bu işlem hearbeat'den bağımsızdır. bu datanın suncuya ilk olarak, sunucuya bağlanıldıktan 40 saniye sonra yollanır.

  - eureka.client.instanceInfoReplicationIntervalSeconds = 30s

    com.netflix.appinfo.InstanceInfo değeri ilk yollandıktan sonra, her 30 saniyede bir tekrar yollanır.

  - eureka.server.responseCacheUpdateIntervalMs = 30s

    server her 30 saniyede bir servis listesini yeniler. bu liste yenilenmeden, kaydolan servisler bir sonraki yenileme ile ancak dışarıdan erişilebilir hale gelecektir.
    
    "/eureka/apps" REST isteği listesinde, yenileme süresi geçmediyse, o arada register olan servisler gözükmeyecektir.
    
    dahsboard ise yenilemeyi beklememektedir. direk güncel bilgiyi döndürür.

    "/eureka/apps/appName/instanceId" REST isteği yenilemeyi beklemez. direk güncel bilgiyi döndürür.

  - ribbon.ServerListRefreshInterval = 30s

    bu değer eureka modülüne ait değil. ribbon load balancer'dır ve eureka server'dan servis listesini çeker. bu süre zarfından güncellenmiş servis var ise, onları ilgili node'umuz göremeyecektir.

  - eureka.server.numberRegistrySyncRetries = 5, eureka.server.getWaitTimeInMsWhenSyncEmpty = 5m

    eureka server peer-aware mode'da çalışabilir. yani diğer server'lar ile haberleşerek çalışabilir. bu da verimliliği arttırır. server bu mode'da iken, 5 kere diğer sunuculardan servis listesini çekmeye çalışır. 5 kere başarısız olursa, 5 dakika boyunca client'ların kendisinden bilgi almasına izin vermez.

  - eureka.server.enableSelfPreservation = true, eureka.instance.registry.expectedNumberOfRenewsPerMin = 4, eureka.server.renewalPercentThreshold = 0.85, eureka.server.renewalThresholdUpdateIntervalMs = 15m

    eureka server'a 2 client bağlı olsun. her biri 30 saniyede 1 heartbeat atsın. bu durumda dakikada 4 adet istek gelmeli. bu değeri expectedNumberOfRenewsPerMin ile belirtiyoruz. 4 * 0.85 = 3.4. eğer dakikada 3 veya 4'ten daha az istek gelirse ve bu 15 dakika boyunca sürerse, eureka server kendini enableSelfPreservation'a alır. bu mode'a girdiği zaman artık expire eden instance'ları listesinden silmez.

# congig server

tüm diğer servislerin bir micro-servisten config'leri (propertie'leri) okuması gerekir. bu micro-sunucuya "config server" adı verilir.

# zuul

bir microservis olarak çalışır. bu sunucuya "gateway server" yada "edge server" denilmektedir. "Zuul proxy" buna örnek bir uygulamadır.

bu servise register olan sunucuların API'lerini Zuul dışarıya kendisi üzerinden açmaktadır. örnek: user-service'imizin /url1 path'li bir metodu olsun. money-service'imizinde /url1 path'li bir metodu olsun. bunları dışarıdan şu şekilde çağrılmalarını sağlamaktadır. bu iki servis ayrı porttan çalışmaktadır. bu iki api'yi de tek bir porttan açmak istediğimizde zuul proxy üzerinden açarız.

```yml
zuul:

  routes:

    service1:

      path: /user-service/**

      url: http://localhost:8081/user-service/

    service2:

      path: /money-service/**

      url: http://localhost:8082/money-service/
```

yukarıdaki konfig şunu diyor: path'e gelen istekler (örnek: http://zuul_proxy_ip:zuul_port/zuul_proxy_service/money-service/url1 ) url'ye yönlendirilsin ( örnek: http://localhost:8082/money_service/url1 )

zuul-proxy'nin filter özelliği mevcut. istek önce zuulServlet'e geliyor. zuul servlet sırası ile bizim filtrelerimizi işletiyor. filtrelerimiz 3 çeşit:

- prefilter: istek yönlendirilmedenönce

- routing filter: istek burada henüz yönlendirilmedi, fakat httpRequest objesi burada hazırlanabiliyor ve request burada yapılıyor. request'in dönüşü de ilk bu sınıfta karşılanabiliyor.

- postfilter: istek geldikten sonra çalıştırılıyor

- error filter: herhangi bir aşamada exception alındığında bu filter devreye giriyor

basit filter örneği:

```java
public class QueryParamPreFilter extends ZuulFilter {

@Override

public int filterOrder() {

    return PRE_DECORATION_FILTER_ORDER - 1; // run before PreDecoration

}

@Override

public String filterType() {

    return PRE_TYPE;

}

@Override

public boolean shouldFilter() {

    RequestContext ctx = RequestContext.getCurrentContext();

    return !ctx.containsKey(FORWARD_TO_KEY) // a filter has already forwarded

           && !ctx.containsKey(SERVICE_ID_KEY); // a filter has already determined serviceId
}

@Override
public Object run() {

    RequestContext ctx = RequestContext.getCurrentContext();

    HttpServletRequest request = ctx.getRequest();

    if (request.getParameter("sample") != null) {

         // put the serviceId in `RequestContext`
         ctx.put(SERVICE_ID_KEY, request.getParameter("foo"));

    }
    return null;
}

}
```

Zuul proxy'yi internal microservislerimiz kendi arasında haberleşirken kullanmayız. Best practice olarak microservisler internal haberleştiğinde discovery'den haberleşirler. discovery'ye erişilmek istenen servis ismi verilir, discovery bize bir ip/port atar, o ip/port'a istek atarız. Zuul üzerinden de bu iş yapılabilir fakat best practice değildir.

# Circuit Braker (yada devre kesici) 

bu kütüphane sayesinde hata fırlatan veya cevap vermeyen (timeouta düşen) metodlar için backup metodlar hazırlanabilir. Spring boot ile de entegrasyonu olan ama bağımsız da çalışabilen Hystrix buna bir örnek araçtır.

hystrix örnek kod:

aynı sınıf içinde aşağıdaki iki metod olmalıdır. eğer fallbackMethod yok ise; hystrix exception fırlatır. zaten bu exception'u fırlatacaktı diye düşünebiliriz. fakat fallback yapması ve timeout'ları da desteklemesi hystrix'in avantajıdır.

```java
@HystrixCommand(fallbackMethod = "noBooks", ignoreExceptions = { NullPointerException.class })

public String fetchBooks(int a) {

    return restTemplate.get(uri, String.class);
}

public String noBooks(int a) { //aynı değeri buraya atıyor

    return "There is no book available now";
}
```

yukarıdaki fetchBooks metodu için timeout set etmek isteyelim. timeout ayarını bu projenin applicaiton.yml'sine eklememiz yeterlidir. bu projeyi restart ettiğimizde ayar devreye girmiş olacaktır.

# ribbon

client side loadbalancer görevi görüyor. ribbon rest-template yada feign-client gibi hazır spring modülleri ile dışarıdaki sunuculara istek yaptığımız zaman, ilgili sunuculara düzenli /testUrl gibi bir path üzerinden sürekli istek yapar. bu istek eğer 200 dönmezse o sunucuyu down olarak varsayar ve bizi diğer sunculara yönlendirir. /testUrl path'i, timeout, gibi paramterler override/configure edilebilir.

ribbon kütüphanesi ribbon işlemi yapılcak client'a eklenmelidir. örnek bir confgi (yml) içeriğimiz (client uygulamada olmalı bu configler):

```yml
account-service: #this is service name

  ribbon:

    eureka:

      enabled: false

    listOfServers: localhost:8090,localhost:9092,localhost:9999

    ServerListRefreshInterval: 15000
```

Yukarıdaki config'de eureka disabled edildiği için listOfServers'ı elle verdik. eğer eureka enabled olsaydı, listOfServers otomatik algılanıyor olacaktı.

# Feign Client

feign türkçe kelime anlamı: uydurmak

rest istekleri için kolayca client oluşturmamız sağlayan modül. rest serverdaki kodların aynısını (body kısmı hariç) feignclient anotation'lu interface'e kopyalanır. daha sonra rest istek yapılması istenen kod satırında şu şekilde kullanmak yeterli olacak: 

```java
MyFeignClientInterface.doPostRequest("Hello");
```

örnek kod:

```java
@FeignClient(name = "account-service")
public interface CHAccountServiceClient {
	@RequestMapping(value = "/accounts/v1/transactions", method = RequestMethod.POST)

	public ServiceResponse<String> transaction(@RequestBody RequestDTO requestDTO);
}
```

Feign client'ın ribbon ile entegrasyonu vardır. Eğer @FeignClient(name = "account-service") yazılırsa, "account-service"'in adresi ribbon'dan getirilecektir. eğer ribbon kullanılması istenmiyorsa, direk url verilmelidir:  @FeignClient(name = "http://mysite.com/rest/")

Yukarıdaki CHAccountServiceClient Feign client bir interfacedir. direk olarak autowired edilir ve implementasyonunu yaratmayız. bu sebeple test, prod, local gibi ortamlar (spring profiller) için farklı Feign Inject edemeyeceğiz. çünkü profiller runtime sırasında implementasyon arar. Bunun için şöyle bir yol izleyebiliriz:

- Test kodlarımızda farklı url'li feign client yaparız. mockito ile asıl feign cliet'ımızdaki her metodu ikinci yazdığımız bu feignClient'a yönlendiririz.

- FeignFactory diye bir interface yaparız. 2 adet te bunun implementasyonu: FeignFactoryProdImpl ve FeignFactoryDevImpl.

```java
@Component

@Profile("prod")

class FeignFactoryProdImpl implements FeignFactory{

  @Autowired
  ProdFeign feign; 
}
```

Benzeri FeignFactoryDevImpl içinde olucak. Artık asıl feignclient'ı kullanacağız sınıfa @autowired ile FeignFactory'yi inject edeceğiz. Prod profilindyken runtime'de ProdFeign gelecektir.

Feign client builder'ı ile hem encoderlarımızı değiştirebiliriz hemde diğer client'ları wrap ettirip kullanabiliriz. örnek:

```java
GsonCodec codec = new GsonCodec();
    GitHub github = Feign.builder()
                         .encoder(new GsonEncoder()) // buraya JacksonEncoder da gelebilirdi
                         .decoder(new GsonDecoder())
                         .target(GitHub.class, "https://api.github.com");
```

```java
GitHub github = Feign.builder()
                     .client(new OkHttpClient())
                     .target(GitHub.class, "https://api.github.com");
```

# Spring Cloud Sleuth

Sleuth türkçe kelime anlamı: dedektif.

Sleuth, sping'in cloud'un bir subprojesidir. Sleuth zipkin gibi takip sistemlerini kapsar.

# Spring Cloud Netflix

sping'in cloud'un bir subprojesidir. Service Discovery (Eureka), Circuit Breaker (Hystrix), Intelligent Routing (Zuul) and Client Side Load Balancing (Ribbon) projelerini içerir.

# zipkin

spring ile de entegrasyonu olan kendi başına çalışan bir microservistir. bu microservis yapılan tüm istekleri takip eder. bir transaction'ı baştan sona takip eder ve bir web-GUI ile bunları analiz etmemizi sağlar. log atarken bu transaction-idleri de basabilmekteyiz. 

ortamdaki her microservis zipkine requesti aldığına ve bitirdiğine dair bilgi vermelidir. bunu yapmaları için her microservice'de bir zipkini destekleyen bir kütüphane bulunmalıdır. bu kütüphanelere  "instrument library" deniyor. her microservis'e "reporter" deniliyor. sadece microservisler değil, aynı zamanda isteği yapan client'ta bu sürecin içine dahil edilebilir. client tarafta isteği yolladığı anda bu bilgiyi zipkin sunucusuna bildirebilir.  

zipkinde kullanılan terimler:

#### Annotation

sadece isteğin hangi durumda olduğunu içerir. örnek:

- cs - Client Send
- sr - Server Receive

#### BinaryAnnotation

istek yapılan url bilgisi gibi birçok bilgi içerir.

#### span

türkçe kelime anlamı: karış, süre.

her microservis arasındaki geçişler birer span'dır.

#### trace

requestin client'tan çıkması ve client'ın requesti aldım sinyalini yollayana kadar geçen akış için kullanılan terim. trace-id tüm istek için baştan sona tekildir.

#### parentId

isteğin hangi span-id'den sonra yapıldığı bilgisidir.

#### Flags

bayrak string'i akışın olduğu yönde bir sonraki sunucuya yollanır.

#### b3 propagation

propagation türkçe kelime anlamı: yayılma

zipkin sunucular arası haberleşmedeki header isimlerine karışmaz. bu sebeple 'b3' isimli bir standart belirlenmiştir. burada header isimleri X-B3- prefixi ile başlar ve yollanması gereken id uzunlukları bellidir.

# spring cloud sürümleri

spring cloud spring'in bir subprojesidir ve altında birçok subproje barındırır.

her altporjenin sürümü aslında diğerlerinden bağımsızdır. bu sebeple uygun sürümleri biraraya getirerek bir cloud projesi sürümü oluşturulur. bu projenin sürümü numara ile gitmez. isim ile gider. isim sırası alfabetiktir. 

örnek: 1. sürüm "Angel", 2 "Brixton" şeklinde gider... 

Yani "angel" cloud sub-projeleri için bir sürüm kümesidir.

örneğin feign-client 4ücnü sürümünde ve eureka 3'üncü sürümde olabilir (sayıları uydurdum).

Eğer "angel"' kritik ve ufak bir güncelleme gerekiyor ise SR suffix'ini ("service releases") ve sürümü alıyor. örnek: Angel.SR1, Angel.SR2...

| code name         | release date |
|-------------------|--------------|
| Greenwich.RELEASE | Jan, 2019    |
| Greenwich.SR2     | Jun, 2019    |
| Greenwich.SR1     | Mar, 2019    |
| Finchley.RELEASE  | Jun, 2018    |
| Finchley.SR4      | Jun, 2019    |
| Finchley.SR3      | Feb, 2019    |
| Finchley.SR2      | Oct, 2018    |
| Finchley.SR1      | Aug, 2018    |
| Edgware.RELEASE   | Nov, 2017    |
| Edgware.SR6       | May, 2019    |
| Edgware.SR5       | Oct, 2018    |
| Edgware.SR4       | Jul, 2018    |
| Edgware.SR3       | Mar, 2018    |
| Edgware.SR2       | Feb, 2018    |
| Edgware.SR1       | Jan, 2018    |
| Dalston.RELEASE   | Apr, 2017    |
| Dalston.SR5       | Dec, 2017    |
| Dalston.SR4       | Oct, 2017    |
| Dalston.SR3       | Aug, 2017    |
| Dalston.SR2       | Jul, 2017    |
| Dalston.SR1       | May, 2017    |
| Camden.RELEASE    | Sep, 2016    |
| Camden.SR7        | May, 2017    |
| Camden.SR6        | Mar, 2017    |
| Camden.SR5        | Feb, 2017    |
| Camden.SR4        | Jan, 2017    |
| Camden.SR3        | Nov, 2016    |
| Camden.SR2        | Nov, 2016    |
| Camden.SR1        | Oct, 2016    |
| Brixton.RELEASE   | May, 2016    |
| Brixton.SR7       | Nov, 2016    |
| Brixton.SR6       | Sep, 2016    |
| Brixton.SR5       | Aug, 2016    |
| Brixton.SR4       | Jul, 2016    |
| Brixton.SR3       | Jul, 2016    |
| Brixton.SR2       | Jul, 2016    |
| Brixton.SR1       | Jun, 2016    |
| Angel.SR6         | Jan, 2016    |
| Angel.SR5         | Jan, 2016    |

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# webjars

maven'a aşağıdaki eklendiğinde:

```xml
<dependency>
    <groupId>org.webjars</groupId>
    <artifactId>jquery</artifactId>
    <version>3.1.1</version>
</dependency>
```

html'lerimizden get isteği ile script'i çekebilmemizi sağlar:

```html
<script src="/webjars/jquery/3.1.1/jquery.min.js"></script>
```

configürasyonu bu şekildedir:

```java
@Configuration
@EnableWebMvc
public class WebConfig implements WebMvcConfigurer {
 
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry
          .addResourceHandler("/webjars/**")
          .addResourceLocations("/webjars/");
    }
}
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Netty
tcp veya udp'den haberleşmeleri için kullanılan java kütüphanesi.

netty ile udp soketlerine de bağlanılabilir, http istekleri deyapılıp alınabilir. birçok bağlantı çeşidi resmi olarak destekleniyor fakat farklı bağlantı çeşitleri de implemente edilebilir.

netty ile bağlantı kurulan tarafın netty kullanmasını gerektirmez.

örnek basit bir client kodu:

```java
// grup'lar ile istediğimiz kadar bağlantıyı kolayca yönetebiliyoruz. (bu durum finally kısmında güzel olarak örneklendirilecek)
EventLoopGroup group = new NioEventLoopGroup();

try{
    // Bootstrap genel nesne. bunsuz da olur fakat iş çok uzar.
    Bootstrap clientBootstrap = new Bootstrap();
    
    // her Bootstrap'in hangi gruba dahil olduğunu belirliyoruz. istersek birden fazla gruba da dahil yapabiliriz.
    clientBootstrap.group(group);

    // channel = bağlantı. NioSocketChannel bir çeşit soket çeşidi. birçok çeşit var. NioSocketChannel en temel tcp objesi.
    clientBootstrap.channel(NioSocketChannel.class);

    // gerçek soket nesnemizi Bootstrap'e bind ediyoruz. bunu yapmasaydık aşağıdaki bulunan connect metoduna parametre olarak ip portu yollamalıydık, connect bizim yerimize gerçek soket nesnesi oluşturacaktı.
    clientBootstrap.remoteAddress(new InetSocketAddress("localhost", 9999));

    // her channel'a birden fazla handler atayabiliriz. handler atama işlemlerini ChannelInitializer ile yapmalıyız.
    clientBootstrap.handler(new ChannelInitializer<SocketChannel>() {
        
        protected void initChannel(SocketChannel socketChannel) throws Exception {

            // birden fazla handler ekleyebiliriz. bir data gönderildiğinde yada alındığında handlerlar sırası ile çalıştırılır. addLast, addFirst ile handler'ların sıralarını belirlemekteyiz.
            // handlerlar tıpkı servletlerdeki filter'lar gibi düşünülebilir. data (request), sırası ile her filter'a uğraması gibi...
            socketChannel.pipeline().addLast(new ClientHandler());
        }
    });

    // clientBootstrap connect metodu ip'ye bağlantı yapıyor ve return olarak ChannelFuture döndürüyor.
    // ChannelFuture, java.util.concurrent.Future'den türemiştir. java'nın Future'ının özelleştirilmiş halidir.
    // ChannelFuture metodunun sync metodu, Future'ın bitmesini bekliyor. async durumlarda bunu kullanmamak gerekli. burada örnek olsun diye kullandık.
    ChannelFuture channelFuture = clientBootstrap.connect().sync();

    // channel() metodu channel'ı döndürüyor.
    // closeFuture(); ChannelFuture döndürüyor, ama bu ChannelFuture kapanma event'ini baz alarak çalışıyor. yani; yukarıdaki ChannelFuture soket bağlanınca Future objesinin taskı done oluyordu (tamamlanıyordu). aşağıdaki satırdaki channelFuture (closeFuture()'dan dönen obje) ancak soket kapandığında done oluyor.
    // sync metodu future'nin done olmasını bekliyor. sync tamamen önrke olduğu için bu satırda kullanıldı.
    channelFuture.channel().closeFuture().sync();
} finally {
    // group yapmamızın avantajı bu. bu gruba bağlı tüm Bootstrap'lere tek bir yerden aynı çağrıyı yapabiliyoruz.
    group.shutdownGracefully().sync();
}
```

Chaneller'lar 2 farklı gruba ayrılır:
- ChannelInboundHandler: soketimize istek geldiğinde bu channel'lardan sıra ile geçer
- ChannelOutboundHandler: soketimizden istek yolladığımızda bu channel'lardan sıra ile çıkar

client kodumuza devam edelim:

```java
//channel'larında bir çok implementasyonu/çeşidi var. bazıları generic yapıda olup, byte, string bazında okuma yazma yapabilmemizi sağlıyor.
public class ClientHandler extends SimpleChannelInboundHandler {

    @Override
    //bu metod soket aktif olduğunda (bağlantı açıldığı anda devreye giriyor)
    public void channelActive(ChannelHandlerContext channelHandlerContext){
        channelHandlerContext.writeAndFlush(Unpooled.copiedBuffer("Netty Rocks!", CharsetUtil.UTF_8));
    }

    @Override
    //channel'a istek geldiğinde çalışıyor
    public void channelRead0(ChannelHandlerContext channelHandlerContext, ByteBuf in) {
        System.out.println("Client received: " + in.toString(CharsetUtil.UTF_8));
    }

    @Override
    //herhangi bir yerde hata olduunda çalışıyor
    public void exceptionCaught(ChannelHandlerContext channelHandlerContext, Throwable cause){
        cause.printStackTrace();
        channelHandlerContext.close();
    }
}
```

server kodu da neredeyse tamamen benzer yapıda:

```java
EventLoopGroup group = new NioEventLoopGroup();

try{
    ServerBootstrap serverBootstrap = new ServerBootstrap();
    serverBootstrap.group(group);
    serverBootstrap.channel(NioServerSocketChannel.class);
    serverBootstrap.localAddress(new InetSocketAddress("localhost", 9999));

    serverBootstrap.childHandler(new ChannelInitializer<SocketChannel>() {
        protected void initChannel(SocketChannel socketChannel) throws Exception {
            socketChannel.pipeline().addLast(new HelloServerHandler());
        }
    });
    ChannelFuture channelFuture = serverBootstrap.bind().sync();
    channelFuture.channel().closeFuture().sync();
} catch(Exception e){
    e.printStackTrace();
} finally {
    group.shutdownGracefully().sync();
}
```

```java
public class HelloServerHandler extends ChannelInboundHandlerAdapter {

    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ByteBuf inBuffer = (ByteBuf) msg;

        String received = inBuffer.toString(CharsetUtil.UTF_8);
        System.out.println("Server received: " + received);

        ctx.write(Unpooled.copiedBuffer("Hello " + received, CharsetUtil.UTF_8));
    }

    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        ctx.writeAndFlush(Unpooled.EMPTY_BUFFER)
                .addListener(ChannelFutureListener.CLOSE);
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {
        cause.printStackTrace();
        ctx.close();
    }
}
```

# Codec
netty dünyasında codec; channel implementasyonu anlamına gelir. gelen isteği parse eder ve bize java objelerine çevirir. biz gelen datayı hazır şekilde java objelerinden okuruz.

# ChannelPipeline
her channel'ın bir pipeline'ı vardır. bu obje handler'ların listesini sırası ile tutar.  hem outbound hemde inbound handler'lar bu objenin içerisindedir.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# eclipse compiler java (yada ECJ)
- Eclipse IDE'nin java compiler'ının ismidir.
- Java'nın default compiler'ından farklıdır.
- en temel farklar:
  - kod düzgün derlenmemiş olsa bile, onu paketleyebilir (derleyebilir, jar/war oluşturur). örnek bir class fiziksel olarak yoksa fakat bir başka class içinden referans edilmişse, jdk normalde hata verirken, eclipse IDE bu hatayı esgeçebilir. dolayısı ile runtime'da classNotFound gibi bir hata alırız.
  - kısmi derlemelere imkan sunar. kodun sadece bir kısmını değiştirdiğimizde sadece o kısımları derler.
- tomcat'te JSP'leri derlerken ECJ kullanır. bu şekilde en ufak hatada tüm sistemi derlememezlik yapmaz.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# jre/jdk bin directory binaries

- java
  
  java app starter

- javaw

  wraps the "java" command, and starts the application on a new terminal interpreter. kaynak: https://www.ibm.com/support/knowledgecenter/SSYKE2_7.1.0/com.ibm.java.win.71.doc/user/java.html (archive date: 10/10/2019)

- javaws

  java web starter

- javac

  java code compiler

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# java.util.concurrent.Future

```java
public class SquareCalculator {    
     
    // ExecutorService java içinde gelen, Birçok thread'i yönetebilmemizi sağlayan bir yapıdır.
    private ExecutorService executor = Executors.newSingleThreadExecutor();
     
    public Future<Integer> calculate(Integer input) {

        return executor.submit(() -> {

            Thread.sleep(1000);
            
            return input * input;
        });
    }
}

Future<Integer> future = new SquareCalculator().calculate(10);
 
while(!future.isDone()) {
    System.out.println("Calculating...");
    Thread.sleep(300);
}
 
Integer result = future.get(); //get metodu eğer yukarıdaki while'ı yazmamış olsaydık, işlem tamamlanana kadar bekleyecekti. şimdiki durumda beklemesine gerek yok, çünkü zaten ukarıda işlemin bittiğine dair kontrolümüzü while içerisinde yaptık.
```

Future sınıfı şu metodları sunar:

- Boolean Cancel(boolean mayInterruptIfRunning)

  eğer task zaten kapanmışsa yada kapatılamadıysa false döner.

- V get()

  V dönüş objemiz. metodun ne yaptığı kod yukarıdaki kod içinde açıklandı.

- V get(long Timeout, TimeUnit unit)

  metod belli aralıkta dönmezse TimeoutException fırlatır.

- Boolean isCancelled()

- Boolean isDone()

# java.util.concurrent.CompletableFuture
java.util.concurrent.Future implementasyonudur. ek özellikler sunar. Future'nin eksiklerini kapatmak için daha sonradan geliştirilmiştir. kapattığı eksikler:

- zincir oluşturabilme

  üstüste Futur'leri sırası ile execute etme

- exception handling

- manually complete the future

  ```java
  completableFuture.complete("Future's Result");
  ```

  bu satır sonrası, completableFuture'ı kullanan tüm  metodlar isDone=true olacaktır.

- callback metodu verebilme

  ```java
  CompletableFuture<Void> future = CompletableFuture.runAsync(new Runnable() {
    @Override
    public void run() {
        // any code here
    }
  });

  future.get()
  ```

  Aynı işi lambda ile çok daha kısa yapabiliriz:

  ```java
  CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {
      // any code here
  });
  ```

  Sadece future kullansaydık; get()'ten sonra metodumuzu elle çalıştırmak zorunda kalacaktık ve işlemin success mi olup olmadığını da kontrol etmemiz gerekecekti.

  Burada callback metodumuz istersek obje de dönecek şekilde ayarlayabilirdik.

# Promise
standart java içerisinde Promise objesi yoktur. CompletableFuture, diğer dillerde kullanılan promise kavramına en yakın objedir. 

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# java package names

- java.* - jre içinde olan core paketler

- javax.* - jre içinde gelen fakat genelde extension (daha çok core pakete girmesi zorunlu olmayan: örnek jaxb) sınıflarını içermektedir.
  
  Bazı paketler javax.\*'dan java.\*'ya geçmiştir.
  
- önerilen isimlendirme:
  
  com.company_name.region_or_project_name.package_purpose

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# InputStream
reads bytes from any type of stream

# OutputStream
writes bytes to any type of stream

# flush
türkçe kelime anlmı: 1. su ile temizlemek. "The toilet doesn't flush." gibi kullanılıyor. 2. utançtan yüzü kızartmak.

OutputStream'de olan bir metoddur. bazı stream'ler write ile yazdığımız datayı karşıya hemen yollamaz. bunun bir çok sebebi olabilir: cache, buffer, protokol standartları gereği belli bir boyuta gelmesi beklenir... Flush metodu stream'e / protokole yazma sinyali göndermektedir. öncelikte stream'in flushable olması gereklidir. flushable olsa dahi bu metod işlemin fiziksel olarak karşıya gidip gitmeyeceğini garanti etmez. örneğin TCP soket'e yazarken flush metodu kesinlikle bunun garantisini vermiyor, çünkü tcp standartları belli data'nın bir byte'a gelmesini bekliyor. ancak tcp soket kapatılırken, data kesinlikle yollanıyor.

# InputStreamReader
kind of InputStream that read only character type from stream.

# DataInputStream
kind of InputStream that reads all kind of primitive types from stream.

# BufferedInputStream
buffer türkçe kelime anlamı: tampon, koruma.

kind of InputStream that reads only bytes with buffer mechanizm.

# Reader
read chacarter from any type of stream

# BufferedReader
kind of Reader that reads only character with buffer mechanizm.

# Scanner
reads primitive types and string with regex from any type of stream.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# generics
"generic programming" tüm programlama dilleri için bir terimdir. java da bu özelliği destekler. örnek:

generic'in türkçe kelime anlamı 'genel'dir. fakat bazı yerlerde jenerik olarak çevrilir. jenerik yanlıştır. hiçbir resmi kaynak bu şekilde çevirmez. jenerik türkçede 'tanıtım' anlamına gelir.

örnek generic java kodu:

- kullanıldığı kod:

```java
List<String> c = new ArrayList<String>(); //java 8 ile birlikte artık sağ tarafta generic-tipini belirtmeye gerek yoktur.

c.add(new Object()); // compile-time error fırlatır
```

- tanımlandığı kod:

```java
public class Entry<K, V> {

    private final K key;

    private final V value;

    public Entry(K key, V value) {  

        this.key = key;

        this.value = value;
    }

    public K getKey() {

        return key;
    }

    public Object method1(){

        return new Collection()<? extends K>;
    }
}
```

K, V harfleri istenilen karakter yada string olabilir. Genelde alışkanlık olduğundan, T (type), E (Element), V (value) and K (key) kısaltmaları kullanır. 

Yukarıdaki örnekte V yerine gerçek bir sınıf ismi yazmaya gerek yoktur. zaten o sınıf belli ise (fix ise) o zaman generic yapmaya gerek yoktur. BU sebeple oraya ne yazarsak yazalım sınıf ismi değil, özel bir keyword olarak algılanacaktır.

Yukarıdaki örnekte new Collection()<? extends K>; satırındaki "extends" tahmin edilen anlamından farklı bir anlama geliyor. K'nın subclass'ı olduğu herhangi bir sınıf gelmeli buraya anlamına geliyor. eğer tersi olursa runtime'da hata alırız. extend yerine super yazarsa, aşağıdaki satırda hata amayız. çünkü süperi "String" olan bir sınıf anlamına gelecekti:

Box<? super String> list = new Box<String>();  //super'i String olan bir sınıfı gelecek anlamına geliyor

list.add(new String("Hello World"));

Oysa yukarıda super yerine extend yazsaydı daha compile sırasında hata alacaktık.

# PECS (yada Producer Extends Consumer Super)

Yukarıdaki super ve extend'li kod satırlarına dikkat edersek; super yazdığımız zaman aşağıdaki satırlarında listeye ekleme yapabiliyoruz. çünkü ne ekleyeceğimizi biliyoruz. oysa extends'de ne ekleyeceğimizi bilmediğimizden, ekleme yapamıyoruz sadece okuma yaabiliyoruz. Bu sebeple extend keywordü ile işlem yaptığımızda kodumuz "Producer" görevi görüyor. bu sebeple producer'lar extend etmeli terimi ortaya çıkmıştır: "Producer Extends". Benzer şekilde "Consumer Super" terimi ortaya atılmıştır.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# static initializer

class Person {
   static {
           int a = 10;
           System.out.print("this block is 'static initializer' ")
   }

   {
          int b = 20; 
          System.out.print("this block is 'instance initializer' ")
   }
}

kod çalışma sırası:

1- static initializer

2- instance initializer

3- constructor (türkçe keliem anlamı: inşaatçı)

Yukarıdaki kodda int a ve b classın field'ları değil. block'un local field'larıdır. initializer block'ları ile class'ın fiels'larını set etmek için kullanırız. class'ların field'larını asagidaki gibi de set edebiliriz:

```java
class ABC {

  private a = 5;
}
```

fakat "instance initializer" ek özellikler de sunar. örneğin; if koşullarına göre farklı değerler set edebiliriz. bazı durumlarda log attırabiliriz.

# instance initializer vs constructor
yukarıda bahsedilen set etme olayı neden constructor'da yapılmıyor?

1- instance initializer'ın sınıfın 'final' değişkenlerini set etme özelliği de bulunuyor.

2- birden fazla constructor olduğunda hepsinde aynı set etme işlemini yapmak zorunda kalabiliriz. bunun yerine tüm constructor'lar için ortak olan kodu "instance initializer"'a atmakta yarar vardır.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# java thread

# thread oluşturma
iki şekilde thread yaratılabilir:

1- Runnable interfacesi implemente edilerek 

2- thread sınıfı extend edilerek

örnek:

```java
class ImplementsRunnable implements Runnable {

   //runnable sadece run metodunu içerir.

   private int counter = 0;

   public void run() {

         counter++;

         System.out.println("ImplementsRunnable : Counter : " + counter);
   }
 }

 class ExtendsThread extends Thread {

   private int counter = 0;

   public void run() {

         counter++;

         System.out.println("ExtendsThread : Counter : " + counter);
   }
 }
```

hangisini kullanmak gerekli:

- runnable kullanılırsa; ImplementsRunnable sınıfımız isterse başka sınıflardan extend edebilir. fakat ExtendsThread zaten extend hakkını kullandığı için tekrar extend edemez (java kuralı)

- runnable'den implemente etmiş sınıfta başlatılan her thread "private int counter" değerini ortak kullanır.

ImplementsRunnable direk çağrılamaz. Thread içine atılmalıdır.

```java
Thread t1 = new Thread(new ImplementsRunnable());
t1.start();

Thread t2 = new Thread(new ImplementsRunnable());
t2.start();
```

yukarıda t1 ve t2 aynı "counter" değeri kullanır.

# void run vs void start
run metodu çağrıldığında yeni bir paralel thread yaratılmaz. fakat satrt metodu run metodunu thread yaratarak çağırır.

start metodu aynı sınıf için 2 kere çağrılırsa IllegalThreadStateException fırlatır.

# void sleep(long)
milisecond cinsinden parametre alır ve ilgili thread'i o kadar bekletir.

# void join()
örnek:

```java
t1.join();
a++;
```

t1 thredi sonlanmadan a++ çalışmayacaktır.

# void join(long)

örnek:

```java
t1.join(3000);
a++;
```

t1 ölürse a++ çalışır, yada 3 saniye içinde ölmezse a++ çalışır. 

# static Thread currentThread()
bu metod o anda çalışmakta olan thread'in instance'ını dönüyor. static bir metod olmasına rağmen o anda bu metodu çağran thread'in bilgisini alabiliyor. 

# getName setname
thread sınıfına isteğe bağlı isim atanabiliyor.

# setdaemon getdaemon
boolean bir parametre alır. normalde java tüm thread'ler sonlanmadan JVM'i kapatmaz. daemon thread'lar bu kurala dahil diildir. daemon thread'ler sorgulanmadan JVM kapanabilir. 


# Executors
Birçok thread'i yönetebilmemizi sağlayan bir yapıdır.

ExecutorService executor = Executors.newFixedThreadPool(5);//onceden 5 thread açık tutuluyor. hızlı baslangıc icin.

```java
for (int i = 0; i < 10; i++) {  

   MyRunnableImpl runnable = new MyRunnableImpl(i);  
   executor.execute(runnable);  
}

executor.shutdown(); 

while (!executor.isTerminated()) {  

     //wait
}  

System.out.println("Finished all threads");  
```

# ThreadGroup

```java
ThreadGroup tg1 = new ThreadGroup("Group A");   

Thread t1 = new Thread(tg1,new MyRunnable(),"one");     

Thread t2 = new Thread(tg1,new MyRunnable(),"two");   
```

artık grupandıklarından dolayı tümüne aynı işlemi uygulamayabiliriz:

```java
Thread.currentThread().getThreadGroup().interrupt();
```

# synchronized
bu java keyword'ü metodun imzasına koyulduğunda o metod aynı anda en fazla 1 thread tarafından çalıştırılabilir olur. diğer threadler beklemeye alınır.

bu keyword ile isterske sadece belli bir kod bloğunuda kilitleyebiliriz:

```java
public void anyMethod() {

    //some code here

    synchronized (objRef) {

        //some code here

    }

    //some code here
}
```

yukarıdaki synchronized bir metod değil. özel bir syntax. burada objRef bu kod bloğunun o andaki thread için bekletilip bekletilmeyeceğine karar veriyor.

JVM, her aynı objRef'nin o kısma girmesine engel oluyor. yani "X" değerinde objRef olan iki thread varsa, aynı anda bu bloğa giremezler. 

objRef aynı zamanda "class" tipinde de değer alıyor. Örneğin Person.class. Eğer buparametre verilirse, Person'dan oluşmuş bütün thread'ler buraya girmek için sırada bekleyecektir.

# thread safe
bu terim tüm programla dilleri için geçerlidir. bir metod aynı anda istenildiği kadar thread tarafından çağrılıyor ve sorunsuz çalışıyor ise o metod thread safe'tir. bir sınıf thread safe ise o sınıfın içindeki tüm public metodlar thread safe anlamına gelir.

çağrılan metod; dışarıdaki kaynaklardan yararlanıyorsa ve özel olarak threadlocal, mutual exclusion, synchronized gibi çözümler kullanmamış ise; çağrılan metod, thread local değildir. mutual exclusion, synchronized gibi çözümler kullanılırsa bu sefer bu metodu çok thread aynı anda kullandığında sistem yavaşlayacaktır. bu sebeple daha verimli çözümler tavsiye edilir.

# threadlocal
javada bir sınıftır. aşağıdaki örnekte basit şekilde kullanımı mevcut. ThreadLocal her thread için yeni bir nesne yaratmaktadır. nesneyi yaratmak için initialValue() metodunu çağırır.

```java
public class Foo
{
    private final ThreadLocal<SimpleDateFormat> formatter = new ThreadLocal<SimpleDateFormat>(){

        @Override
        protected SimpleDateFormat initialValue()
        {
            return new SimpleDateFormat("yyyyMMdd HHmm");
        }
    };

    public String formatIt(Date date)
    {
        return formatter.get().format(date);
    }
}
```

# wait notify
Javanın obje sınıfına ait metodlarıdır. wait ile o thread artık bekleme durumuna girer. taki başka biri o thread üzerinde notify metodunu çağırana kadar.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# objenin metodları

aşağıda açıklaması geçmeyen metodlar başka yerde anltılıyor.

- tostring
- wait
- notify
- notifyall
- finalize: object JVM tarafından destro eidlmeden önce çağrılır.
- clone: tüm variablelelerin aynı olduğu yeni bir obje yaratır. bunu user'ın kendisinin override etmesi gerekir. eğer user ovverride etmediyse direk CloneNotSupportedException fırlatacak şekilde default implemente edilmiştir.
- getClass

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Spring framework

# SpringSource
spring framweork'ünü geliştiren firmanın eski ismi. firma ismi daha sonra spring oldu.
 
# Spring Tools (yada STS yada Spring Tools Suite)
Eclipse için spring eklentisidir. Eclipse'e yüklü şekilde de direk indirilebiliyor.

# spring modules

Spring birçok modül sunuyor. Bu modüller gruplandırılmış durumda ve her modül farklı gruptanda olsa bir modüle depend ediyor olabilir.

- Data access & Integration
  - spring-jdbc
  - spring-orm
  - spring-oxm: Object/XML mapping implementations for JAXB and other library
  - spring-tx: transaction
- Web & Remoting
  - spring-web: httpclient + servlets
  - spring-servlet: web-servlet denildiğinde bu paket kastedilir. bu modül MVC özellikli rest özelliğini içerir. sadece rest supportu da bu modüle dahildir.
  - spring-websocket
  - spring-portlet
- Core Container
  - spring-core: IoC özelliği bu modülün içinde tanımlıdır.
  - spring-beans: BeanFactory özelliği bu modülün içinde tanımlıdır.
  - spring-context: ApplicationContext özelliği bu modülün içinde tanımlıdır.
  - spring-expression (yada spEL): "Expression Language" modülüdür. string üzerinde kelime işleme özellikleri barındırmaktadır. aynı zamanda bean property'lerine variable atayabilmek için özel syntax kullanımını sağlıyor.
- Aspect
  - spring-aop: method-interceptors (spring's own Aspect library)
  - spring-aspects: AspectJ ile entegrasyonu sağlamakadır (alternative of spring-aop)
- spring-test: JUnit + TestNG support.
- spring-instrument: support for class loader implementations

# spring version naming

(spring cloud versionları başka başlıkta anlatılıyor.)

- GA (yada General availability): stable versiyon.

- RC (yada Release candidate): beta versiyon.

- M (yada Milestone build): nightly versiyon.

Yukarıdaki sürüm terimleri genel olarak tüm yazılım sürüm politikalarınca kullanılmaktadır. sadece spring'e özgü terimler diildir.

# spring version history

| version number | release year | compatible jdk version |
|----------------|--------------|------------------------|
| 0.9            | 2002         |                        |
| 1.0            | 2003         |                        |
| 2.0            | 2006         |                        |
| 3.0            | 2009         |                        |
| 4.0            | 2013         |                        |
| 4.3            |              | 6-8                    |
| 5.0            | 2017         | 8-10                   |
| 5.1            |              | 8-12                   |

# spring initializr
https://start.spring.io sitesinin altyapısı olan projedir. bu site ile web arayüzden spring modülleri seçebiliyoruz, paket ismi vs form girişi yaptıktan sonra bizim için gradle/maven, java/groovy gibi hazır boş spring projesi oluşturmaktadır. bu projeyi anında download etmemizi sağlıyor.

# Spring Bean

- ## Spring IoC container
DI için gereklidir. 2 çeşittir: Bean Factory vs ApplicationContext. ApplicationContext daha gelişmiş özellikler içerir.

  - ### ApplicationContext

    ```java
    ApplicationContext context = new ClassPathXmlApplicationContext("Beans.xml");

    HelloWorld objA = (HelloWorld) context.getBean("helloWorld");
    ```

  - ### ClassPathXmlApplicationContext
    classhpath içindeki dizini istiyor

  - ### FileSystemXmlApplicationContext
    full path istiyor

  - ### WebXmlApplicationContext
    tüm uygulamadaki xml'leri load ediyor

  - ### AnnotationConfigApplicationContext
    parametre olarak bir class istiyor. bu sınıfın içinde configürasyonlar oluyor.

  Spring bean'i dışında kalan sınıflar (bean olmayan sınıflar, normal sınıflar) içerisinde bean çeken anotation'lar kullanılamaz. hata alınmasa bile null gelir değerler. örneğin; @autowired ile normal bir sınıfta bir bean sınıfını inject ettik. bu sınıf runtime'da null olur. bean'ler ancak bean'ler tarafından çağrılabilir. yada yukarıdaki gibi context.getBean() metodu ile çağrılabilir.

  Runtime sırasında aynı java uygulamasında birden fazla ApplicationContext olabilir. dolayısı ile context.getBean() metodu ile hangi ApplicationContext'i aldığımıza dikkat etmeliyiz. fakat best practice'lere göre context'e bu şekilde erişmek pek önerilmez.

- ## BeanFactory
ApplicationContext'e alternatif bir kütüphanedir. spring-beans modülü içinde gelir. ApplicationContext, BeanFactory'den daha gelişmiştir ve BeanFactory'nin tüm özelliklerini zaten içerir. BeanFactory daha sadedir. bu sebeple mobil gibi uygulamalarda tercih edilebilir.

- ## Bean Scopes
  - ## singleton
  tüm applicationContext'te tek bir instance olmasını sağlıyor

  - ## prototype
  each injection initializes new object

  - ## request
  each HTTP request. only exist for Web applications.

  - ## session
  each HTTP session. only exist for Web applications.

  - ## global-session
  portletler için session bazlı bean oluşmasını sağlıyor. bu bean normal servlet'ler için kullanılırsa, "session" bean ile aynı mantıkta çalışacaktır.

  - ## websocket
  websocketlerin bağlantısı açık kaldıkça aynı bean sürekli açık kalır

  - ## application
  ServletContext hayat döngüsü boyunca varolan singleton bir obje. bir applicaionContext içerisinde birden fazla ServletContext olabilir.

  Yukarıdaki hazır scope'lar dışında custom scope'ta yaratılabilir.

  bean'lerin ne scope olursa olsun initialize ve destroy sırasında çağrılacak metodları olabilir. bu metodlar beans.xml dosyasında belirtilmek zorundadır.

- ## Bean hayat döngüsü
  sırası ile:

  - bean'e propertieleri set edilir

  - BeanNameAware.setBeanName(String name)

  - BeanFactoryAware.setBeanFactory(BeanFactory beanFactory)

  - ApplicationContextAware.setApplicationContext

  - @PostConstruct yada BeanPostProcessor.postProcessBeforeInitialization()

  - InitializingBean.afterPropertiesSet()

  - a user defined bean init method

  - BeanPostProcessor.postProcessAfterInitialization()

  - bean hazır durumda

  - DisposableBean.destroy()

  - a user defined ben destroy method

  bir örnek üzerinden gidelim:

  X Bean'imizin hayat döngüsüne bir metod ekleyelim: X bean BeanFactoryAware'i implemente eder ve setBeanFactory metodunu override ederse, setBeanFactory otomatik olarak çalışır. aksi durumda bu event atlanır.
  BeanFactoryAware'yi ilgili bean (X) implemente etmeyip aşağıdaki gibi kullanabiliriz. fakat böyle durumlarda aşağıdaki metod tüm bean'ler için çalıştırılmaktadır.

```java
public class MyBeanFactory implements BeanFactoryAware {
 
    private BeanFactory beanFactory;
 
    @Override
    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {
        this.beanFactory = beanFactory;
    }
 
    public void getMyBeanName() {
        MyBeanName myBeanName = beanFactory.getBean(MyBeanName.class);
        System.out.println(beanFactory.isSingleton("myCustomBeanName"));
    }
}
```

- ## bean property

xml tanımı yapılır:

```xml
<bean id="person" class="com.ornek.bean.Person">
      <property name="message1" value="Ahmet" />
</bean>
```

java tarafında artık bean hazırdır. message1 değeri otomatik javaee/spring tarafından doldurulacatır:

```java
public class Person {
   private String message1;
}
```

Yukarıdaki xml tanımını yapmasaydık, java kodumuzun içine anotation atmak zorundaydık.

- ## bean init method

benzer şekilde destroy metodu da belilenebiliyor

```xml
<bean id="myBean" class="..." init-method="myInıtMethod"/>
```

- ## @PostConstruct and @PreDestroy Annotations

JavaEE Annotations standardıdır. bu sebeple anotationlar javax.annotation.\* içerisindedir. bean'lerde initialize ve destroy sirasinda calisacak metodlarun üzerine konulur. beans.xml'de belirtilmemişse, bu anotationlar kullanılabilir.

# ServletContext
Bir web uygulamasında sadece bir ServletContext olabilir. 

ServletContextListener 'dan implemente etmiş bir sınıfı spring'de tanımlarsak, ServletContext init olduğunda, yani uygulama deploy olduğunda ve uygulama durduğunda çalışacak eventleri tanımlayabiliriz.

Herhangi bir servlet içinde servlet'in kendi configlerine erişmek için bu ServletConfig kullanılır:

```java
ServletConfig servletConfig = getServletConfig(); //getServletConfig javax.servlet.Servlet sınıfında zaten tanımlıdır.
String servletName = servletConfig.getInitParameter("ServletName");
```

Fakat tüm servlet'lerde kullanılacak olan bilgiler ServletContext'ten çekilir:

```java
ServletContext servletContext = getServletContext();
String projectOptions = servletContext.getInitParameter("projectOptions");
```

# request.getSession().getServletContext() vs getServletContext()
getServletContext() Servlet classın'dan extend eden sınıfılarda direk kullanılabilir bir metoddur. oysa request objesi herhangi bir kod satırında kullanılabilir. request'ten de ServletContext'e erişilebilir. İkisi aynı instance'ı döndürürler.

# RequestContextListener
Bu sınıftan implemente etmiş bir sınıfı spring'e tanıttığımızda request oluştuğundaki event'lerimizi tanımlayabiliriz.

# DispatcherServlet
Dispatch türkçe kelime anlamı: sevk etmek. yazılım dünyasında metoda/fonksiyona mesaj(parametre) yollama(sevk etme) anlamında kullanılır.

SpringMVC'de front controller'ın ismidir.

DispatcherServlet, HandlerMapping'e basvurararak ilgili Controller bilgisine ulasir. Varsayilan olarak BeanNameUrlHandlerMapping handler olarak kullanilir.

her servlet'in bir url'si vardır. alt-url'ler 1 adet servlet sınıfının kodunun içinde if blokları ile dağıtılır. fakat Sping MVC bunu bizim için otomatik yapar. Spring MVC'nin servlet'i org.springframework.web.servlet.DispatcherServlet'dir.

# WebApplicationContext
ServletContext'i barındırır. ApplicationContext'i web uygulamalar için uyarlandığı bir türevidir.

örnek web.xml'imizde aşağıdaki servlet tanımımızda spring MVC'nin config'lerini değiştiriyoruz.

```xml
<servlet>
     <servlet-name>mvc-dispatcher-1</servlet-name>
     <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
     <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/dispatcher-servlet-context-1.xml</param-value>
     </init-param>
     <load-on-startup>1</load-on-startup>
</servlet>

<servlet-mapping>
     <servlet-name>mvc-dispatcher-1</servlet-name>
     <url-pattern>/app1/*</url-pattern>
</servlet-mapping>
```

Yukarıkida param-value'daki dispatcher-servlet-context-1.xml içerisinde sadece o servlet için kullanılacak Bean tanımlarımız olabilir.

Bu tanımı özellikle servlet için yapmak durumundayız. çünkü web projeleri war dosyalarından oluşur. app server'lar war dosyalarını standartlar gereği, önce web.xml'ini okur. bu sebeple servlet sınfımızın spring tarafından yönetildini app server'a belirtmemiz gerekmektedir.

Yukarıdaki xml'de, servlet ile aynı seviyede ContextLoaderListener tanıtırsak, WebApplicationContext'imizden bağımsız, tüm uygulamadan çağrılabilen ApplicationContext oluşturmuş oluruz. ContextLoaderListener default olarak /WEB-INF/applicationContext.xml dosyasını okur.

```xml
<listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>
```

Eğer default xml path'ini değiştirmek istersek yine aynı xml seviyesine bunu eklememiz yeterli olacaktır:

```xml
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>/WEB-INF/context1.xml, /WEB-INF/context2.xml</param-value>
</context-param>
```

Yukarıdaki gibi birçok dispatcher-servlet aynı projede kullanabiliriz.

Büyük resimden bakıldığında; ApplicationContext root-context iken, WebApplicationContext child-context'tir.

Kısaca özetlersek:

Tek bir jar içerisinde aşağıdakiler olabilir:

```
ApplicationContext     > WebApplicationContext-1 > servlet-1
                                                   servlet-2 (dispatcher-servlet)
                                                   servlet-3 (dispatcher-servlet)
                                                   servlet-4
                                                   ...
                         WebApplicationContext-2 > servlet 9
                                                   ...
ApplicationContext-2 > ... ... ...
                       ... ... ...
```

Yukarıdaki örnekte;
- ServletContext; her "WebApplicationContext-\*" için ayrıdır.
- ServletConfig; her "servlet-\*" için ayrıdır.

# Spring Boot
sağladığı en temel yetenek: öntanımlı konfigürasyonlardır. diğer tüm özellikler buradan türer. örnekler:
- Konfigürasyon yapmadan Embeed servler container getiriyor. böylece app server'a atma ihtiyacı duyulmuyor.
- projeye lib olarak database ekledik. eğer database ayarları yapılmadıysa in-memory database açıyor. bunu @EnableAutoConfiguration ile yapıyoruz.

# spring boot version history
| version | released year | change log                                                                                                                                                                   |
|---------|---------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1.1     | June 2014     | improved templating support, gemfire support, auto configuration for elasticsearch and apache solr.                                                                          |
| 1.2     | March 2015    | upgrade to servlet 3.1/tomcat 8/jetty 9, spring 4.1 upgrade, support for banner/jms/SpringBootApplication annotation.                                                        |
| 1.3     | December 2016 | spring 4.2 upgrade, new spring-boot-devtools, auto configuration for caching technologies(ehcache, hazelcast, redis, guava and|infinispan) and fully executable jar support. |
| 1.4     | January 2017  | spring 4.3 upgrade, couchbase/neo4j support, analysis of startup failures and RestTemplateBuilder.                                                                           |
| 1.5     | February 2017 | support for kafka/ldap, third party library upgrades, deprecation of CRaSH support and actuator loggers endpoint to modify|application log levels on the fly.                |
| 2.0     |               |                                                                                                                                                                              |
| 2.1     |               |                                                                                                                                                                              |
| 2.2     |               |                                                                                                                                                                              |

Her sürüm için ayrı ayrı, changelog'lar özet olarak burada açıklanmaktadır: https://github.com/spring-projects/spring-boot/wiki/Spring-Boot-2.2-Release-Notes


# @SpringBootApplication
bu anotasyon şu 3'ünü içeriyor:

- @Configuration (başka başlıkta anlatılıyor)

- @EnableAutoConfiguration (örneğin projeye lib olarak database ekledik. eğer database ayarları yapılmadıysa in-memory database açıyor. yukarıdaki ikinci madde.)

- @ComponentScan (eğer parantez içinde parametre vermezsek, sadece bulunduğu sınıfın paketindeki ve altpaketlerdeki sınıfları Spring ayarlarına kabul ediyor.)

# Sunucu ihtiyacı
Spring sadece servlet container'a ihtiyaç duyuyor. Oysa javaee bir spesifikasyon ve komple tüm library'ler sunucu içerisinde.

# spEL (yada spring Expression Language)

2 temel işlevi vardır:
- regex işlemleri
- bean'e property atamalarında kullanılan özel bir syntax dilidir

bean property atamalarına örnekler verelim:

örnek:
 
```xml
<property name="message" value="Available thread number is #{100+1}"/>
```
 
yada
 
```java
@Value("#{100+1}")
private String message;
```
 
Her property set edildğinde (her yeni instance oluşturulduğunda), set edilecek 1 artacaktır. ilk değer 100 olacaktır.

Diğer örnekler:

Diğer örnekler:

```java
@Value("#{1 == 1}") // true
private boolean equal;
 
@Value("#{1 eq 1}") // true
private boolean equalAlphabetic;
 
@Value("#{1 != 1}") // false
private boolean notEqual;
 
@Value("#{1 ne 1}") // false
private boolean notEqualAlphabetic;
 
@Value("#{1 < 1}") // false
private boolean lessThan;
 
@Value("#{1 lt 1}") // false
private boolean lessThanAlphabetic;
 
@Value("#{1 <= 1}") // true
private boolean lessThanOrEqual;
 
@Value("#{1 le 1}") // true
private boolean lessThanOrEqualAlphabetic;
 
@Value("#{1 > 1}") // false
private boolean greaterThan;
 
@Value("#{1 gt 1}") // false
private boolean greaterThanAlphabetic;
 
@Value("#{1 >= 1}") // true
private boolean greaterThanOrEqual;
 
@Value("#{1 ge 1}") // true
private boolean greaterThanOrEqualAlphabetic;

@Value("#{250 > 200 && 200 < 4000}") // true
private boolean and; 
 
@Value("#{250 > 200 and 200 < 4000}") // true
private boolean andAlphabetic;
 
@Value("#{400 > 300 || 150 < 100}") // true
private boolean or;
 
@Value("#{400 > 300 or 150 < 100}") // true
private boolean orAlphabetic;
 
@Value("#{!true}") // false
private boolean not;
 
@Value("#{not true}") // false
private boolean notAlphabetic;

@Value("#{'100' matches '\\d+' }") // true
private boolean validNumericStringResult;
 
@Value("#{'100fghdjf' matches '\\d+' }") // false
private boolean invalidNumericStringResult;
 
@Value("#{'valid alphabetic string' matches '[a-zA-Z\\s]+' }") // true
private boolean validAlphabeticStringResult;
 
@Value("#{'invalid alphabetic string #$1' matches '[a-zA-Z\\s]+' }") // false
private boolean invalidAlphabeticStringResult;
 
@Value("#{someBean.someValue matches '\d+'}") // true if someValue contains only digits
private boolean validNumericValue;
```

spEL aynı zamanda regex işlemlerini de yapıyor:
 
```java
Expression expression = expressionParser.parseExpression("'Any string'.bytes");
Expression expression = expressionParser.parseExpression("'Any string'.replace(\" \", \"\").length()");
Integer result = (Integer) expression.getValue();
```

# Annotation based vs Java based (JavaConfig) vs XML based configuration
Spring kendi kütüphaneleri ile "Annotation based" veya "XML based" işlem sağlayabilir. fakat spring JSR standartları (java standartları) dışında kendi paketlerini sunmaktadır. Spring dökümanlarında; "Annotation based"'Den kasıt spring'in kendi kütüphaneleridir. Spring aynı zamanda Java standart anotationları ile de işlem yapabilmemizi sağladığı için "Java based" configuration olarak ayrı bir kavram mevcuttur. Oysa JavaEE kitaplarında "Annotation based vs Java based" kavramları aynı şeye denk gelmektedir, çünkü JavaEE zaten sadece JSR kütüphanelerini kullanmaktadır.

# Javaee dezavantajlar
- application server specific deployment descriptors

- lots of xml files even the most basic EJB - Güncel sürümlerde XML yerine anotation kullanılıyor (spring bu durumu daha önceden çözdüğü için sprig projesi ortaya çıkmıştı. Güncel sürümlerde bu sebep kalktı.)

- sunucu ayağa kalkma süresi (çünkü tüm kütüphaneler sunucu içerisinde) - Güncel sürümlerde sunucular çok hızlandı spring daha büyüdüğü için kısmen daha yavaşladı

- sunucuya bağımlılık

# spring dezavantajlar

- app sever üzerinde çalıştırılırsa ticari destek alınamaz

- app server'sız çalıştırılıdığında monitoring tool'ları genelde javaee sunucularına uyumlu olduğundan, monitoring işlemlerinde sıkıntılar yaşanabilir

# spring-aop
spring security web servise gelen istekleri kontrol ederken, loggining mekanisı debug logları atarken, hep AOP'den yararlanır.

# aspectJ kullanımı

```java
import org.aspectj.lang.*;

@Aspect
public class MyLoggingAspect 
{
    @Before("execution(# com.mycustompackage.MyService.myMethod(..))")

    public void beforeMyMethod(JoinPoint joinpoint)

    {
        System.out.println("Before "+joinpoint.getSignature().getName());
    }

    @AfterThrowing(

            pointcut="execution(# com.mycustompackage.MyService.myMethod(..))",

            throwing="exception")

    public void afterMyMethodThrowException(JoinPoint joinPoint,Throwable exception)
    {
        System.out.println("After throw exception");
        System.out.println("Exception: "+exception);
    }
}
```

diğer bazı anotationlar:

- AfterReturning - it returns (does not throws an exception)

- After -> return or throws an exception

aspect işlemleri java-core'da desteklenmediği için bazı trick'lerle gerçekleştirilir. bu trick'lere __weawing__ denir.

weawing işlemi 3 farklı şekilde yapılabilir:

- derleme esnasında. javada bir proxy sınıf yaratılır. öncesinde ve sonrasında çalışcak metodlar burada çağrılır.

- özel bir classloader ile yüklenecek sınıfın bytecode'u ile oynanır

- runtime sırasında AOP modülü dinamik olarak bir proxy sınıfı üretir. Spring-aspect modülü bu şekilde çalışır.

# Pointcut
aspect metodlarını gruplandırmak için kullanılır. direk örnek üzerinden gidersek;

```java
@Aspect
public class Audience {

  @Pointcut("execution(public String com.mypackage.myaction(Long) )")
  public void performance() {} 

  @Before("performance()")
  public void myMethod1() {
    //do something
  }

  @Before("performance()")
  public void myMethod2() {
    //do something
  }

  @AfterReturning("performance()")
  public void myMethod3() {
    //do something
  }
}
```

YUkarıda before, AfterReturning gibi tüm metodlar aynı sınıfta olan Pointcut metodu performance'ı işaret ediyor. böylece Pointcut'ta bir değişiklik olduğunda tüm aspectlerin aksiyon alması gereken nokta tek bir yerden belirlenmiş oluyor.

Yukarıda performance() metodu tanımlamasına (anotationu ile birlikte) __pointcut signature__ deniliyor.

# pointcut designator (yada PCD)

@Pointcut içerisindeki tanımlaya verilen isimdir. Birçok PCD vardır. örnek:

Aşağıdaki PCD, public/private ve protected olan tüm Class1 sınfı içindeki metodları kapsamaktadır.

> @Pointcut("execution(* com.package.Class1.*(..))")

Aşağıdaki PCD, sadece Long alan findById metodunu kapsamaktadır.

> @Pointcut("execution(public String com.package.Class1.findById(Long))")

Aşağıdaki PCD, Class1 içindeki tüm metodları kapsamaktadır.

> @Pointcut("within(com.package.Class1)")

Aşağıdaki PCD, find ile başlayan ve sadece 1 adet long parametresi kabul eden tüm metodları kapsamaktadır:

> @Pointcut("execution(* *..find*(Long))")

Aşağıdaki PCD, find ile başlayan ve ilk parametresinde long kabul eden tüm metodları kapsamaktadır:

> @Pointcut("execution(* *..find*(Long,..))")

Aşağıdaki PCD, Repository anotation'u içeren sınıfın tüm metodlarını kapsamaktadır.

> @Pointcut("@target(org.springframework.stereotype.Repository)")

Aşağıdaki PCD, Entity anotation'unu içeren nesneleri parametre olarak kabul eden tüm metodları kapsamaktadır

> @Pointcut("@args(org.baeldung.aop.annotations.Entity)")

Aşağıda iki adet PCD birleştirilmiştir:

```java
@Pointcut("@target(org.springframework.stereotype.Repository)")
public void repositoryMethods() {}
 
@Pointcut("execution(* *..create*(Long,..))")
public void firstLongParamMethods() {}
 
@Pointcut("repositoryMethods() && firstLongParamMethods()")
public void entityCreationMethods() {}
```

# @Around
bir Pointcut'ı referans etmiş tüm aspect metodlarını harmanlayabiliriz.

direk örnek üzerinden gidelim:

```java
@Aspect
public class Audience {

  @Pointcut("execution(*# concert.Performance.perform(..))")
  public void performance() {}

  @Around("performance()")
  public void watchPerformance(ProceedingJoinPoint jp) {

        System.out.println("before all aspects");
        jp.proceed();
        System.out.println("after all aspects");
  }
}
```

# handling parameters
aspect ettiğimiz metoda geçilen parametreleri de alabiliriz:

```java
@Pointcut(
"execution(# soundsystem.CompactDisc.playTrack(int)) " +
"&& args(trackNumber)")
public void trackPlayed(int trackNumber) {}

@Before("trackPlayed(trackNumber)")
public void countTrack(int trackNumber) {

    //do something with trackNumber
}
```

# dependency yönetimi
maven-pom'da şu eklenirse:

```xml
<parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>1.5.2.RELEASE</version>
</parent>
```

spring'in 1.5.2 versiyonunun tüm dependency'leri artık tanımlanmış (eklenmemiş,sadece tanımlanmış!) olur. Artık aşağıdaki gibi bir kütüphane ekleyebiliriz:

```xml
<dependencies>
        <dependency>
             <groupId>org.springframework.boot</groupId>
             <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
</dependency>
```

spring-boot-starter-web'in sürümünü belirtmeye gerek yok çünkü zaten parent'ta tanımlanmıştı.

spring-boot-starter-web projesi default olarak embeeded tomcat kullanır. biz bunun yerine jetty kullanmak istersek aşağıdakini yazmamı yeterli olacaktır:

```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <exclusions>
            <exclusion>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-tomcat</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jetty</artifactId>
    </dependency>
</dependencies>
```

# Starters
spring-boot-starter-XYZ formatında yazılırlar. XYZ uygulamamızın tipidir.

örneğin;

spring-boot-starter-web; spring-mvc ve tomcat embeded getirir.

spring-boot-starter-jersey; web'e bir alternatiftir. spring-mvc yerine Apache Jersey kullanır.

spring starter'lar spring-boot-dependencies'i kullanılarlar. spring-boot-dependencies sadece her paketin versiyonunu barındırıyor. oysa stretler'lar birçok paketi bir arada barındırıyor. örneğin web dediğimizde tomcat vs yüklenmektedir.

# stereotype
kelime anlamı: klişe, basmakalıp.

bu terim javaee ve spring'de kullanılan bir terimdir. java core'a ait değil. 

- javaEE'de; javaee tarafından yazılmış bir (custom) anotationdur. bu anotation javaee'nin kendi yazdığı bazı anotationların içinde kullanılır. bu anotation'un bir işlevi yoktur. amaç sadece gruplandırmak (mark etmektir).

- spring'de; asagidaki anotation'lar org.springframework.stereotype paketi altındadır. amaç (javaee'dekine benzer olarak) sadece gruplandırmaktır.

  - Component
  - Controller
  - Indexed
  - Repository
  - Service

# profiles
uygulama içinde interfaceler @autowired ederiz. runtime sırasında hangi implementasyonun instance olarak ayarlanacağına spring profiller aracılığı ile karar verir.

örnek:
@autowired ile WeatherService ekledik. 

bir implementasyonumuz da bu olsun:

```java
@Service
@Profile({"sunny", "default"})
public class SunnyDayService implements WeatherService {
   ...
}
```

applciation.properties'te;

```
spring.profiles.active=sunny
```

satırı olmalıdır. "default" isimli profil özeldir. dfault aktif hale gelir.

Eğer bir profilde bir component'in hiç scan edilmemesini istiyorsak ünlem işareti kullanırız. örnek:

```java
@Profile({"!sunny","default"})
```

## default implementasyon
spring veya javaee'de bir interface'yi bir sınıfın içinde inject ettiğimiz zaman, framework o nesneye path'te olan bir implementasyonunu atar. path'te en az bir inplementasyon yok ise hata fırlatır.

Aşağıdaki örnekte; request o anda isteği yapan request bilgilerini içerir.

```java
@Autowired
private HttpServletRequest request;
```

Bu durum yukarıda bahsi edilen default implementasyonla bağlantılı değildir. Burada instance'ı ele alıyoruz, yukarıda bahsi edilen durum hangi implementasyonun (yani sınıfın) kullanılacağıdır.

Eğer birden fazla implementasyon classpath'te ise, o zaman önceliği vereceğimiz sınıfın tepesine @Primary yazmamız gerekmektedir.

# conditional beans

MyConditions içerisindeki matches metodunun dönüşüne göre Bean tanımlanıyor yada tanımlanmıyor.

```java
@Bean
@conditional(MyConditions.class)
MyBean myBean(){
  return new MyBean();
}
```

```java
class MyConditions implements Condition {

  boolean matches( ConditionContext cc, AnnotatedTypeMetadata meta){

      // ConditionContext gives info about the environment: classloader, beanFactory...

      // AnnotatedTypeMetadata gives info about the Bean which will be included or not

      if( context.getEnvironment("my_keyword") == null ){

           return false;
      }
      return true;

  }
}

```

# application.properties

spring basladiginda default olarak proje içindeki application.properties dosyasını okur. farklı dosya verilmek istenirse;

> -Dspring.profiles.active=dev -Dspring.config.location=file:C:/application.yml

profillerde dosya içinde --- (üç çizgi) ile ayrışmalıdır:

```yml
spring:
  profiles: dev

prop1: val1
prop2: val2

---

spring:
  profiles: prod

prop1: val1
prop2: val2
  
```

3 çizgi yml formatının bir özelliğidir. kaynak: https://yaml.org/spec/current.html#document%20boundary%20marker/ ("4.3.2. Document Boundary Markers" başlığı) (archive date: 25/10/2019)

# bootstrap.yml vs application.yml
bootstrap dosyası microservisler ile karşımıza çıktı. config serverdan her servis configlerini aldığı için, spring boot uygulaması ayağa kalkmadan bazı propertieleri tutması gerekli: örneğin; config server'ın portu ve ip bilgisi. microservis; config'den aldığı port numarası bilgisi ile kendisini hizmete açacaktır.

# Aware
türkçe kelime anamı: farkında, tetikte, haberdar

ServletContextAware gibi birçok aware interfacesi vardır. ServletContextAware örnek olarak alınırsa, bu sınıftan implemente ettiğimiz her bean ServletContext'i inject etmesine gerek kalmaz. örnek:

```java
@RestController("/mycontroller")
public myController implements ServletContextAware {

    private ServletContext context;

    @Override
    public void setServletContext(ServletContext context) {

        //setServletContext ServletContextAware interface'sinin bir metodu. "context" private değerine istediğimiz ismi verebiliriz.
        
        this.context = context;
    }
}
```

# sping security
spring varsayılan olarak authantication tarafı için birçok implementasyonu destekliyor: HTTP Basic, HTTP digest, LDAP... Bunların içinde JWT(JSON Web Token) yok. JWT için implemetasyonu yazılımcının kendisi yapması gerekiyor. Zaten JWT bir security metodu değildir, JWT data transferi yöntemidir.

## Spring security modülleri:

- spring-security-core.jar
  core spring paket'i. aşağıdaki java paketlerini içeriyor: 
  - org.springframework.security.core
  - org.springframework.security.access
  - org.springframework.security.authentication
  - org.springframework.security.provisioning 

- spring-security-remoting.jar

  remote method calling için gerekli.

- spring-security-web.jar

  url based servlet control. filtreler buranın içinde.

- spring-security-ldap.jar

- spring-security-oauth2-core.jar

- spring-security-oauth2-client.jar

  client tarafta java uygulaması varsa bu client kullanılabilir.

- ve diğer modüller

## ayarlar

asagidaki sınfıta istediğimiz ayarlı belirliyoruz:

```java
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {

 @Override
 protected void configure(HttpSecurity http) throws Exception {

  http
    .authorizeRequests()
     .antMatchers("/css/**", "/index").permitAll()
     .antMatchers("/user/**").hasRole("USER")
     .and()
    .formLogin().loginPage("/login").failureUrl("/login-error");
 }

 @Autowired
 public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {

  auth
   .inMemoryAuthentication()
    .withUser(User.withDefaultPasswordEncoder().username("user").password("password").roles("USER"));
 }
}
```

Artık controller taraflarında ekstra bir ayar yapmaya gerek kalmıyor.

## Role
Roller username, password ile aynı tabloda bir string şeklinde saklanabilir.

## SecurityContext
bu sınıf tüm login olmuş kullanıcıların listesini tutar. kullanıcıları Authentication objesi ile saklar.

## SecurityContextHolder
SecurityContext'e direk erişim tavsiye edilmez. SecurityContextHolder aracılığı ile erişebiliriz.

## Authentication
bir interface'dir. birçok implementasyonu var. örnek:
- UsernamePasswordAuthenticationToken. UsernamePasswordAuthenticationToken'a göre; login olmaya çalışan kullanıcı username ve password bilgisini göndermesi yeterlidir.

## AuthenticationManager
- Authentication implementasyonu (yukarıdaki örnekteki UsernamePasswordAuthenticationToken) AuthenticationManager'a pass edilir.
- AuthenticationManager kendi içinde AuthenticationProvider aracılığı ile kullanıcıyı login eder yada hata fırlatır.
- AuthenticationManager içinde birden fazla AuthenticationProvider olabilir.
- Kullanıcı login olabilirse; AuthenticationManager bir Authentication instance'ı döndürür. bu döndürülen instance SecurityContextHolder.getContext().setAuthentication(…​) metoduna yollanır. setAuthentication metodu o andaki user'ın authantication instance'ını değiştirecektir.

"Spring security diagram" internette aratıldığında açıklayıcı görseller bulunabilir.

## UserDetailsService
interfacedir. birçok implementasyonu var. örnek: InMemoryUserDetailsManager. UserDetailsService sadece şu metodu içerir:

```java
public org.springframework.security.userdetails.UserDetails loadUserByUsername(String username) throws UsernameNotFoundException
```

Spring arkaplanda loadUserByUsername metodunu çağırır. Kullanıcının gönderdiği credentials bilgileri ile UserDetails'i karşılaştırır. Eğer bilgiler uyuşuyorsa kullanıcıyı login eder.

## Subject vs Principal vs User
Bilişim güvenliği dünyasında;

- subject; bir objeye erişmek için izin isteyen varlıktır. Örnek: web-browser'dan login olmaya çalışan ve daha sonra isteklerde bulunan web-tarayıcı/user bir subject'tir. sunucu/erişilmeye çalışılan yazılım parçaları ise bu durumda obje olur.

- Principal ise; subject'in bir türevidir. bir hesap olduğunu temsil eder. bu hesabı bir otomat, atm, bir kullanıcı, yazılım kullanıyor olabilir.

- User ise; Principal'in bir türevidir. sadece kullanıcıyı temsil eder.

"apparmor vs selinux" başlığında da benzeri isimlendirme kullanılmaktadır.

## SecurityContext metodları
- getAuthentication
- setAuthentication

## Authentication metodları:
- getCredentials: o andaki isteği yapan user'ın credential'i döndürür. credential tam olarak şu demek: kullanıcının login olabilmesi için kullandığı token/şifre veya bunların kombinasyonlarının tutulduğu objedir.

- getDetails: o andaki isteği yapan hakkında ekstra bilgiler içerir: örnek: IP.

- getPrincipal: o andaki isteği yapanın hesabı ile ilgili bilgileri içerir. örnek: username, password, roles, email.

- isAuthenticated: isteği yapan kullanıcının token'ının onaylanmış olup olmadığı (login olup olmadığı)

- setAuthenticated

- getAuthorities: GrantedAuthority'den implemente etmiş obje listesi döner. Her GrantedAuthority bir işlemin yetkisini ifade eder. örnek: READ_AUTHORITY, WRITE_PRIVILEGE.

## Herhangi bir kod satırında kullanıcı bilgileri çekme
herhangi bir satırda;

```java
Authentication auth = SecurityContextHolder.getContext().getAuthentication();

auth.getPrincipal();
```

metodları çağrılabilir. getPrincipal'ı çağırmak yerine isteğe bağlı controller requestinde şu parametre eklenebilir:

```java
@RequestMapping("/messages/inbox")

public ModelAndView findMessages(@AuthenticationPrincipal CustomUser customUser) {

     //some code here
}
```

## role vs GrantedAuthority
Her role bir GrantedAuthority kümesidir. Yazılımcı; role listesi verildiğinde GrantedAuthority listesi dönen bir metod sunmalıdır. Bunu da UserDetails.getAuthorities() metodunu implemente ederek yapmalıdır.

## configure metodu içeriği
http objesinin aşağıdaki gibi metodlara ayırmakta fayda var. bu şekilde daha okunaklı oluyor.

```java
@Override
protected void configure(HttpSecurity http) throws Exception {

         // hepsini bir arada yazmamak için metodlara bölüp
         // gruplandırmış olduk
         csrf(http);
         login(http); 
         logout(http); 
         exceptionHandling(http);
         authorizeRequests(http);
}

protected void csrf(HttpSecurity http) throws Exception {

    http
    .csrf().enable();
    /*banka sitemiz olsun. Kullanıcı login oldu ve logout olmadan baska siteye gitti (X sitesi). X kendi içinde bizim bankamıza istek yapabilir. İstek yaparken cookie'yi barındıramayacağı için (çünkü JSESSIONID yada Session-ID bankamıza ait domain spesifik cookie'ye bagli saklaniyor) isteği geçersiz olacaktır. fakat cookie'ler her zaman %100 güven sağlayamıyor. bazen farklı sitelerce yada web tarayıcısı dışından da çekilebiliyor. örnek:
    
    - kötü niyetli web tarayıcı eklentileri ve bug'ları
    - web tarayıcı bug'ları
    - işletim sisteminde kurulu native uygulamanın web tarayıcısından cookie'leri çekmesi
    - X sitesi iframe içinde bankamızı açar ve üzerinde css işlemleri ile bir butonuna basmamızı sağlayabilir...
    
    gibi açıklarla cookie çalınabiliyor veya cookie bir şekilde kullanılarak adımıza request atılabiliyor.

    bu durumu engellemek için spring'in çözümü var. bu çözümde her istek için için sunucu tarafta o anda random bir token üretiliyor. buna csrf-token deniliyor. token client tarafa yollanıyor ve cookie'de saklanmıyor. direk sayfaya gömülü oluyor. bu değeri yazılımcının client tarafta her istekte yollaması gerekiyor. burada yazılımcının da bir şey yapmasına gerek kalmıyor her form alanının içine otomatik spring hidden-input olarak bu değeri sokuyor eğer sayfa jsp/jsf ise. fakat javascript olan sayfalar için iş yaızlımcının kendisine düşüyor. 
    */
}

protected void login(HttpSecurity http) throws Exception {

  http
  .formLogin() // cookie based form login için gerekli ayarlar

          .loginPage("/login") 
          //web sayfası olarak login formunun olduğu sayfa url'si

          .loginProcessingUrl("/loginservice") 
          // /login formu ve diğer login olmak isteyenler buraya istek yapacakalar

          .failureUrl("/loginfailed") 
          //login işlemi başarısız olursa, login http isteği buraya yönlendirilir (redirection)

          .successHandler(authenticationSuccessHandler)
          //success işlemleri eventlerinin tanımlamaları

          .failureHandler(authenticationFailureHandler);
          //fail işlemleri eventlerinin tanımlamaları
}

protected void logout(HttpSecurity http) throws Exception {

  http
      .logout() 
      //logout config ayarları

          .logoutUrl("/logout") 
          // default: /logout

          .logoutSuccessUrl("/my/index") 
          // default: /login?logout

          .logoutSuccessHandler(logoutSuccessHandler) 
          // eger bu set edilmisse logoutSuccessUrl ignore edilir

          .addLogoutHandler(logoutHandler)

          .deleteCookies("JSESSIONID");
          // auto olarak silinmesi istenen cookie'ler
}

protected void exceptionHandling(HttpSecurity http) throws Exception {

  http
     .exceptionHandling()
          .authenticationEntryPoint(new Http403ForbiddenEntryPoint());
          //when someone try to access a URL which is not pemitted

}

protected void authorizeRequests(HttpSecurity http) throws Exception {

  http.
     authorizeRequests()

          .mvcMatchers("/login/impersonate*").hasRole(ADMIN_ROLE)
          // only ADMIN_ROLE users can access these URLs

          .mvcMatchers("/login/anotherpage*").hasAuthority(USER_ROLE_1)

          .mvcMatchers("/logout/impersonate*").authenticated()
          // any authenticated user can  access these URLs

          .mvcMatchers("/**").permitAll();
          // allow all (even anonym) users can access these URL's.
          // mvcMatchers("/**") yerine anyRequest()'de kullanılabilir.

          //not: buradaki config'lerde mvcMatchers yerine antMatchers kullanılabilir. fakat MVC request'i ise mvc tercih edilmelidir.

          //not: mvcMatchers("/**") kısmı, authorizeRequestsher() 'ın her zaman sonunda çağrılmalıdır. çünkü authorizeRequests() kısmı URL'leri spesifikten genele doğru bir sıra ile ayarlanmalıdır. farklı bir örnek:
          .antMatchers("/auth/admin/*").hasAuthority("ADMIN")
          .antMatchers("/auth/*").hasAnyAuthority("ADMIN", "USER")
}
```

## Session-based Authentication vs Token-based Authentication
Session-based'de bir random bir id yaratılır ve login olmuş kullanıcının referansı bu olur. kullanıcı bilgileri sunucudadır. JavaEE ve Spring'de bu session-Id default olarak "JsessionID" olarak adlandırılır. yani statefull'dır. burada token; session-id'dir.

Token-based'de ise token random bir string değildir. şifreli ve kullanıcının session bilgilerini içeren bir stringdir. dolayısı ile bilgiler sunucuda tutulmaz. yani stateless'dır. JWT, Token-based'e en iyi örnektir.

jwt içerisindeki blok şifrelenmiştir ve sadece sunucu tarafında açılıp/okunabilir. sunucu taraf kimlere jwt verdiğini bilmez. jwt bir kere üretilir ve sonra salınır. dolayısı ile jwt her geldiğinde içindeki bilgilerde olan son kullanma tarihine bakılır. son kullanma tarihi geçmişse artık bu token geçersizdir. jwt içinde son kullanma tarihi ve userId olması yeterlidir. zaten data kimse tarafından değiştiirlemeyeceği için sunucu bunu güvenle kullanabilir.

jwt'deki sakınca şudur: eğer jwt token'ını hacker çalarsa, o kişi adına jwt'nin son kullanma tarihine kadar işlem yapabilir. hackerın çaldığını sunucu ve client bilsede bunu engelleyemezler. çünkü jwt'lerin geçerliliği sunucu tarafta tutulmamaktadır. sunucu tarafta hiçbir bilgi tutulmamaktadır. bu sebeple genelde jwt'nin son kullanma tarihi çok kısa tutulmaktadır. bu sebeple jwt'de refresh token atyapısı mevcuttur. (baska başlıkta anlatılıyor)

Token-based Authentication'ın avantajı sunucu tarafta datanın tutulmamasıdır. sunucu tarafta birnden fazla aynı işi yapan sunucuları loadbalancer ile bağladığımızı düşünelim. her login datası güncellendiğinde tüm sunucuların senkron olması gerekceke. senkronizasyon işlemi hem sistemi yavaşlatacak hemde sunucu çöküşlerinde sorun yaratacak. cluster'ın olaylarında konfigürasyon gerekecek. jwt bizi bu sorunlardan kurtarıyor. özellikle load balancing yaptığımız sunucular fiziksel olarak uzak mesafelerde ise "Session-based Authentication" facialara sebep olabilir.

## RedirectStrategy
security modülü içinde olan bir Interface'dir. DefaultRedirectStrategy isminde bir implementasyonu mevcut. RedirectStrategy, filter'ların yada authanticationSuccessHandler gibi sınıfıların içinde inject edilir. bu inject edilen nesne ile filter içerisinde gelen istekleri farklı bir url'ye yönlendirmemiz mümkündür. örneğin; login olmuş ve header'ında admin olan kullanıcıyı admin sayfasına yönlendirebiliriz. admin olmayanları ise farklı bir syafaya yönlendiririz.

DefaultRedirectStrategy, sendRedirect(request, response, url); metodunu içerir. url burada yönlendireceğimiz path'tir.

# forward vs redirect
http isteklerinde forward; sunucuya gelen isteği  bir yere yönlendirir. bunu yaparken client'ın bu yönlendirmeden hiçbir haberi olmaz. oysa redirect'te, client'a 30x kodunda repsonse dönülür. aynı response'ta client'ın yapması gereken yeni isteğin nereye olacağı bilgisi de dönülüdür. burada client ikinci isteği yapar. web tarayıcıları bu isteği otomatik (son kullanıcıya sormadan yapar). 

forward vs redirect birçok yerde kullanılan metdo isimleridir. örnek:

- response.sendRedirect("login.jsp");

- request.getRequestDispatcher("login.jsp").forward(request, response);

Dispatch türkçe kelime anlamı: sevk etmek. yazılım dünyasında metoda/fonksiyona mesaj(parametre) yollama(sevk etme) anlamında kullanılır.

# @EnableResourceServer
bu anotasyonun atıldığı service auth2.0 API'si olmaktadır (başka yerde auth2.0 API nedir anlatılıyor.)

# @EnableOAuth2Sso

bu anotasyonun olduğu service auth2.0 client'i oluyor. bu anotasyon aşağıdaki iki anotasyonu içermektedir:

- @EnableOAuth2Client : OAuth2RestTemplate ile yaptığımız isteklerde access-token'ı karşı tarafa otomatik yollamaktadır.

- @EnableConfigurationProperties(OAuth2SsoProperties.class) : eğer yetkisiz istek gerçekleşirse gelen isteği otomatik olarak /login'e (daha doğrusu Authorization Server'a) yönlendirir.

# spring security örnek kod:

```java
@Service

public class CustomAuthenticationManager implements AuthenticationManager {

 @Override
 public Authentication authenticate(Authentication authentication) throws AuthenticationException {

      //authentication nesnesi otomatik dolduruldu spring tarafından. içinde user'ın login olmaya çalışırken yaptığı istekteki bilgiler var.

      // asagida username string'i kullanıcının formdan gönderdiği "username" alanıdır.

      // password ise password alanıdır.

      String username = authentication.getPrincipal() + "";

      String password = authentication.getCredentials() + "";

      // fetch from database

      // User user = dbCOnnection.fetch(username);

      // check password

      //get roles of user

      List<GrantedAuthority> grantedAuths = new ArrayList<>();

      grantedAuths.add(new SimpleGrantedAuthority("ROLE_USER"));

      if(username.equals("ahmet")) {

          throw new AuthenticationException("Engellenmis/bloke kullanıcı");

          //eğer throw edilmeyip null döndürülürse, spring bir sonraki auth-provider ile işlem yapmaya çalışacaktır.
    }

     return new UsernamePasswordAuthenticationToken(username, password, grantedAuths); 
     //bu constructor'ın içinde "super.setAuthenticated(true);" satırı mevcut.
 }
}
```

authenticate metodundan dönen Authentication instance'ı artık o kullanıcın principal ve credentials'ini tutuyor ve her tarafta bu objelere erişebiliyoruz. principal ve credentials birer java obje sınıfıdır. dolayısı ile buralarda istediğimiz herşeyi tutabiliriz.

CustomAuthenticationManager'ı spring'e kullanmasını belirtmeliyiz:

```java
@EnableWebSecurity //bu satır zaten vardı

public class SecurityConfig extends WebSecurityConfigurerAdapter { //bu satır zaten vardı

  @Autowired
  private CustomAuthenticationProvider authProvider;

  @Override
  protected void configure(AuthenticationManagerBuilder auth) throws Exception {

         auth.authenticationProvider(authProvider);
 } 
}
```

# AuthenticationException
AuthenticationException fırlatılacak olan sınıftır. BUnun birçok türevi vardır. Fakat tüm exception'lar sadece string error'u döndürür. farklı bir parametre eklemek istersek ya bu string alanına bir json yazmamız gerekecek yada daha sonraki aşamalarda devreye girecek kod bloklarına yeni kodlar eklememiz gerekecek.

AuthenticationException'dan türemiş bazı sınıflar: AccountStatusException, AccountExpiredExcepitn, DisabledException, LockedExcepitn, BadCredentialsExcepition, UserNameNotFoundExcepiton

# client taraftan login isteğinde username vs password haricinde değer yollama
Authenticate metodu sadece Authentication parametresi alır. "Authentication metodları" başlığına bakılırsa görüleceği credential, details ve principal birer objedir. yani custom bir Authentication nesnesi yaratıp buraya request parameterları ekleyebiliriz. bunun için bir filter eklememiz gerekli:

Securty config sınıfına bunlar eklenmelidir:

```java
@Override //burası zaten olmalı
protected void configure(HttpSecurity http) throws Exception {  //burası zaten olmalı

    http  //burası zaten olmalı

      .addFilter(authenticationFilter())

        .... 

      //addFilter yerine addFilterBefore, addFilterAfter gibi metodlar da mevcut.
}

public MySimpleFilter authenticationFilter() throws Exception {

    MySimpleFilter filter = new MySimpleFilter();

    filter.setAuthenticationManager(authenticationManagerBean());

    return filter;

}
```

Aynı zamanda filter sınıfımızı tanımlayalım:

```java
public class MySimpleFilter extends GenericFilterBean {

  public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain)

    throws IOException, ServletException {

      //get params from request

      //and create token object to pass to next filter or auth-provider

      UsernamePasswordAuthenticationToken token = ...

      chain.doFilter(req, res);
  }
}
```

Yukarıdaki UsernamePasswordAuthenticationToken nesnemizi custom bir obje yaparız ve kendi custom-auth-provider'ımızıda cast ederek kullanabiliriz.

GenericFilterBean'dan türemiş birçok hazır sınıf mevcuttur.

Eğer MySimpleFilter içinde "token.setAutanticated=true; ve SecurityContextHolder.getContext().setAuthentication(token);" yapıp o sesison'daki user'ı otantike yaparsek o istek için auth-provider kodu çalışmayacaktır.

Filterlar user login olmuşsa bile her istekte çalışır. auth-provider'a sadece login olmamışsa yönlendirilir.

# spring'in default filterlarının bazıları:

- ChannelProcessingFilter: en önce olan filter'dır. http'den gelenleri https'e yönlendirme, sendRedirect ile gelen yeni isteklerin nerelere yönlendirileceğini belirten tanımlar mevcut.

- SecurityContextPersistenceFilter: SecurityContextHolder ve HttpSession'ın o request için tanımlanmasını sağlıyor.

- ConcurrentSessionFilter: aynı anda, aynı kullanıcı iki farklı session ile login olabilir (örneği 2 ayrı web browser'dan). bunların yönetimini sağlayan filter'dır. burada bir önceki session iptal edilebilir yada devam etiririlebilir...

- AbstractAuthenticationProcessingFilter'dan türemiş sınıfların olduğu filter'dır. autt-proiver'a Authentication nesnesini hazırlarlar.

# JWT

spring'in içinde default jwt entegrasyonu yok. elle kod yazmka gerekli. BUnu yaparken Java'nın JWT kütüphaneleri mutlaka kullanılmalı, yoksa iş uzar. 

JWT ekleyeceksek security filter şart. JWT yapısında bu şekilde kullanıcıyı header'ındaki bilgi ile her istekte login olup olmadığını tespit edebiliriz.

JWT yapacaksak refreshToken, createToken gibi tüm metodlarımızı için rest-controller  açmamız gereklidir. bu metodlara tüm doğru user bilgisi olan kişiler erişebilmelidir. bunun için bir ROLE belirlemek gerek. BU role her user'da olmalı. çünkü herkes bu metodlara erişebilmelidir.

JWT'de login işleminide rest servisine bağlamamız gerekli. Login tamamen public bir metod/url olmalı. Login controller'a "@Autowired AuthenticationManager" 'ı inject edip, login metodunda token'ı oluşturup authenticationManager.authenticate(token) metodunu çağırmalıyız. auth-provider'ımızı burada çalışacaktır. ve login metodunun sonunda da kulanıcıya header'a eklemesi gerek JWT Token'ımızı dönmeliyiz.

# Method security
Main sınıfımıza @EnableGlobalMethodSecurity(securedEnabled = true) eklenmelidir. Daha sonra herhangi bir metodun yetkisini kısıtlmak istediğimizde o metodun tepesine anatation atarız. örnek:

```java
@Secured("ROLE_USER")
public String myMethod() {
    return "Hello";
}
```

# RestTemplate 
asagidaki gibi kullanımı olan rest client'tır. spring-web modülü içinde gelir.

```java
RestTemplate restTemplate = new RestTemplate();

People people = restTemplate.getForObject("http://google.com/people", People.class);

log.info(people.toString());
```

# TestRestTemplate
Bu sınıf RestTemplate'ten extend etmez fakat RestTemplate'i private olarak kendi içinde bulundurur. neredeyse tüm metodları RestTemplate'teki metodları direk çağırır. yani RestTemplate'i wrap eder. fakat ekstradan testleri kolaylaştırmak amaçlı bazı metodlar içerir. örnek: 

- basic auth için password ve username'i veririz, artık her istekte bunları header'da yollar.

- Constructor with HttpClientOption sunuyor. böylece options'ları constructor'da geçebiliyoruz.

Aynı zamanda TestRestTemplate exception fırlatmaz. onun yerine bazı noktalarda Assert metodları kullanır yada kod çalışmaya devam eder. böylece testlerimizde try-catch bloklarımızın sayısı azalır.

TestRestTemplate kesinlikle sadece test'ler için kullanılmalıdır.

# @Configuration

```java
@Configuration
public class MyClassConfig {

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }
}
```

artık TransferService bean'i uygulamamızın herhangi bir yerinden çağrılmak istendiğinde (contextten inject edilmek istendiğinde), "new TransferServiceImpl()" instance'ı çağrılacaktır.

Configuration'ın üstüne @Profile("development") gibi profiller tanımlanabilir.

@Bean anotasyonu projenin herhangi bir dizininde (componentScan içinde olmak şartıyla) kullanılabilir. ve o metodun dönüş değeri bean olarak tanımlanacaktır. fakat @configuration anotasyonu ile bu beanleri gruplamış oluyoruz. ve bazı profillerde istediğimiz bean'ler aktif olurken, diğer profillerde  bean'leri aktif edebiliriz. örnek:

```java
public class MainApp {

   public static void main(String[] args) {

      ApplicationContext ctx = new AnnotationConfigApplicationContext(MyClassConfig.class);

      TransferService ts = ctx.getBean(TransferService.class);

      ts.doSomething();
   }
}
```

# org.springframework.context.annotation.Import sınıfı
Anotation tanımımızın üstüne @Import(MyClass.class) yazabiliriz. bu şekilde o anotation'u barındıran sınıfta artık MyClass'ta olan herşey tanımlı olacaktır. MyClass'ın @Configuration barındıran bir sınıf olması şarttır.

Import sayesinde configuration'ları kolayca sınıflara grupandırıp tek bir sınıfta birleştirebiliriz. @Import, sadece @Configuration ile birlikte çalışabilmek için tasarlanmıştır.

# spring MVC
Rest supportu bu modül içindedir. ModelAndView objesi de bu modül içindedir.

## @ResponseBody
bu anotation yazılımcı tarafından kullanılmasa bile spring bunu default olarak yazılmış varsayara. bu anotation response değerimizi JSON/XML'e çevrileceğini belirtir.

## ModelAndView
Rest controllerımızı normal yazıyor ve gelen request'e cevap olarak ModelAndView döndürüyoruz.

```java
@Controller
class RegistrationController {

  @RequestMapping(value = "/register", method = RequestMethod.GET)
  public ModelAndView showRegister() {

    ModelAndView mav = new ModelAndView("register");

    mav.addObject("user", new User("Ahmet"));

    return mav;
  }
}
```

ModelAndView içinde 'model' ve 'jsp dosya path'i bilgisini barındırır. Spring "ViewResolver" sınıfında belirlendiği ayarlarla jsp'yi bulmaya çalışır. viewresolver config örneği;

```java
@Configuration
@EnableWebMvc
class WebConfig extends WebMvcConfigurerAdapter {

  @Bean
  public ViewResolver viewResolver() {

        InternalResourceViewResolver resolver = new InternalResourceViewResolver();

        resolver.setPrefix("/WEB-INF/views/");

        resolver.setSuffix(".jsp");

        resolver.setExposeContextBeansAsAttributes(true);

        return resolver;
  }
  
  @Override
  public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {

        configurer.enable();
  }
}
```

Viewresolver'da belirtilen View'ı (jsp'yi) model ile doldurup response olarak yolluyor.

# persistence

## spring data
en üst modülün ismi "Spring Data"'dır. Spring data bir interface'dir. Bunun birçok implementasyonu mevcut. Örnek: 'Spring Data JPA', "Spring Data MOngoDB".

'Spring Data' implementasyonları Spring tarafından geliştirilmez. Spring sadece JavaEE standartlarında olan persistence API'leri için daha önüne bir katman koyar, böylece tümüne aynı APı'lerden erişebilmemizi sağlar.

## JPQL Queries vs native queries
JPQL JPA'nın kendi query syntaxıdır. örnek: 'SELECT c FROM Country c'. Native query ise sql sunucusunda çalıştırılacak sql'in kendisidir. JPA API'leri ikisini de çalıştırmamıza izin verir.

## named query tanımlama:
native yada JPQL querie'lerini bir isim ile tutup çağırabiliriz. örnek:

```java
@Entity
@Table(name = "country", schema="my_db")
@NamedQueries({

    @NamedQuery(name="Country.findAll",

                query="SELECT c FROM Country c"),

    @NamedQuery(name="Country.findByName",

                query="SELECT c FROM Country c WHERE c.name = :name"),

}) 

public class Country {

    @Id
    @Column(name = "id")
    @GeneratedValue(strategy = GenerationType.SEQUENCE)
    private Long id;
}
```

Artık yazılımımızın herhangi bir yerinden şu kod ile named query kullanabiliriz:

```java
@PersistenceContext
public EntityManager em;

customers = em.createNamedQuery("findAllCustomersWithName")

        .setParameter("custName", "Smith")

        .getResultList()
```

# EntityManager/EntityManagerFactory vs Session/SessionFactory
Session hibernate spesific sınıftır. EntityManager ise JPA spesific'tir. EntityManager arkaplanda hibernate'in Session'ını zaten kullanmaktadır.

EntityManager'dan Session instance'ımızı elde edebiliriz:

```java
Session session = entityManager.unwrap(Session.class);
```

# entity manager types

Basically JPA specification defines two types of entity managers:
 
- Application-Managed (__LocalEntityManagerFactoryBean__ kullanılır)
  Application Managed entity manager means "Entity Managers are created and managed by merely the application ( i.e. our code )" .
 
- Container Managed (__LocalContainerEntityManagerFactoryBean__ kullanılır)
  Container Managed entinty manager means "Etity Managers are created and managed by merely the J2EE container ( i.e. our code doesn't directly manages instead entity managers are created and managed by container, and our code gets EM's through some way like using JNDI ).
 
# JPA Konfigürasyon
 
- ## Uygulama Tarafından Yönetilen EntityManager Konfigürasyonu
 
jpa-application-managed.xml:
 
```xml
<bean id="entityManagerFactory"
      class="org.springframework.orm.jpa.LocalEntityManagerFactoryBean">
 
         <property name="persistenceUnitName"
                   value="rentAcar-application-managed" />
</bean>
```

persistence.xml:
 
```xml
<persistence
    version="1.0"
    xmlns="http://java.sun.com/xml/ns/persistence"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/persistencehttp://java.sun.com/xml/ns/persistence/persistence_1_0.xsd">
    
        <persistence-unit name="rentAcar" />
        <persistence-unit name="rentAcar-application-managed">
            <class>com.kurumsaljava.spring.Car</class>
            <class>com.kurumsaljava.spring.Customer</class>
            <class>com.kurumsaljava.spring.Rental</class>
            <properties>
                <property name="hibernate.connection.url" value="jdbc:hsqldb:mem:spring-playground" />
                <property name="hibernate.connection.driver_class" value="org.hsqldb.jdbcDriver" />
                <property name="hibernate.dialect" value="org.hibernate.dialect.HSQLDialect" />
                <property name="hibernate.connection.username" value="sa" />
                <property name="hibernate.connection.password" value="" />
                <property name="hibernate.hbm2ddl.auto" value="create" />
                <property name="hibernate.show_sql" value="true" />
                <property name="hibernate.format_sql" value="true" />
                <property name="hibernate.hbm2ddl.show" value="true" />
            </properties>
        </persistence-unit>
</persistence>
```

örnek bir işlem:
 
```java
public static void main(String[] argv) {   
    ApplicationContext context = new ClassPathXmlApplicationContext("jpa-application-managed.xml");
    EntityManagerFactory factory = (EntityManagerFactory) context.getBean("entityManagerFactory");
    EntityManager manager = factory.createEntityManager();
    EntityTransaction transaction = manager.getTransaction();
    transaction.begin();
    List result = manager.createQuery("select c.name from Customer c").getResultList();
    System.out.println(result.size());   
    transaction.commit();  
    manager.close();  
    factory.close();
}
```
 
- ## Uygulama Sunucusu Tarafından Yönetilen EntityManager Konfigürasyonu
 
jpa-container-managed.xml:
 
```xml
<bean id="entityManagerFactory"    
      class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
         
          <property name="jpaVendorAdapter">
                   <bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"/>
          </property>
         
          <property name="jpaProperties">
                  <props>
                    <prop key="hibernate.show_sql">true</prop>
                    <prop key="hibernate.format_sql">true</prop>
                    <prop key="hibernate.hbm2ddl.auto">create</prop>
                    <prop key="hibernate.hbm2ddl.show">true</prop>
                  </props>
          </property>
         
          <property name="dataSource" ref="dataSource" />
</bean>
```

# Repository
türkçe kelime anlamı: depo, ambar

```java
public interface MyRepository extends CrudRepository<Person, Long> {

  Person save(Person p);

  Optional<Person> findById(Long primaryKey);

  Iterable<Person> findAll();

  long count(); 

  void delete(Person p);

  boolean existsById(Long primaryKey);
}
```

Yukarıdaki metodlar default implemente edilmiş durumdalar. çağrıldıklarında veritabanında işlem yapacaklardır. isteğe bağlı ekstra metodlar yazılabilir. o zaman interface değil clas sypaılmalıdır. fakat metod body2si yazılmayacak ise (yani hep quer ler ile çalışılacak ise) sadece interface yapılıp metod imlazarı yeterli olacaktır.

Super'den sub-interface'ye doğru:

- Repository -> hiçbir metod içermiyor.

- CrudRepository -> count, delete, existbyid, findall, save gibi metodlar içeriyor

- PagingAndSortingRepository --> pagination için metod içeriyor.

bunlardan türemiş birçok implementasyon mevcut.

# @NoRepositoryBean
ilgili sınıfın instance'ının repository olmadığını işaretler. örneğin baseRepository sınıflarımızda bu anotation'ı kullanabiliriz. örnek 2: PagingAndSortingRepository bu anotation'ı içeriyor.

# enabling jpa on project
```java
@EnableJpaRepositories(basePackages = "com.acme.repositories.jpa")

@EnableMongoRepositories(basePackages = "com.acme.repositories.mongo")

interface Configuration { }
```

# noSQL
NoSQL işlemlerde @Entity yerine @Document yazmak gerekli.

# relations
(önce güçlü zayıf tablo başlığı okunmalı)

customer-order tablosunda ilişkilere bakalım. customer güçlü, order güçsüz tablodur. çünkü order'da customer-id olmak zorundadır. yoksa o order bi anlam ifade etmez.

normalde nesneye dayalı dillerde, Customer objesi içerisinde List<Order> olmalıdır. fakat databasede buna gerek yok. yukarıdaki satırdan çıkan sonuç bu.

entity customer:

```java
@OneToMany(mappedBy="customer") //order class'ının private 'customer' property'sidir
private List<Order> order;
```

entity order:

```java
@ManyToOne
@JoinColumn(name="customer_id") //order tablosundaki 'customer_id' sutununun adı
private customer customer;
```

# JoinColumn vs mappedBy
mappedby ile jpa'ya ilişkinin sutnunun (foregin key'in) karşı objede olduğunu belirtiyoruz. mappedby belirtildiğinde ilgili tablomuzda foreign key olmamasına rağmen, java objesinde sanal olarak varmış gibi davranabilmemiz sağlanabiliyor. örneğin yukarıdaki örnekte; customer içinde herhangi bir foreign key olmamasına rağmen getOrder yapabileceğiz.

oysa JoinColumn ile order tablosunun customer_id diye databasede bir sutun içerdiğini belirtiyoruz.

# crosstable (yada jointable)
sadece tablo ilişkilerinin tutulduğu tabloya verilen isimdir. one-to-one yada many-to-one ilişkilerde pek tercih edilmiyor. çünkü yeni tablo yaratmak yerine, varolalan tablolara bir foreign key ekleniyor. fakat many-to-many ilişkilerde kullanılması şart. ismi genelde ilişkilendirilen iki tablonun birleşimidir. örnek: customer_order.

# @jointable
kullanımı:

```java
@Entity
public class A {

    private Long id;

    @ManyToOne
    @JoinTable(
       name = "A_B", 

       joinColumns = @JoinColumn(name = "B_ID"), 

       inverseJoinColumns = @JoinColumn(name = "A_ID")
    )
    private B b;
}
```

# FetchType
@ManyToOne(fetch = FetchType.LAZY) şeklinde kullanılır. Lazy sadece get methodu çağrılınca databaseden nesneyi çağırır, EAGER ise her zaman direk databaseden okunmuş halde objeyi getirir. one-to-one ve many-to-one ilişki default olarak EAGER iken, many-to-many ilişki default'ta LAZY'dir.

# CascadeType
@OneToMany(cascade=CascadeType.ALL) şeklinde kullanılır. örneğin order yaratıyoruz fakat customer_id foreign key'inin null olmaması gerekiyor. dolayısı ile önce customer yaratılmış olmalı. bu sebeple iki tabloya birden kayıt atarken önce customer daha sonra order'a yazmasını istiyoruz JPA'dan. örnek:

```java
Student student = new Student();

student.setName("Ahmet");

student.getHomeAddress().setStreet("Esentepe");

entityManager.persist(student);
```

Yukarısı CascadeType belirtmediysek hata verecektir. çünkü adres objesi student içinde tanımlı diil. bunu şu şekilde çözebiliriz:

```java
@OneToOne(cascade = CascadeType.PERSIST)

private Address homeAddress = new Address();
```

CascadeType'lar:

- PERSIST : Nesne persist edilirse alt nesne de persist edilir

- MERGE : Nesne merge edilirse alt nesne de merge edilir

- REMOVE : Nesne silinirse bağlı alt nesne de silinir

- REFRESH : Nesne yenilenirse bağlı alt nesne de yenilenir

- ALL : Tüm işlemler birlikte yapılır

multiple kullanım mevcuttur:

```java
@OneToOne(cascade = { CascadeType.PERSIST, CascadeType.MERGE })
```

# bi-directional (yada bidirectional) vs in-directional (indirectional)
onetomany yada manytomany yada onetoone tek yönlü yada çift yönlü olabilir. örneğin; onetoone ilişki yaptık fakat 2 objenin sadece 1 tanesine foreign key koyduk. java objesinden (entity içinde) de tanımlama yapmadık. dolyaısı ile runtime sırasında sadece birinden diğerine gidiş olabilecek. dolaylı yoldan erişim yapılır fakat bidirectional ve indirectional terimleri direk erişim olup olmadığı ile ilgili bir durumdur.

# transaction
bir metodun tepesine @Transactional anotation'u atılırsa o metodun içindeki işlemerde yapılan database işlemleri atomic olur. eğer hata çıkarsa otomatik olarak sql'ler geri alınır. aslında geri alınmasından ziyade yapılan database işlemleri database'de işlenmiyor. 

@Transaction opsiyonel olarak şu parametreleri alabilir:

```java
@Transactional(rollbackFor = MyException.class, 
               propagation = Propagation.REQUIRED,
               timeout = 35)
```

- rollbackFor

  sadece belirtilen excepiton(lar) için rollback yapılacağıdır. eğer exception alınırsa, exception alınan kısma kadarki sql'şer comit edilir.

- timeout

  eğer bu süre geçerse rollback edilir

- propagation

  türkçe kelime anlamı: yayılma
  
  @transactional bir metod içinde farklı bir @transactional bean'in metodu çağrılabilir. o zaman bu yeni metod'daki işlemlerin bağımsız mı yoksa, bir önceki transaction'a bağlı mı olacağına propagation özelliği ile karar veriliyor. propagation'ın alabileceği bazı değerler:

  - REQUIRED
    
    default değerdir. Aktif bir Transaction yoksa yeni bir transaction açar. Aktif varsa buna katılır.

  - REQUIRES_NEW

    Aktif bir transaction işlemi varsa bunu bekletir (Suspend) Yeni bir tane açarak kendi işini hallettikten sonra bu transaction işlemini kaldığı yerden devam ettirir.2 transaction bağlantısızdır.

  - NOT_SUPPORTED

    Transaction varsa suspend edilir servis metodu Transactionsız çalıştırılır.

  - NEVER

    Transaction varsa Exception fırlatır.

  - MANDATORY

    Transaction yoksa exception fırlatır

  - SUPPORTS

    önceden açılmış transaction varsa; onu kullanır. yoksa transaction'suz işlem yapar.

  - NESTED
    
    Aktif bir Transaction yoksa yeni bir transaction açar. Aktif varsa buna katılır. Bu kısım aynı REQUIRED gibidir. sadece ek olarak metod bağlangıcında bir "savepoint" yaratır. ve eğer hata alınırsa bu savepoint'e dönülür.

@Transactional decleratif çözüm. Programatik çözüm için:

PlatformTransactionManager sınıfından yararlanılır. Bu sınıf ile:

```java
DefaultTransactionDefinition def = new DefaultTransactionDefinition();
TransactionStatus status = txManager.getTransaction(def);
try {
  // execute your business logic SQL operations here
}
catch (MyException ex) {
  txManager.rollback(status);
  throw ex;
}
txManager.commit(status);

```

# application.properties dosyasındaki örnek datasource tanımı

bu tanım jpa sadece jdbc kullanılacakken, 

```yml
mydabatabase:

  datasource:

    url: jdbc:sqlserver://ip:1433;databaseName=mydb

    username: usr

    password: 123

    driver-class-name: com.microsoft.sqlserver.jdbc.SQLServerDriver

    testOnConnect: true -> her db connection'ı oluşturulduğunda öncesinde yapılan kontroldür

    testWhileIdle: true -> bir connection'dan kimse bir süredir işlem yapmadıysa, bağlantı üzerinden validationQuery çağırılır.

    logValidationErrors: true -> validationQuery yapıldığında alınacak olan hataların loglanıp loglanlanmayacağı

    validationQuery: "SELECT 1" -> yukarıdaki eventlerde (testOnConnect, testWhileIdle...) çağrılıcak sql sorgusu

```

# SpringApplicationBuilder
spring boot uygulamamız başlatılmadan önce ayarlar set etmemizi sağlar. kullanımı direk @SpringBootApplication atılan sınıfın içinde olmalıdır. örnek:

```java
@SpringBootApplication
public class WebApplication extends SpringBootServletInitializer {

    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {

        application = new SpringApplicationBuilder();

        application.parent(new Object[]{"classpath:file1.xml", "classpath:file2.xml"})

       .profiles("abc")

       .properties("key1:test1", "key2:test2") 

      .showBanner(false)

      .logStartupInfo(true)

       .headless(true)

      .application()

      .run();

        return application;
    }

    public static void main(String[] args) throws Exception {

        SpringApplication.run(WebApplication.class, args);
    }
}
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# dependency Injection types

## Constructor-based

```java
public class Service {

  private Collaborator collaborator;

  Service(Collaborator collaborator) {

    this.collaborator = collaborator;
  }
}
```

## Setter-based

```java
public class Service {

  private Collaborator collaborator;

  @Required
  public void setCollaborator(Collaborator c) {
    this.collaborator = c;
  }
}
```

## field-based

```java
public class Service {
  @AUtowired
  private Collaborator collaborator;
}
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# POJO (yada Plain Old Java Object)
Sadece getter setter'ları olan sınıflardır. Resmi bir tanım değildir. bu sebeple; bazı yerlerde serializable'dan da türeselerde POJO diye adlandırılırlar.

POJO kavramı genelde pattern'lerden ortaya çıkmıştır. temelde en basit java objesi kavramını temsil etmek için kullanılır. bu basit obje herhangi bir java frameworkü tarafından tanınacağı için portable'dır.

# Java Bean (yada Bean)
"Bean" java dünyası için ortak bir terimdir. tekrar kullanılabilir java objeleri yaratmak için belli kurallar belirlenmiştir. JavaEE tüm beanler için bu tanımı baz alır. fakat spring-beanleri bu kuralı baz almaz.

"bean" tekrar kullanılabilir java-objesi değildir; "bean" belli kurallara uyan sınıftır. yani inject ettiğimiz bean'ler tekrar kullanılabilirdirler, fakat configürasyon için kullanılan beanlerde olabilir, bunlar tekrar kullanılmazlar.

# JavaEE Bean kuralları
- public ve argüman istemeyen bir constructor olmalı
- her properti için getter setter olmalı
- java.io.Serializable'dan implemente etmeli

# Spring Bean kuralları
JavaEE'deki gibi belli kuralları yoktur. kullanılacak modül ne şekilde istiyorsa o şekilde tanımlanmalıdır.

# DI (yada Dependency Injection)
Tüm programlama dillerinde kullanılan bir pattern'dir. sınıf içinde kullanacağımız nesneleri "new" operatörü ile yaratmayız. Bunun yerine anotation kullanırız bizim çin inject işlemi yapılır.

# IoC (yada Inversion of Control)
Yazılımcılar arasında DI ile karşılaştırılır. İkisi çok benzer fakat inject işleminin hayat döngüsünün farklı aşamalarıdır.

kullandığımız framework bizim için istediğimiz implementasyonu inject etmemizi sağlar. Biz framework'e istek yaparız framework bizim için impelmentasyonları inject eder. Inject etme ksımı ise DI'dır. farklı implementasyonların framework tarafından bize temin edilmesi IoC kavramıdır.

IoC tüm programlama dillerinde kullanılan bir terimdir. Fakat özellikle spring DI işlemi için sürekli IoC kullanır ve DI container'larına IoC container adını vermiştir.

# cdi (yada Context and Dependency Injection)
@javax.inject.Inject anotation'unu kullanır.
javaee'nin DI spesifikasyonudur. birçok implementasyonu vardır.

# ejb (yada enterprise java bean)

- @javax.ejb.EJB anotation'unu kullanır. javax.ejb.Singleton anotation'u ejb için kullanılır. oysa javax.inject.Singleton anotation'u CDI bean'leri için kullanılır.

- CDI yapısı üzerine kurulu ve daha fazlasını sunan bir DI yöntemidir. 

- ejb'nin açılımı genel olsada sadece özel bir DI kütüphanesi ismidir.

- çeşitleri:

  - session bean

    - Stateful- aynı session için sürekli sabit kalır. her session için bir instance oluşturulur.

    - Stateless- durumsuzdur. istemciler istek yaptıkça yeni instance açılır, yada varolanlar paylaştırılır.

  - Singleton- sürekli tek bir bean açık kalır. bu bean'i herkes kullanır.

  - entity bean- veritabanı modellemesi için yaratılan bean'ler

  - message driven beans- JMS (Java Message Service) için kullanılan bean

  - managed bean- JSF'in hayat döngüsünde kullanılan bean'lere verilen isimdir. JSF xhtml'lerden çağrılan beanlere bu isimleri vermektedir.

  - baked bean- JSF, xhtml'lerde bean ismi vermeden bir Java sınıfını (java bean'ini) kullanmamıza olanak sağlamaktadır. sınıf ismi ve xhtml ismi aynı ise, o xhtml'de bean isi yazmaya gerek kalmaz. bu durumda olan java sınıflarına baked bean ismi verilir.

# Bean sınıfı tanımlama
Sınıfın bean olabilmesi için ya xml, yada anotation ile tepesinde tanımlama yapılması gerekmektedir. Örnek:

- Spring'de @Repository bir sınıfı DAO haline getiriyor ve bir bean olarak tanımlıyor.

- Spring'de @Component genel manada bi bean yaratmak için kullanılır. Spring'deki diğer bean anotation'ları bunun üzerine kuruludur. yani diğer tüm beanlerde @Component vardır.

- Spring'de @Service bir bean servis amaçlı kullanılıyorsa bu tanımı alır.

- Spring'de @Controller Spring MVC'de controller tarafındaki sınıflar için kullanılır. örneğin rest isteklerinde ilk çağrılan metodların bulunduğu sınıf Contoller'dır.

# ejb container
uygulamadaki tüm ejb'lerin tutulduğu yerdir. birileri bu ejb'leri çağırdığında, ejb container üzerinden paylaşılmaktadır. Spring projelerinde "ejb container" yerine "IoC container" vardır.

# DI Container
ejb container'ın programlama düyasında kullanılan genel ismidir. Bu container'lar, kendi içlerinde tüm uygulamada bulunan dependency listesinin haritasını tutar. böylece bir dependency kullanmak istediğimizide, kullanacağımız dependency'nin dependency'lerini de bulur ve ona inject eder.

# @Qualifier
javax.inject paketi içerisinde olan bu anotation ile inject edilen sınıfın ismi belirtilebilir. böylece aynı isimde olan bean var ise; doğru olanı inject etmiş oluruz. Bu anotation inject edilecek variable'ın üstünde resource, inject, autowired ile birlikte kullanılmalıdır. örnek:

```java
@Autowired
@Qualifier("iceCream")
void setDessert(Dessert dessert){
    this.dessert = dessert;
}
```

Yukarıdaki kod örneğinde; Desert olarak iceCream implementasyonu set edilecektir.

Eğer bu @Qualifier sınıfın tepesine yazılırsa:

```java
@Qualifier("iceCream")
class MyDesert {
    ...
}
```

artık "MyDesert" yerine "iceCream" kullanılır.

# osgi (yada Open Services Gateway initiative)
osgi java için bir standarttır. belli kalıplarda yazılan java uygulamaları osgi standartlarına uyuyorsa, mödüler bir şekilde çalışabilirler. osgi için jar paketlerinin içine bazı ek dosyalar eklemek gerekir.

osgi'nin implementasyonları vardır. Equinox, Apache Felix gibi. osgi standartlarındaki jar'ları kullanabilmek için osgi implementasyonunun (kütüphanesinin) runtime'a çalışması gerekir.

RUntime sırasında hiç restart etmeden bir OGSI-uyumlu jar'ı çağırabiliriz. çünkü bu jar içerisinde start stop gibi implemente edilmiş metodlar vardır. aynı zamanda bu çağırdığımız jar'ın bağlı olduğu diğer dependency'ler kendi manifest dosyasında vardır. aynı zamanda kendi hakkında detalları da manifest içerisinde bulabiliriz (sürüm no gibi).

OSGI da her OSGI uyumlu jar birer 'bundle'dır. örneğin eclipse IDE kendi altyapısında Equinox kullanır. IDE'de her eklenti birer 'bunlde'dir. fakat eclipse son kullanıcıya uygun olsun diye bunlara "eklenti" demek zorundadır.

# osgi vs cdi
osgi kadar esneklik sağlamaz. Aslında bu iki teknolojiyi karşılaştırmak yanlış. İkisi apayrı mantıkta ve amaçta çalışmaktadır. OSGI modüler uygulama geliştirmke için yaratılmıştır. CDI ise sınıfların inject edilebilmesini sağlamaktadır.

- osgi java runtime sırasında yeni bir paketin java proramına entegre edilebilmesini sağlar. restarta ihtiyac duymaz. oysa CDI'de, sonradan inject edilecek bir sınıfın path'te runtime sırasında her zaman tanımlı olması gerekir.

- osgi'da bağımlılıklar (paket id + class name olarak verilir). oysa CDI'de path yukarı doğru ilk bulduğu sınıfı kullanır. bu da komplekslik yaratır.

- osgi'de bağımlılıklar versiyon bazında seçilebilir ve birden fazla versiyon aynı anda çalıştırılabilir. oysa CDI-de bunların hiçbiri yok, çünkü versiyon mantığı yok.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# app server vs web server
Web suncusuna bir istek geldiğinde, sunucu bu isteği basitçe en iyi karşılayabilecek programa aktarır. kısacası; yapılan çağrıları ilgili yerlere aktarmaktır ve dönen cevabı döndürmektir. load balancing, caching, gibi bir çok ek işlevi de yapabilir..

örnek sunucular: Apache HTTP Server, nginx

uygulama sunucusu ise; iş mantığını yürüten (işleten - üzerinde uygulamlacıklar çalıştıran) ve API sunan bir motordur.

örnek sunucular: GlassFish, weblogic, jboss (yada WildFly), IBM WebSphere

Java dünyasının standartlarına göre; "EJB Container" içermeyen hiçbir yazılım uygulama sunucusu olamaz. Bu tanıma göre; tomcat bir web sunucusudur.

benzer şekilde sadece web sunucusu olanlar: Jetty

# uygulama neden sunucuya ihtiyaç duyuyor?

her java app server birer JavaEE implementasyonudur. JavaEE kütüphaneleri maven'a eklenirken interfaceler ve abstractlar bazen de sınıflar tanımlanır. fakat uygulama ayağa kalkması için runtimede bunların implementasyonlarına ihtiyaç duyar. her uygulama sunucusu JavaEE'yi kendisi farklı implemente etmiş olabilir.

Bir "web" uygulamasını ayağa kaldırabilmek için en az "Servlet Container"'a ihtiyaç vardır. İşte bu kütüphane tüm app serverlarda + tomcat'te dahi mevcuttur. Spring-framework uygulaması dahi bunu yapmaya zorunludur. Fakat spring bu kütüphaneyi direk olarak kendi içinde bulundurmaktadır. Daha sonra hayata geçirilen Spring-boot projesi bu kütüphanelerin uygulama içerisine gömülmesini daha çok kolaylaştırmaktadır. Spring projesini bir app server'da çalıştırdığımızda, spring uygulaması app server'ın "servlet container"'ını kullanabilir.

Servlet container bu sebeple "web container" olarak ta adlandırılmaktadır.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# deployment descriptors

| file                   | platform        | directory           |
|------------------------|-----------------|---------------------|
| application.xml        | Java EE         | META-INF            |
| application-client.xml | Java EE         | META-INF            |
| beans.xml              | CDI             | META-INF or WEB-INF |
| ra.xml                 | JCA             | META-INF            |
| ejb-jar.xml            | EJB             | META-INF or WEB-INF |
| faces-config.xml       | JSF             | WEB -INF            |
| persistence.xml        | JPA             | META-INF            |
| validation.xml         | Bean Validation | META-INF or WEB-INF |
| web.xml                | Servlet         | WEB-INF             |
| web-fragment.xml       | Servlet         | WEB-INF             |
| webservices.xml        | SOAP            | META-INF or WEB-INF |

# "Java EE deployment descriptors" vs "runtime deployment descriptors"
JavaEE implementasyonları (app server'lar) kendi içlerinde ek olarak xml istiyor olabilir. bunlar "runtime deployment descriptors"tır. örnek: sun-application.xml, sun-web.xml.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# anotation
türkçe kelime anlamı: dipnot
anotationlar birer @interface anotation'undan türemiş objelerdir. örnek:

tanım:

```java
@Target(ElementType.METHOD) //anotation nerelerin önüne koyulabilir

@Retention(RetentionPolicy.RUNTIME) //anotation hangi adımlarda kullanılacak (runtime, source, class olabilir)

@interface Todo { //anotation ismi

 public enum Priority {LOW, MEDIUM, HIGH} //anotation'un parantez içinde verilen bir parametresi

 public enum Status {STARTED, NOT_STARTED} //anotation'un parantez içinde verilen bir parametresi

 String author() default "Yash"; //anotation'un parantez içinde verilen bir parametresi

 Priority priority() default Priority.LOW; //anotation'un parantez içinde verilen bir parametresi

 Status status() default Status.NOT_STARTED; //anotation'un parantez içinde verilen bir parametresi

}
```

kullanım:

```java
@Todo(priority = Todo.Priority.MEDIUM, author = "Yashwant", status = Todo.Status.STARTED)
public void myMethod() {

          //Some code here...
}
```

# Anotation kendi içinde nasıl businnes logic uyguluyor?
- RetentionPolicy.RUNTIME
  Runtime sırasında iş yapan anotationlar (): Runtime sırasında anotation'u sunan framework reflection kullanarak hangi sınıflarda anotation varsa a onları buluyor. her anotation'un içinde tuttuğu bir data var. bu data'lar anotation çağrılınca yazılımcı tarafından veriliyor. bunları kullanarak runtime sırasında framework businnes logic uyguluyor.

  Diğer fazlarda (compile gibi) çalışan anotation'lar farklı şekilde işliyor.

- RetentionPolicy.SOURCE
  @Override, @SuppressWarnings gibi sadece IDE'lerin görmesi beklenen, derleme sırasında önemsenmeyen ve derlenmeyen anotation'lardır.

- RetentionPolicy.CLASS
  derleme sırasında kullanılırlar fakat derlenip class olarak kullanılmazlar. örneğin; compile sırasında dökümantasyon oluşturmak için kullanılabilirler. 

  CLASS anotation'ları derleme sırasında java derleyicisi tarafından çağrılırlar. İşte burada "java source code generator" yazılımı ortaya çıkıyor. java derleme yaparken farklı source code generator'lar kullanmamıza izin veriyor. eğer farklı bir generator (processor) kullanmak istiyorsak java compiler'ına bunu belirtmek gerekiyor.

  örnek:

  - komut satırından: javac -processor com.MyProcessor Person.java

  - maven'dan:

```xml
    <build>
      <plugins>
          <plugin>
              <groupId>org.apache.maven.plugins</groupId>
              <artifactId>maven-compiler-plugin</artifactId>
              <configuration>
                  <annotationProcessors>
                      <annotationProcessor>
                          com.MyProcessor
                      </annotationProcessor>
                  </annotationProcessors>
              </configuration>
          </plugin>
      </plugins>
    </build>
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Class objesi
Class bir sınıftır. Bu sınıf her sınıfın içinden myClassIntance.getClass() yada (static) MyClass.class ile çağrılabilmektedir. bu iki değerin referansı birbirine eşittir. 

Class sınıfı, MyClass'ın özelliklerini yansıtan metodlar içermektedir. Bu şekilde MyClass hakkında bilgiler alabilmekteyiz. örneğin; myClass'ın ismi, paket ismi gibi…

# Class objesinde olan bazı metodlar/propertie'ler:

- static forName(String className) : metoddur. Bu metoda herhangi bir sınıfın ismi string olarak gönderilebilir. bize gönderdiğimiz sınıf için Class objesini döndürecektir. Örnek: Class myCarClass = Class.forName("Car");

- getAnnotation(Class < A > annotationClass): parametre aldığı anotation sınıfından ilgili sınıfta var ise o anotation'u döner. java.lang.annotation.Annotation döner. bu sınıfı tüm anotation'lar extend eder.

- Annotation[] getAnnotations(): o sınıfta kullanılantüm anotation'ları dönder.

- ClassLoader getClassLoader(): ilgili sınıfın clasloader'ını dönüyor.

- diğer metodlar: enum olup olmadığı, field'lar, anonym olup olmadığı...

# reflections (yada yansımalar)
java.lang.reflections paketleri altında olan bu sınıflar, metodlar ve sıfınılar hakkında meta bilgileri alabilmemiz ve hatta gerektiğinde ismi ile aşağıdaki örnekte görüldüğü gibi metodları execute edebilmemizi sağlayabilmektedir.

```java
Method m = valueObject.getClass().getMethod(methodName, new Class[] {});

Object ret = m.invoke(valueObject, new Object[] {}); //m isimli metoda parametre yolluyoruz
```

# java arrays
Obje sınıfından türemiştir. fakat runtime'de dinamik oluşturulurlar. örnek:

```java
int[] x = new int[3];

System.out.println(x.getClass().getName()); //ekrana [I basar. int[][] ise [[I basar.  [[I sınıfı dinamik oluşturulur.
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# jrebel
JVM için yzılmış bir bir Classloader extension'udur. Varolan classloader'a ek olarak kendi logic'lerini çalıştırır. Birçok IDE için yazılmış eklentisi de vardır.

jrebel ile deploy edilen uygulama (app server içerisinde çalışsa dahi) hot-deploy yapılabiliyor. sadece değişen java sınıfları deploy ediliyor ve uygulama restart istemiyor. normalde javada hotdeploy özelliği var fakat metod imzası değişmesi gibi durumları desteklemiyor. bu eklenti ile daha fazla durumda hotdeploy yapılabilmesi sağlanıyor.

ASM ve Javassist framework'leri, bytecode'u runtime sırasında manipüle edebilmek için kullanılan projelerdir. jrebel'da bunlara alternatif bir yazılım geliştiriyor.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# war (web application archives) vs ear (enterprise archives) vs jar (java archive)

- jar sadece java sınıfları ve resource'leri barındırır.

- war, jar'a ekstradan, servlet ve jsp dosyalarını barındırır.

- ear ise servlet (war) + "ejb modülü" olarak ayarlanmış jar dosyaları bulundurması gerektiğinde kullanılır.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# JVM memory spaces

- Heap Space
  - Young Generation
    - Eden Space : 'new' keywordü ile oluşturulan her nesne bu alanda tutulur
    - Survivor Space : garbage collector (yada GC), "eden space" alanını gezip ölü nesneleri yokeder. yaşayanları bu alana taşır.
  - Old Generation
    - Tenured Space: garbage collector, "Survivor space" alanını gezip ölü nesneleri yokeder. yaşayanları bu alana taşır.
- Non-Heap
  - Permanent Generation (PermGen) : JVM'in uygulamanın içindeki sınıfların meta bilgilerini (metod imzaları gibi) tutmak için kullandığı alandır.
  Java8 Update: PermGen is replaced with Metaspace which re-sizes dynamically at runtime.
  - Code Cache (Virtual or reserved) : hotspot kod kısımlarının, native kod'a çevrildiğinde saklandığı cache bölgesi

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# apache commons
birçok java kütüphanesi barındıran projenin ismidir. altındaki kütüphaneler birçok  amaç için yazılmıştır. sadece ihtiyaç duyulan kütüphanenin jar dosyası ayrı ayrı indirilmektedir. alt modüllerin bazıları:

- commons-codec: General encoding/decoding algorithms (example: phonetic, base64, URL).

- commons-lang: extra feature for java.lang (core java library)

- commons-cli: command line argument passer

- commons-collection: datastructures library

- commons-dbcp: jdbc üzerinde pool'ların yönetimini yapmamızı sağlayan kütüphane. ORM kütüphanesi değildir.

# Google Guava
apache commons gibi birçok  iş için geliştirilen java kütüphaneleri grubudur.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# JNDI (yada Java Naming and Directory Interface)
Java API'sidir. 

propertie dosyalarından okurmuş gibi obje yaratabilmemizi sağlamaktadır:

```java
Context context = new InitialContext(); 

MyDataSource ds = (MyDataSource) context.lookup("service-name");
```

Yukarıdaki kodun çalışabilmesi için bu kod satırı çalışmadan önce uygun servis'in init edilmiş olması gerekmektedir:

```java
MyDataSource ds = new MyDataSource();

ds.setPassword("abc");

Context context = new InitialContext(); 

context.bind("service-name", ds);
```

JNDI en çok database bağşantıları ve LDAP gibi sistemler için kullanılıyor. Örneğin; tomcat, jboss bize JNDI ile database'e bağlanabilmemiz için kendi data-source nesnesini döndürüyor. bu nesneyi kendi tabımlıyor, biz tüm deploy ettiğimiz java uygulamalarından bu JNDI'ları okuyabiliyoruz. Okduğumuzu bu JDNI objelerinden örneğin; daatbase connection'ı açabiliyoruz.

MyDataSource objemiz istediğimiz custom metodları barındırabilir. örneğin; dbDataSOurce.getConnection(); gibi...

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# log
log kelimesi türkçede "kayıtların bütünü" anlamına geliyor. (çok farklı anlamları da var.)

# graylog
java ile yazılmış bir sunucudur. buraya herkes http gibi  protokollerle log atıyor uzaktan. kolay bir arayüz sunuyor logların okunması için. tüm sunucular buraya log atıyor. tek bir yerde depolanıyor ve yönetiliyor.

# log4j
java için log kütüphanesi.

default olarak; log4j.properties yada log4j.xml dosyasından konfigürasyonları okur.

log4j 2'inci sürümü log4j2.properties yada xml dosyasını okur.

# logback
log4j'nin 1'inci sürümündeki bazı köklü sorunlarını gidermek için başlatılan proje. log4j 2'inci sürümünde bunları giderdi, fakat logback projesi hala devam etmektedir.

# log4j12
log4j'nin 1.2'inci sürümünün paket adıdır. artık geliştirilmemektedir.

# commons-logging (yada eski adı: Jakarta Commons Logging yada eski adı: JCL)
java için log kütüphanesi. apache-commons projesinin bir parçasıdır.

commons-logging, SLF4J gibi tek başına kullanılamaz. başka bir logger altyapısına yönlenmesi gerekir. slf4j ile benzer yapıdadır, fakat SLF4J'den önemli bir farklılığı vardır: jcl claspath'te olan bir kütüphaneyi bulur ve logları ona yönlendirir. yani kulanılacak logger kütüphanesi jcl implementasyonu olmak zorunda diildir. örneğin bir projede log4j ve jcl kütüphanesi olması yeterlidir. jcl otomatik lo4j'ye yönlenecektir.

# SLF4J (yada Simple Logging Facade for Java)
Birçok java log kütüphenesi için facada (ön adaptör) sunan bir kütüphanedir. bu şekilde kullanıcı istediği log kütüphanesine geçişi çok kolay bir şekilde yapabilmektedir. SLF4J tek başına kullanılmaz. diğer kütüphanelerin ortak bir API üzerinden kullanılmasını (çağrılmalarını) sağlar.

slf4j ilk başladığında bir implementasyon arar. eğer yok ise; default olarak kendi içinde gelen no-operation (yada NOP yada NOPLogger) implementasyonunu kullanır. eğer birden fazla implementasyon kütüphanesi classpath'e eklenmiş ise; o zaman slf4j bunlardan sadece 1 tanesini kullanır ve bize sadece bir uyarı verir. kullandığımız kütüphanelerde (örneğin; sql-server-client) slf4j implementasyonu "optional" dependency olarak gelir. böylece herkes eklediği her kütüphanede birden fazla slf4j implementasyonu sorununu yaşamamış olur.

slf4j başlarken org.slf4j.impl.StaticLoggerBinder sınıfını arar. bu sınıf her slf4j implementasyonunda mevcuttur.

- slf4j-simple: çok basit bir slf4j implementasyonudur.

- slf4j-jdk14: bir slf4j implementasyonudur. Java.util.logging kullanmamızı sağlar.

- slf4j-api: slf4j core kütüphanesinin paket adıdır.

- slf4j binding: bu terim slf4j implementasyonunu kullanılması anlamında kullanılır 

# slf4net
slf, facade olduğundan birçok dilde aynı API'yi destekliyor. bu pakette .net frameworkü için geliştirilmiş slf'dir.

# example of slf4j with log4j binding
asagidaki dependency'ler şarttır:

- slf4j-api
- log4j-slf4j-impl
- log4j-api //log4j impl bunu şart koşuyor.
- log4j-core //log4j için gerekli bir bağımlılık

# bridge vs migrator
bridge paketleri jul-to-slf4j gibi arada "to" olacak şekilde isimlendirilir. migrator paketlerinde ise arada "over" keywordü yer alır. örnekler:

> jcl-over-slf4j

> log4j-over-slf4j

> jul-to-slf4j

- migrator paketleri classpath'te varolan diğer log kütüphanesinin kodlarını(API'lerini) ezer ve logları slf4j'ye aktarır. örnek: jcl-over-slf4j: classpath'te jcl olan kütüphanenin kodlarını ezer ve slf4j'ye aktarır.

- bridge paketlerinin de amacı aynıdır. fakat farklı şekilde çalışır. örnek üzerinden gidersek: jul-to-slf4j paketi, classpath'teki JUL apilerine Handler ekler ve logları slf4j'ye aktarır. Bu handler'lara SLF4JBridgeHandler ismi verilir.

JUL migrator paketi olamaz. çünkü; jul java.# paketleri altındadır. bu paketler ezilemeyeceğinden jul için migrator paketi yaratılamıyor.

# java.util.logging (yada JUL)
jre içinde geliyor. logging.properties dosyasını okur.

val l = java.util.logging.Logger.getLogger("MyClass"); //aldıgı parametre o andaki sınıfın ismidir. böylece logu attığımızda hangi sınıın o logu attığını okuyabiliriz. 

# isteğe bağlı handlerlar
handler atanmazsa her zaman default handler olur.

```java
val h = new ConsoleHandler

h.setLevel(Level.ALL) // we output ALL the logs to the console

val f = new FileHandler("warn.log", true)

f.setLevel(Level.WARNING) // we also send all WARNINGs and more criticals to a file

f.setFormatter(new SimpleFormatter)

l.addHandler(h)

l.addHandler(f)
```

# log4j FileAppender vs RollingFileAppender vs DailyRollingFileAppender

RollingFileAppender FileAppender'dan extend eder ve dosya boyutu maximuma geldiğinde yeni bir dosya oluşturur eskisini backuplar.

DailyRollingFileAppender RollingFileAppender'ı extend eder ve dosya boyutu maximuma gelince değil, istenilen gün sayısı sonrasında yeni dosyayay geçiş yapar.

# log levels
slf4j ve log4j ve log4j2 için:

- Trace: sadece developerın anlayacağı loglardır. fonksiyonların içlerinde kodun nerede oldugunu belli etmek için kullanılır.

- Debug: it'cilerin de anlayacağı loglama olmalı. it'ciler bir sorunu incelerken buraya başvurabilmeli.

- Info: servis başladı. kapandı gibi bilgileri vermek için kullanılır.

- Warn: uygulama için bazen önemli olabilecek akışları bildirmeli. örneğin; soket timeout verdi. tekrar deneniyor. buralar bir hata değildir. sayısı çok arttıkça uygulama incelemeye alınmalı, yada uygulamada bir terslik oldugunda ilk bakılacak kısımlar burada olmalı.

- Error: hataların yazıldığı seviye

- Fatal: sistemin durması gerektiğinde veya zarar gördüğü durumlarda

- All: bu bir seviye değildir. log basarken tüm logların basılacağını belirtir.

Yukarıdaki level'lar kütüphaneden kütüphaneye değişebiliyor. bazılarında bazı levellar olmuyor, bazılarında yukarıdakilerden daha fazla çeşit level sunuluyor. bazı diğer leveller:

- level -> yukarıdaki seviyelerden denk olanı

- SEVERE (türkçe kelime anlamı: şiddetli) -> Error

- WARNING -> Warn

- CONFIG -> Info

- FINE -> Debug

- FINER -> Debug

- FINEST -> Debug/Trace

- VERBOSE (türkçe kelime anlamı: gereksiz sözler) -> Trace

# audit trail (yada audit log)
audit kelime anlamı: denetim

trail kelime anlamı: iz

audit log'lar domain event'leri gibi, domain'de olan her olayın log'larıdır. örnek: a transaction is created, a user is performing an action... kaynak: http://www.cnss.gov/Assets/pdf/cnssi_4009.pdf (archive date: 01/01/2020) ve http://www.atis.org/glossary/definition.aspx?id=5572 (archive date: 01/01/2020)

# best practices:
- SLF4 kullanırken;

log.debug("Found " + records + " records matching filter: '" + filter + "'");

yerine bunu kullanmak daha iyi:

log.debug("Found {} records matching filter: '{}'", records, filter);

log4j'de SL4j gibi bir metod yok. bu sebeple ilk satırdaki yöntem kullanılmak zorundadır.

- if(logger.isDebugEnabled) gibi kodlar kullanılmamalı

- hatalar sadece bu şekilde loglanmalıdır:

log.error("Error reading configuration file", e);

- log.debug("the name is");

  log.debug(name);

gibi iki satıra kesinlikle yayılmamalı. pararlelden gelen loglar bu ikisi arasına girebilir ve loglar anlamını kaybeder.

- her sınıfın tostring'i olmalı ki loglar düzgünce basılabilsin. fakat gizli bilgiler loga basılmayacağı için onlara ekstra dikkat edilmeli. gerekirse tostring'den gizli bilgiler çıkrılmalı veya hashlenerek tutulmalı (yada hashlenerek print edilmeli).

- log.info("Processing ", request.size());  request'in null gelme durumunda bu kod satırı patlayacaktır. request null kontrolü yapılması istenmiyor ise; request'in tostringi olmalı ve size() metodu kulanılmamalıdır. zaten logger tostring'i çağırdığında, logları okuyan kişi dizinini boyutunu da çıkarabilicektir. eğer bu şekilde istenmiyor ise; null kontrolü yapılmalıdır.

# spring'de logging
spring'de java sınıflarının bulunduğu paket isimleri ile log level'ı belirleyebiliriz. örnek:

```yml
logging:

  level:

    ROOT: ERROR  # tüm sistem için genel seviyeyi temsil ediyor

    org.springframework: ERROR 

    org.springframework.security: DEBUG 

    org.springframework.security.web.FilterChainProxy: ERROR 

    com.myapppackages: INFO # kendi sınfılarımız 

    org.mongodb: ERROR   # üçünçü parti dependency olsa bile bunu yapabiliriz

  file: /Users/myapp/application.log 
```

Spring kendi içinde commons-logging kullanıyor. SLF4J kullanılmamasının sebebi eskiden kalma olduğundan değiştirilememesidir. commons-logging yerine sl4j kullanıcaksak, jcl-yi exclude edip sl4j'yi eklememiz (ve slf4j implementasyonu eklememiz) yeterli olcaktır. fakat log4j kullanacaksak; log4j eklemek yeterli olcaktır. jcl zaten otomatik log4j'yi görmektedir. 

# logstash
sunucu olarak çalışan bu uygulama, ona gelen log'ları veritabanına kaydediyor. gelen logları kaydetmeden onları üzerinde manipülasyon yapılmasına da izin veriyor. çoğunlukla veritabanı olarak elastic search kullanılıyor.

# ELK (yada Elastic Stack)

Elastic + logstash + kibana üçlüsü çoğu zaman birlikte kullanılıyor. bu sebeple bu 3'lü pakete verilen kısaltma. 

Logstash'e her uygulama log'u yollar, Logstash tüm veriyi elastic'e aktarır. Kibana ise elastic'ten okduğu data'ları son kullanıcıya web arayüzünden gösterir.

Bu mimaride Logstash çok yorulur. Çünkü herkes sadece Logstash'e data (log) yollar. Burada yükü dağıtmak için "__Beats__" isimli uygulama sıkça kullanılır. Tüm projemizdeki her uygulama için ayrı ayrı beats ayağa kaldırabilir yada n-adet uygulama için sadece 1 adet beast kaldırabiliriz. Beats sadece aracılık yapar. Logstash'e dataları yollarken, backpressure yeteneği de olduğundan yoğunluk sırasında sistemin dengesini korur. Beats aynı zamanda isterse direk olarak elastic'e de aldığı dataları atabilir. Hatta bazı ek modüller sayesinde basit filtreleme işlemleri de yapabilir. (tüm paragraftaki bilgiler için kaynak: https://dzone.com/articles/filebeat-vs-logstash-the-evolution-of-a-log-shippe (archive date: 31/12/2019) )

beats'ler tipine göre farklı executable dosyaları indirme gerektiriyor. örnek: __filebeat__; dosyadan okuma yaparken, __winlogbeat__ ms-windows log sisteminden log'ları takip eder ve ms-windows log'larındaki her değişikliği kendisinin input'u olarak kabul eder.

filebeat için örnek config file:

```yml
filebeat.prospectors:
- input_type: log
  paths:
    - /var/log/httpd/access.log # filebeat'in sürekli okuyacağı dosya

document_type: apache-access # okunacak dosyanın dosya formatı

fields_under_root: true

output.logstash:
  hosts: ["127.0.0.1:5044"] # filebeat hangi ip'deki logstash'e data'ları (log'ları) göndereceği
```

Logstash'in sırası ile 3 farklı fazı vardır:
- input: input'tan dataların okunması
- filter: dataların manipüle edilmesi
- output: dataların farklı bir yere yollanması

logstash için örnek config file:

```groovy
input { // hangi faz için tanımlama yapacağımızı tepede belirtiyoruz
  beats { // beats'ten okuyacağımızı belirtmemiz gerekli.
    port => 5044 // input'un nerden okunacağı
  }
}

// yukarıda "beats" ('ten okumak yerine) yerine şunları kullanabilirdik:

// - file (logstash ile aynı makinede bulunan bir dosyadan okumamızı sağlardı)
// - redis (redisten okumamızı sağlardı)

// input örnekleri için kaynak: https://www.elastic.co/guide/en/logstash/current/pipeline.html (archive date: 31/12/2019)

filter { // hangi faz için tanımlama yapacağımızı tepede belirtiyoruz

  grok { // logstash ile gömülü gelen bir filter plugin'i
    match => { "message" => "%{IPORHOST:clientip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:time}\] "(?:%{WORD:verb} %{NOTSPACE:request}(?: HTTP/%{NUMBER:httpversion})?|%{DATA:rawrequest})" %{NUMBER:response} (?:%{NUMBER:bytes}|-)" }
  }

  date { // logstash ile gömülü gelen bir filter plugin'i
    match => [ "timestamp" , "dd/MMM/yyyy:HH:mm:ss Z" ]
  }
}

// yukarıda grok eklentisi sayesinde, logstash'e gelen anlamsız log satırı anlamlı hale dönüştürülüyor. log formatımızı grok'a parametre olarak veriyoruz. date eklentisine geldiğimizde ise artık tarih değerimizi log satırından parse etmemize gerek yok. tarihi "timestamp" olarak yeni bir json field'ı olarak kaydediyoruz. artık elastic search'e baktığımızda "timestamp" field'ı istediğimiz formatta görünecektir. ek not: "@timestamp" field'ı logstash tarafından otomatik atılmaktadır. "@timestamp" logsstah'e ne zaman log gelirse o anın tarihi olarak set edilmektedir. 

output { // hangi faz için tanımlama yapacağımızı tepede belirtiyoruz
  elasticsearch { // dataları hangi sunucuya yollacağımıızı bilertmemiz lazım.
     hosts => ["localhost:9200"] // elastic'in ip'si ve portu
  }
}

// yukarıda "elasticsearch" ('e dataları atmak yerine) aşağıdakileri kullanabilirdik:

// - file (logstash ile aynı makinede bulunan bir dosyaya yazmamızı sağlar)
// - graphite (graphite isimli programa dataları yollayabilmemizi sağlar)
// - statsd (aynı makiende bulunan statsd isimli servise data yollayabilmemizi sağlar)

// output örnekleri için kaynak: https://www.elastic.co/guide/en/logstash/current/pipeline.html (archive date: 31/12/2019)
```

logstash filter'ları için farklı bir örnek: https://itnext.io/common-logstash-use-cases-with-grok-json-and-mutate-filters-elk-logstash-in-docker-filebeat-871ed58c7651 (archive date: 01/01/2020)

# syslog
Birçok implementasyonu olan fakat rfc3164 ve daha sonrasında rfc5424 ile standartlaştırılmış log formatı ve protokolüdür. syslog standartlaştığından ötürü özel isimdir.

https://tools.ietf.org/html/rfc3164 (archive date: 31/12/2019)

https://tools.ietf.org/html/rfc5424 (archive date: 31/12/2019)

syslog servisleri, 514 portundan dinleme yapar. platformdaki tüm uygulamalar buraya loglarını yollar. Logstash'te input plugini olarak syslog yazılırsa, Logstash 514 portundan dinleme yapmaya başlar. aynı bir syslog deamon'u gibi log'ları dinler ve bunları elastic'e yollar.

# kibana
logstash'in elastic'e kaydettiği logları son kullanıcıya göstermek için web arayüzü sunan bir yazılım.

kibana web-ui'ındaki sekmeler:

- discover: arama yapılmasını sağlıyor.
  discover sekmesindeki alt widget'lar:
  - bir widget'ta "Selected Fields" ve "Available Fields". bunlar arama sonucları ekranında gösterilebilecek sutunları belirtmektedir. örnek: "Available Fields"'de loglarda akan tüm alanlar mevcuttur. örnek: appName, ip, timestamp, message. "Selected Fields"'a "Available Fields"'lardan seçim yaparak alan ekleriz. böylece sadece "Selected Fields"'daki alanlarımız sonuc ekranında görünmüş olur. eğer "Selected Fields" ı boş bırakırsak sonuc ekranında "\_source" sutunu olur ve bu sutunda tüm log bilgileri(alanları) bir json şeklinde gösterilir.
  - bir widget'ta standart olan "Apache Lucene Query Syntax" ile arama yapabilmemizi sağlayan textbox mevcuttur. Lucene arama örneği: "status:200 AND appName:user-service".
  - bir widget'ta filter'lar mevcut. bunlar Lucene stili aramasına ek filtreler eklememizi sağlıyor. Lucene ile de yapılabilecek bir şey fakat filtreler kolay enable disable edilebiliyor. oysa lucene'de bir filtreyi yorum satırı yapmazsınız. silip tekrar yazmamız gerekir.
  
  Ekranda yaptığımız her ayar URL'ye yansır. URL'yi başka tarayıcıya yapıştırdığımızda bu arama aynen açılır. 

- dev tools: json query'leri ile arama yapılmasını sağlıyor. örnek:

```
  GET _search
  {
    "query": {
      "match_all": {}
    }
  }
```

- visualize: grafikler hazırlamamızı sağlıyor. burdan grafik oluşturuyoruz. fakat bu grafikleri direk web-ui'ı açan user'a gösteremiyoruz. bu grafikleri dashboard'a bağlamak zorundayız.

- dashboard: bir filtre yazıyoruz ve visualize'da hazırladığımız her görsel'i buradaki filtreleye bağlıyoruz. örneğin filtremiz 'status:200' olsun. altında da buna bağlı 3 tane grafik bağlamış oluruz. bu dashboard'a "başarılı istekler" adını verelim. birçok dashboardumuz olabilir. artık dashboard sekmesine girip, listeden "başarılı istekler"'i seçen user, karşısında 3 tane grafik görecektir.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# modes of jvm
client ve server mod var. client daha çok jit kullanmayı sever. oysa server mode daha uzun vadede istatistik toplayıp, ilgili kod bloklarını daha yavaş şekilde jit kullanmaya başlar. yeni olarak "tiered compilation" modu gelmiştir. bu mod hem client hemde server karışımıdır. bu mod; uygulamanın başlangıcında client mod temelli çalışır, daha sonraki zamanlarda server mod temelli çalışır.

"java -version" komutu ile jvm'in çalıştığı mode çıkıyor.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Garbage Collector
Yaptığı işlemlere teknik özel isimler verilmiştir. JVM parametresi geçmek gerektiğinde, yada GC'nin algortimaları araştırıldığında bu terimlere ihtiyaç duyulabilir.

# mark
scan and marking all reachable (kullanılan) objects

# sweep
scan and free unmarked objects

# copy collection
coping collection to another memory block (example: from eden to survivor space)

# paralel collection
GC uses multiple threads for itself

# concurrent collection
GC uses concurrent threads for itself

# compacting
moves objects inside memory for defrag

# stop the world
GC pause all app threads to finish its job

# minor collection
garbage collection for young generation

# major collection
garbage collector for old generation

# Types of GC
GC kullandığı algoritmalara göre ayrılmaktadırlar:

- Serial collector
  - tek cpu'lu cihazlara uygun
  - GC işe başladığında tüm sistemi durdurur
- Parallel (throughput) collector
  - multiple cpu'lar için uygun
  - GC paralel thread'ler açarak işlem yapıyor
  - GC işe başladığında tüm sistemi durdurur
- concurrent (yada CMS yada concurrent-mark-sweep) collector
  - old generation için arkaplanda sürekli GC işlemi yapar. bazen sistemi durdurur bazen durdurmaz. bu mantığa low-pause collection deniliyor.
  - young generation için hep sistemi durduruyor
  - GC kendi içinde concurrent çalışmaktadır (paralel'den farklı mantıktır. başka başlıkta anlatıldı.)
- G1 (yada garbage first) collector
  - CMS ile benzer mantıkta çalışmaktadır.
  - çok büyük heap size verilmiş sistemler için uygun.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# JVM components

# byte code verifier

kodları okuyup jvm sürümüne uygunluğunu ve validation'ununu yapan mekanizmadır.

# class loader

class'ları bellekten okuyarak JVM'e aktarır. classloader'da bir java sınıfıdır yada sınıflar grubudur. aynı jvm'de her app farklı classloader kullanabilir. tomcat ve spring'in kendi classloaderları var.

- jvm'in içindeki default classloaderın ismi "bootstrap class loader (yada primordia class loader)"'dır. bunun asıl amacı /lib ($JAVA_HOME\lib\rt.jar ve diğerleri) dizinindeki core jre kütüphanelerini import etmektir.

- "Extension Class Loader" ise bootstrap'in bir child'ıdır. bootstrap tarafından çağrılır. \lib\ext\ içini yükler.

- "Application Class Loader (yada System Class Loader)" ise Extension tarafından çağrılır. Extension'ın child'dıdır. jvm başlatılırken, jvm'e paramtre geçilen path'lerden class'ları yüklemekle görevlidir.

# execution engine

ya JIT yada interpreter'a iletilerek kodun çalıştırılmasını sağlar.

# garbage collector

boş referanslı verileri temizlemektedir.

# security manager

private metodları çağırılmasını engellemek gibi güvenlik duvarı görevi görmektedir. jvm'e parametre geçilerek herşey serbest bırakılabilmektedir.

# Tomcat classloader

Tomcat sırası ile bunları işletir:

- JVM's bootstrap classloader (with it's child-class loaders)

- System class loader

  $CLASSPATH variable'ında olan sınıfları yükler. fakat /tomcat/bin/catalina.sh or /tomcat\bin\catalina.bat script'i CLASSPATH değerini ignore eder ve CLASSPATH'e kendisi /tomcat/bin/ içerisindeki bazı lib'leri yükler.

- Common class loader

  Aşağıdakileri load eder:

  - unpacked classes and resources in $CATALINA_BASE/lib
  - unpacked classes and resources in $CATALINA_HOME/lib
  - JAR files in $CATALINA_BASE/lib
  - JAR files in $CATALINA_HOME/lib

- WebappX

  sadece bu classloader'dan yüklenen class'lar webapp'a özeldir. diğer web app'ler bunları göremez. bu dizinleri sırası ile yükler:

  - /WEB-INF/classes
  - /WEB-INF/lib

Tomcat'in loader configurasyonunda aşağıdaki belirtildikçe yukarıdaki sıra geçerlidir. eğer aşağıdaki belirtilmişse sıra aşağıdaki gibi olur:

```xml
<Loader delegate="true"/>
```

- bootstrap of jvm
- WebappX
- System
- Common

Tomcat'te default açık olmayan classloader'lar:

- Server: sadece tomcat'in görebildiği kütüphaneler.
- Shared: tüm web uygulamalarından görülebilen kütüphaneler. buradakilerin tekrar yüklenmesi için tomcat'in restart edilmesi gerekir.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# jvm parametreleri

jvm paramtrelerinde -x ile başlayanlar her jvm de farklı implemente edimiş olabilir. fakat x'siz başlayanlar her vm de olmak zorundadır.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# exceptions

# try with resource 
try parantezinin içinde olan BufferedReader java.lang.AutoCloseable'dan implemente eder. bu şekilde java onu hata olursa otomatik kapatır.

```java
try( BufferedReader br =new BufferedReader(new FileReader(path)) ){

   return br.readLine();

} catch (Exception e) {
    //no need to close the "BufferedReader br"
}
```

# class hiyerarşisi

- Object

  - Throwable

    - Error

      - VirtualMachineError

        - InternalError

        - OutOfMemoryError

        - StackOverflowError

        - UnknownError

      - AssertionError

      - OutOfMemoryError

      - ThreadDeath

      - AnnotationFormatError

    - Exception

      - RuntimeException

        - NullPointerException

        - ArithmeticException

      - IOException

        - FileNotFoundException

- Tüm throwable nesneleri throw/catch edilebilirdir.

- Error ve altındaki objeler manuelde "throw new OutOfMemoryError()" şeklinde fırlatılabilirler. fakat catch edilmek zorunda dillerdir.

- Error'lar ne kadarda genel VirtualMachine sorunları gibi gözükselerde, Exception'lar gibi belirli bir satırdan fırlatılırlar. Örneğin OutOfMemoryError tam olarak bu satırdan fırlatılabilir: "new byte[999999999];"

# Checked exception vs unchecked exception
bazı Throwable'lar catch edilmek zorundadır. yoksa kod compile edilemez. catch edilmek zorunda olan Throwable'lar "checked"'dır.

RuntimeException ve Error ve bunların subclass'ları haricindeki tüm Throwable'lar checked'tır.

Eğer unchecked exception yaratmak istiyorsak, yeni exception'umuzu unchecked excepiton'lardan türetmeliyiz.

# finally block on java

finally methodu catch'te excepiton meydana geldiğinde de çalışır. örnek:

```java
public static void myMethod() throws Exception {
		FileInputStream inputStream = null;
		try {
			File file = new File("./notexist.txt");
			inputStream = new FileInputStream(file);
			
		} catch (FileNotFoundException e) {

			System.out.println("this print will be executed 1");
			throw new Exception();
			
		} finally {
			
			System.out.println("this print code will be executed 2");
		}
		System.out.println("this print code will NOT execute 3");
	}
```

# best practices
- istisnalar dışında; sadece checked olan Throwable'lar fırlatılmalıdır. örneğin; arithmeticexcepiton (uncheckted) fırlatılmamalıdır. çünkü zaten unchecked excepiton'lar JVM tarafından fırlatılıyor. Tekrar yazmanın bir anlamı yok. kod kalabalığı yaratırız. örnek:

  ```java

  if( a == 0){
    throw new ArithmeticException();
  }
  return b/a;

  ```

  Yukarıdaki kod sadece kod kalabalığı yaratmaktadır. zira arithmetic excepiton bu metodu çağıran yazılımcı tarafından yakalanmak zorunda diildir.

- her çeşit exception ayrı ayrı fırlatılmalıdır. hepsi gruplanıp fırlatılmamalıdır. öblyece yakalan metod ne her exception çeşidi için ayrı ayrı ne yapacağına karar verebilir.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Java Specification Requests (yada JSR)

Java ve JavaEE için toplulukların yayımladığı spesifikasyon yayımlarıdır.

# JDK Enhancement Proposal (yada JEP)

OpenJDK için toplulukların yayımladığı spesifikasyon yayımlarıdır.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# @transient

basic java anotation'ıdur. serialize edilirken bu objenin esgeçilmesini sağlar. gson ve diğer tüm serialize etme kütüphaneleri bu değeri kullanır.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# remote debug

java uygulaması çalıştırıldığında debug parametresi ile başlatılır ise; jvm bir port üzerinden "debugger" uygulamasının kendisine bağlanmasına izin verir. debugger uygulaması genelde bir IDE'dir. IDE uygulamaya bağlanır. IDE üzerinde önceden proje tanımlanmıştır, bu şekilde source code ile java uygulaması arasında ilişki kurulabilir.

bir uygulamayı localde IDE ile debug ettiğimizde, IDE arkaplanda bu işlemi yapar fakat yazılımcıya farkettirmez. remote=localhost olur.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# primitive

türkçe kelime anlamı: ilkel

primitive proramlama diline gömülü olan data tipleridir (data type). örnek: int, char, byte gibi.

# literal

bilişimde kullanılan literal kelimesinin türkçesi mevcut değildir.

literal kelimesinin türkçe anlamı: gerçekçi olan, kelime kelimesine aynı olan.

literaller primitive'lere atanabilecek değerlere verilen isimdir. örnek true, false, 'C', 123 gibi. bunlar "new" operatörü kullanılmadan oluşturup atanabilirler.

# primitive vs literal

int count = 9; //bu satırda int bir primitive'dir. 9 ise literaldir.

char first = 'C' //c bir literal; char ise bir primitive'dir.

çoğu makalede primitive ve lietral kelimesi birbiri yerine kullanılmaktadır. fakat farklı kavramlardır. buradaki anlatımlarda alt kısımdada yanlış kullanılmış kısımlar olabilir. üst tarafta kesin doğru anlatım mevcuttur.

# java'da primitive'ler

byte, short, char, long, boolean, float, double, int.

String, Float gibi kavramlar büyük harfle başladıklarından birer sınıfı temsil ederler. literal değillerdir. kendi içlerinde literal barındırır ve onlar için hazır metodlar bulundururlar. isteğe bağlı kullanılabilirler ve birbirlerine her zaman cast edilebilecek şekilde tasarlanmışlardır.

# integer (yada tamsayı)

integer'a verilecek değeri 3 farklı şekilde set edebiliriz:

- binary (yada ikili düzen): int myVal = 0b101; //b harfi büyükte olabilir

- Decimal (yada tr:desimal yada onluk düzen): int myVal = 5;

- Oktal (yada sekizlik düzen): int myVal = 010; //önünde sıfır olduğundan otomatik 8 lik tabanda algıladı

- Hexadecimal (yada onaltılık düzen): int myVal = 0x1A; //önünde 0x olduğundan otomatik algıladı

Yukarıdaki 0x, 0, 0b standratları genelde tüm programlama dillerinde (ve matematiksel/bilimsel ifadelerde) de kullanılmaktadır.

java 7 ile birlikte sayı tiplerinde degerlerin arasına alt çizgi koyulabilir. okunaklığı arttırmak için. int a = 100_300_500; gibi.

# long

long a = 150L; veya long a = 150l; şeklinde set edilebilir. eğer long a = 150; yazılırsa 150 değeri int oldugu için otomatik olarak long'a cast edilir.

# Kayan Noktalı Literaller (yada floating point literal)

double a = 2e-5;  //küçük e yada büyük E kullanıalbilir.  2*(10^(-5)) anlamına geliyor. e karakteri 10 sayısını temsil ediyor. ve sol tarafındaki sayı ile çarpılıyor.

double b = 3e+1;  // yada '3e1' = 30 yapıyor

double b = 3*e+1; // hata verir. e sayısı normal sayı gibi kullanılamaz. özel bir gösterimdir. e karakteri 'Exponential (yada üssel)' matematik ifadesinin baş harfidir.

Yukarıda 'e' karakteri hexadecimal bir sayıda 14 rakamına denk gelmektedir. Bu sebeple hexadecimal bir sayı yazıldığında e harfi yanlış anlaşılma yaratıyor. örnek:

0x11e+3 // bu (ondalık)3 ile (onaltılık)11e sayısının toplamı gibi duruyor. dolayısı ile standart belirlenmesi için hexadecimal işlemlerde 'e' yerine 'p' karakteri kullanılır. 'p' karakteri 10 sayısına değil, 2 sayısına denk gelmektedir. yani;

double c = 0x3p4; // 2*(2^4)

# float

javada  float a = 42.8F; yazıldığında 42.8 int olamayacağı için double kabul edilir. double'yi float'a çevirmek için suffix eklenir.

# char

char x = ‘\141'; //Oktal düzende 141 = 97'dir ve ASCII tablosunda 97=a karakteri olduğuna göre; x'e "a" değeri atanır. \ işareti oktal düzeni ve ASCII tablosunu temsil eder.

char y = ‘\u0061'; // \u onaltılık düzeni ve UNICODE tablosunu temsil eder.

# cast işlemleri

cast edilen taraf, dönüştürdüğümüz tipin değerinden büyük ise, ondalık kısmını kaybedebilir, yada dönüştürdüğümüz tipin maksimum değerini alır. örneğin (byte)150; değeri işlemi sonucu bize 127 verecektir. (int)50.9 değeri bize 50 verecektir.

# Standart büyüklükler

işletim sistemi ve donanımlar yazılımların en az byte tipinde veriyi işletmesini sağlarlar. Tabi bazı istisnalar da var: bazı cihazlar en düşük birimi 8 bit kullanmıyor. fakat bunlar çok özel amaçlı makinelerdir.

CPU'lar ek olarak ineger, floating point gibi bazı hazır tiplerde sunarlar. SUndukları bu tipler üzerinde toplama, çıkarma gibi birçok işlem de sunarlar.

Derleyiciler/Programlama dillerinin sundukları tipler 2 farklı şekilde olabilir:
- diller kendi içlerinde tipler de yaratırlar. bu tipler byte'lar üzerine kuruludur.
- bazı tipler direk cpu'nun native destek verdiği tip'lere referans ederler. örneğin C'deki int, cpu'nun sunduğu native integer'a referans eder. bu sebeple boyutu dinamiktir.

Bazı tipler IEEE gibi kuruluşlar tarafından standartlara bağlanmaya çalışılsa da, her dilin yada cpu'nun bu standartları kullanacağı kesin değildir. hatta bir dil IEEE standartlarını kullanıyor olsada, tüm kuralları %100 aynı şekilde kullanmaz. IEEE üzerine ufak düzenlemeler/değişiklikler yapabilir.

Aslında dilden ziyade, compiler büyüklüklere karar verir. compile sırasında makine ve işletim sistemi tipine göre karar verir ve büyüklükler dinamik olabilir. bu sebeple kod yazılırken C dilindeki gibi "sizeOf" fonksiyonları ile işlem yapmak gereklidir.

Oracle'ın Java standartlarında 32 bit ve 64 bit makinalarda tiplerin boyutları sabittir. bunlar:

byte: 1 byte

char: 2 byte

short: 2 byte

int: 4 byte (virgülsüz)

long: 8 byte (virgülsüz)

float: 4 byte (virgüllü)

double: 8 byte (virgüllü)

# word
bu terim bilgisayarlarda cpu'nun desteklediği bir birimdir. cpu aynı zamanda bu desteklediği word üzerinde işlemler (toplama, çıkarma...) yapılabilecek arayüzler sunar. cpu'larda işlem yapılabildiğinden dolayı, word'ler cpu'nun registerlarında da saklanabilmelidir. bu sebeple "word" tanımı bazıları tarafından registerların desteklediği boyutlar anlamında kullanılmaktadır. Word tanımı çok ne tdiildir. çünkü çoğu cpu birden fazla tip sunarlar: integer, floating point types... Bu sebeple hangisinin word olacağını söylemek çok net diildir.

örneğin bazı cpu'lar için word 8 bit, bazıları için 64 bit olabilir. 

# 32 bit vs 64 bit vs others
bu ayrımlar cpu'ların mimarisine dayanmaktadır. eğer bir cpu 32 bit destekli ise regster'larındaki 32 bitlik data'yı tek instruction cycle'da okuyabiliyor anlamına gelmektedir. okunan data cpu'nun __datapath__'lerinden taşınmak zorunda olduğu için "datapath widths" 32 bit olmalıdır.

dolayısı ile; cpu'daki register'lardan 64 bitlik data'nın okunması gerektiğini düşünelim. 32 bitlik bir cpu 2 kere döngüye girecektir. 64 bitlik makine ise işlemi tek bir hamlede tamamlayacaktır. performans farkı buradan gelmektedir.

cpu'nun register'larında RAM'in adresleri __Memory Address Register (MAR)__'larda saklanmaktadır. çünkü CPU işlem için RAm'in neresinden data çekeceği, işlem bitince sonucu nereye yazacağını kendi içinde tutmak zorundadır. dolayısı ile 32 bitlik makine en fazla 2^32=4 GB'lik RAM'e işaret edebilir. oysa 64 bitlik makine 2^64'lük adrese işaret edebilir. fakat 32 bitlik işletim sistemleri bazı workarround yöntemlerle 32 bitlik makinalarda 8GB'nin üstünde RAM destekletebilmektedirler.

# unsigned vs signed
- sayısal olan her değerin (int, long, double) signed ve unsigned türevleri olabilir. 
- unsigned int 0011=3 ise, signed int (yada sadece "int") için 1011=-3 tür. En başta olan bit değeri negatif olup olmadığını belirler. bu bit'e __sign bit__ denir.
- bir değeri okurken unsigned mi yoksa signed mi olduğu mutlaka bilinmelidir.
- C dilinde her int signed'dir. unsigned veya signed keyword'leri C de özel keywordlerdir ve primitive'lerin önüne koyulabilirler.
- Java'da unsigned tipte primitive yoktur.

# BigInteger vs BigDecimal

Java'da sadece sınıf olarak kullanılama açıktırtırlar (primitive değildir). BigInteger sadece tamsayı (noktasız), BigDecimal noktalı sayıları tutar. teorikte sınır yoktur. fakat pratikte limit mevcuttur.

# matematik aritmetik işlemler hatalı olabilmesi

bunun 2 temel sebebi var:

- ## degerin kaybolması

programlama dillerinde aritmetik işlemler hatalı sonuç vereibliyor. örneğin; int 10 / int 3 = int 3 vermektedir. sayısal değerler kayba uğramıştır. aynı şekilde noktalı sayılarda da limit olduğu için hassas işlemlerde kayıp yaşanabiliyor. bu yüzden özel matematik kütüphaneleri kullanılmalıdır.

bir hesap makinesi diğer hesap makinesi ile farklı sonuc da verebiliyor. çünkü hesap makineside bir bilgisayar.

- ## precision of floating point number format (yada kayan noktalı sayı formatının hassasiyeti) 

Float ve double literalleri kendi içlerinde belli notasyonlarda (formatlarda) tutuluyorlar. Fakat yazılım geliştirici bundan habersizdir. bu format 2'lik düzende olmak zorundadır.örneğin; bir dil dil ve primitive double değerini yarattık. double'ı belli bir formatta 64 bitte tutalım. ilk 1 biti negatif/pozitif bilgisini tutsun. diğer 31 bit üs, 32 bit bit değeri olsun. bu tarz durumlarda 0.3 sayısını tam olarak tutturamadığımızı görürürüz. ekrana bastırmak istediğimizde bu sayıyı yuvarlamak durumunda kalabiliriz. bu tarz durumlar her dilde meydana gelmektedir.

- ## çözüm

çözüm olarak primitive değil sınıf bazlı matematik kütüphanelerinden yararlanmalıyız. örneğin; BigINteger, bigDecimal bu sorunları ortadan kaldırıyor.

BigDecimal gibi değerleri initialize ederken, string bazında etmek daha doğru  sonuçlar verecektir. örnek:

```java
double d = 0.3;

BigDecimal bd = new BigDecimal(Double.valueOf(d));

System.out.println(bd); //prints 0.29999

string kullanarak initialize edilirse:

BigDecimal bd = new BigDecimal("0.3");

System.out.println(bd); //prints 0.3
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# java Serializable

bi sınıfın içindeki anlık değerler ile byte olarak kaydedilmesidir. De-Serialization işlemi ise byte dizisinden java sınıfına aktarılmasıdır. byte'a çevrilecek sınıf  Serializable sınıfının implemente etmek zorundadır.

# serialVersionUID

bu deger Serializable'dan implemente edilmiş sınıflarda olmalıdır. bu deger byte'a çevrilen sınıfın içine gömülür. byte dizisinden De-Serialization yapıldığında eğer sınıfın serialVersionUID'si aynı ise De-Serialization uyumlu buldugu tüm degerleri sınıf degerlerine doludurur. eğer serialVersionUID farklı ise, direk olarak hata alınacaktır. bu sebeple yazılımı geliştirirken serialVersionUID 'leri manuel atamakta yarar var. aksi durumda derleme sırasında bu değerler rastgele atanacak ve dosyadan De-Serialization işlemlerinde aynı serialVersionUID olmayacağı için, yeni alan eklenmiş sınıflara dahi De-Serialization olumlu sonuçlanmayacaktır.

# Eclipse'in sunduğu otomatik serialVersionUID seçenekleri

1- default serialVersionUID: 1L (long tipinde 1 değeri) atanır. serialVersionUID degeri önemsiz olan sınıflara atılması için önerilir.

2- oto generated serialVersionUID: sınıfın içindeki tüm değişkenlere bakılır. tüm bu değerlere göre bir hash üretilir. bu hash ile serialVersionUID oluşturulur. bu algoritma ile aynı aynı olan tüm sınıfların serialVersionUID'leri aynı olacaktır. bu şekilde başka bir yazılım tarafından okuanan serialize edilmiş veri başarılı şekilde okunabilecektir. java sınıfımızda bir değişiklik yaptığımızda serialVersionUID otomatik değişecektir. artık modelimiz serialize edilmiş dosyadan okuyamayacaktır. zaten beklenen de budur.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# java SE (yada java standart edition yada eski adı: J2SE) vs java EE (yada Jakarta EE yada java enterprise edition yada Java 2 Platforms yada java Platform yada eski adı: j2ee)

ortalama bir desktop bilgisayar ihtiyaçlarını karşılayan platformlar için java-runtime içinde bulunan kütüphanaler javaSE grubudur.

javaee, javase'yi kullanan ekstra kütüphanaler içerir. runtime sırasında hangi kütüphanelerin olup olmayacağına çalışan uygulama (sunucu) belirler. ek kütüphanaler jar'ın içinde yada classpath'te bulunmalıdır. bu kütüphaneleri barındıran sunucular glashfish, weblogic'tir.

# sürümler

jre'nin sürümleri ile jdk aynı olmalıdır (yada geriye uyumlu modda çalışılır). fakat javaEE'nin sürümleri jre'den bağımsızdır. Fakat javaEE jre ile aynı zaman dilimlerinde aynı sürüm numaralarını kullanmaya çalışır. bu tamamen isteğe bağlı yapılan bir seçimdir.

javase için çıkış tarihleri ve sürümler:

(eskiden jdk ile bütünleşik geliyordu, bu sebeple ilk isimleri jdk olarak geçmektedir)

- JDK 1.0 (1996)

- JDK 1.1 (1997)

- J2SE 1.2 (1998)

- J2SE 1.3 (2000)

- J2SE 1.4 (2002)

- J2SE 5.0 (2004)

- Java SE 6 (2006)

- Java SE 7 (2011)

- Java SE 8 (2014)

- Java SE 9 (2017)

- Java SE 10 (2018)

- Java SE 11 (2018)

- Java SE 12 (2019)

javaEE için çıkış tarihleri ve sürümler:

- 2EE 1.2 (1999)

- J2EE 1.3 (2001)

- J2EE 1.4 (2003)

- Java EE 5 (2006)

- Java EE 6 (2009)

- Java EE 7 (2013)

- Java EE 8 (2017)

# jdk (yada java development kit)

jdk içinde javaee kütüphaneleri bulunmaz.

jdk içinde; wsimport (web service yaratma tool'u), keytool (sertifika import/export tool'u) gibi birçok utility + jre + compile tool'ları bulunur.

# oracle jdk (yada eski adı: sun jdk) vs openjdk

(not: jdk'lar kendi içlerinde kendi jvm'lerini içermektedirler.)

OpenJDK, javaSE'nin 7'inci sürümü ile artık referans implementasyon olmuştur. yani sadece desktop makinalar için jvm implementasyonu olarak openjdk gösterilidir. yani; artık oracle jre'si openjdk üzerine kuruludur. eskiden de openjdk ve oraclejdk birbirleri ile ortak kodları kullanarak ilerliyorlardı, fakat 7inci sürüm ile artık kesin olarak oraclejdk, openjdk implementasyonu olacağı garantisi verilmiştir.

oracle-jdk ie openjdk arasındaki farklar şunlardır:

- oraclejdk'nın lisansı farklıdır

- Java Plugin and Java WebStart

- JRockit Mission Control (detaylar baska yerde yazıyor)

- font'lar

- bazı ek kütüphanaler

- oracle jdk 11 ve jvm 11 artık ücretli olmuştur. her canlıya atılan paket için oracle'a ücret ödenmelidir.

Openjdk aslında sadece soruce code'u temsil etmek için kullanılan bir terimdir. AdoptOpenJDK; openjdk'yı manipüle edip derlemektedir. aşağıda farklı başlıkta detaylı tablosu mevcut. 

# IcedTea

openjdk'yı geliştiren community tüm OS'ları desteklememektedirler. bu sebeple farklı bir topluluk openjdk'yı diğer OS'lara entegre eder. yani openjdk'yı farklı platformlar için build eder.

# IcedTea-Web

openjdk'da olmayan bir ek modüldür. bu modül web tarayıcıları için java eklentisi sunar. java-plugin'e açık kaynaklı alternatiftir.

# Eclipse Enterprise for Java (yada EE4J)

JavaEE oracle tarafından geliştiriliyordu. 2017'de oracle eclipse vakfına geliştirmeyi bıraktı. eclipse ise JavaEE'yi, JakartaEE olarak değiştridi. JakartaEE ve onunla ilişkili diğer tüm projeler için root proje olarak EE4J ismi verildi.

# WebStart vs java plugin

java plugin; web tarayıcıya kurulan eklentinin ismidir.

WebStart; appletlerin bir sonraki adımı gibi düşünülebilir. local siteme uygulama (applet benzeri ufak uygulama) indirme, çevirimdışı daha sonra açmak için işletim sistemine kısayol atama, kurulan uygulamaları yönetebilme, sürüm güncelleme gibi işlevlerin yapılmasını sağlar. bu uygulamalar tarayıcıdan direk olarak kurulabilir. bu uygulamacıklarda permission'lar çok kısıtlıdır.

# java applet

java runtime'a ihtiyac duyar. client tarafta tarayıcı üzerinden java-plugin aracılığı ile uygulama çalıştırır.

# javafx

masaüstü uygulaması yazılmasını sağlıyor. ek olarak webview kullanımını kolaylaştırmıştır. vewbview içerisini editleme ve üzerinde farklı syntax'lar ile düzenlemeler yapma özellikleri (entegrasyon) sunmaktadır. vewbview içerdiğinden, birçok GUI elementi HTML elementi olacağından, javadaki diğer GUI kütüphanelerine göre daha cross-platform olduğu söylenebilir.

# hotspot

jvm spesifikasyonunu implemente eden birçok jvm mevcuttur. oracle'nin resmi jvm'inin ismi "hotspot"'tur. piyasada onlarca jvm implementasyonu mevcut. örnek: JRockit(java 7 döneminde geliştirilmesi durduruldu), IBM J9, OpenJDK...

oracle'ın jvm ismi olan hotspot, içerdiği hotspot teknolojisinden gelmektedir. sun jvm, oracle tarafından satın alınmadan önce JRockit olarak adlandırılıyor.

hotspot ilk bu isimle çıktığında, özel bir teknoloji barındırıyordu. bu teknoloji; sık kullanılan kod bloklarını, daha hızlı erişebileceği bir bellekte tutmakta ve o kod blokları için optimizasyonu arttırmaktadır. kodlar hakkında istatistikler tutmaktadır. bu istatistikler sonucunda;

- sık kullanılan kod blokları native makine koduna çevrili şekilde hazır tutulmaktadır

- gereksiz bazı kod blokları yürütülmemektedir

- bazı kod bloklarındaki sık girilen if blokları başa taşınmakta, az kullanılan if'ler alta taşınmaktadır

- ve daha birçok teknik kullanılmaktadır

"hotspot" kelimesi sık kullanılan bölgeleri (sıcak bölgeleri/noktaları) belirtmek için kullanılan genel bir terimdir. jvm'in ismi de buradan gelmektedir.

Java dili eskiden interpreter gerektiren bir dildi. Artık güncel sürümlerde hotspot teknolojisinin gelişmesi ile bazı kod blokları, native kod olarak saklandığı için, tekrar interpreter tarafından işletilmiyor. direk olarak makinada run ediliyor (native app gibi). dolayısı ile yeni jvm sürümleri yarı interpreter yarı native kod çalıştırır durumdadır.

java -version ile komut satırından bilgi alındığında "mixed mode" çıktısı; JIT'in de kullaıldığı anlamına gelmektedir. isteğe bağlı bu özellik devre dışı bırakılabilmektedir.

# native lib

java hotspot ile sık girilen kod bloklarını native makine koduna çevirip saklamaktadır. fakat önceden yazılmış default kütüphaneler (jvm içerisden default gelen sınıflar) önceden makine koduna derlenmiş saklanabilmektedirler. bunlara native lib denmektedir.

nativelib içerisindeki kütüphaneler işlemcilerin özelliklerinden de yararlanmaktadırlar. örneğin System.arraycopy() metodu array kopyalamayı işlemcinin özelliğinden yararlanarak yapar. bu tarz metodlardan faydalanmak uygulama hızını çok etkilemektedir.

# Corretto
amazon firmasının geliştirdiği, openjdk forkudur. oracle jdk ücretli olunca (11.inci sürüm) böyle bir çözüme gidildi.

# openJDK builds
openjdk stabil olsada, production-ready build'leri resmi olarak süreklilik garantisi verilerek dağıtılmamaktadır. dolayısı ile production-ready değildir. fakat production ortamında kullananlar vardır. bu sebeple; open-jdk kullanmak istemeyenler farklı jvm implementasyonları kullanırlar. zaten nerdeyse tüm jvm'ler openjdk'yı referans alır ve üzerine eklemeler/çıkarmalar yapılarak dağıtılırlar.

- openjdk, oracle tarafından geliştirildiği için openjdk'nın sitesinde https://openjdk.java.net/install/ indirme linkleri oracle-djk'yı indirir. çünkü openjdk türevi olan production-ready örneği olarak oracle kendini gösterir. dolayısı ile download linkleri buraya yönlenir: https://www.oracle.com/technetwork/java/javase/downloads/index.html

- OpenJDK build'leri ise buradan indirilebilir: https://jdk.java.net/archive/

- https://adoptopenjdk.net projesi openjdk'yı direk olarak saf haliyle derleyip sunmaktadır. projenin arkasında güçlü destekçiler vardır.

- Ubuntu "apt install openjdk-8-jre" komutu ile openjdk'yı kurar.

# Oracle jdk vs adoptOpenjkd

detaylı bilgiye buradan ulaşılabilir: https://adoptopenjdk.net/migration.html

| Oracle JDK 8 proprietary component         | Alternative component     | OpenJDK 8         | OpenJDK 11        |
|--------------------------------------------|---------------------------|-------------------|-------------------|
| Java Web Start                             | IcedTea-Web               | yes               | no                |
| JavaFX                                     | OpenJFX                   | no                | no (coming soon)  |
| T2K font rendering engine                  | Freetype                  | yes               | yes               |
| Monotype Lucida fonts                      | Relicensed Lucida fonts   | no (coming soon)  | no (coming soon)  |
| Ductus 2D renderer                         | Pisces/Marlin             | yes (Pisces)      | yes (Marlin)      |
| Kodac Color Matching System (KCMS) library | LCMS                      | yes               | yes               |
| SNMP                                       | Use JMX (or SNMP4J)       | yes (not bundled) | yes (not bundled) |
| Sound drivers                              | Use Windows sound drivers | yes (not bundled) | yes (not bundled) |
| Java Flight Recorder (JFR)                 | Java Flight Recorder      | no (coming soon)  | yes               |
| Java Mission Control (JMC)                 | Use JDK Mission Control   | no (coming soon)  | no (coming soon)  |

Not: JavaFX, JFR, and JMC, java 8 ile Oracle tarafından openjdk projesine dahil edildi.

# Technology Compatibility Kit (yada TCK)
JVM olabilmek için belirlenmiş standartlardır. Tüm JVM'ler TCK'da belirtilen kurallara uymak zorundadırlar.

# zulu
Azul firması tarafından geliştirilen openjdk türevidir.

# openj9
eclipse vakfının ürettiği openjdk türevi jvm implementasyonu.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# java 7 vs 8

- lambda expressions + function interface (konular başka başıkta anlatılıyor)

- stream

- javafx tümüyle jdk içinde entegre gelmektedir.

- Nashorn (konu başka başıkta anlatılıyor)

- "Optional" sınıfı geldi (konu başka başıkta anlatılıyor)

- Java Misson Control: Java yazilimlarinizi kontrol edebileceginiz bir tool. Mesela programiniz ne kadar CPU, hafiza ve threats kullaniyor.

- permgen politikası değiştirildi

- new Date-Time API. "java.time" isimli yeni kütüphahe paketi eklendi. eski sürümlerde hem java.util.Calendar hemde java.util.Date kullanılıyordu. hala jvm'lerde geriye uyumlu çalışabilmesi için kaldırılmadılar.

- default keyword: interface'de metod önüne "default" keyword'ü atılıp o metodun body'si yazılabiliyor. Eğer yazılırsa artık implementasyonlarda o metod override edilse bile interfacedeki metod çağrılıyor. Yani abstract sınıftakilerden  bir durum var.

  Burada Java zorunlu implementasyon yaptırmak istemiyordu. sadece interfacede metod implemente edilmesi isteniyordu. fakat zorunlu implementasyon geriye uyumluluğu sağlamak için eklendi. şu sebepten:  örnek üzerinden gidelim: List interface'sine bir metod eklenmek isteniyor. bu metodu JDK eklerse tüm güncel yazılımlar artık kullanılamaz hale gelecektir. çünkü tüm yazılımdaki list implementasyonları çalışmaz olacaktır. çünkü interfacedeki tüm metodları implemente etmek zorundalar. fakat artık implemente etme zorunlulukları olmadığı için bu metodlar sorunsuz çalışıyor olacaktır. 

- java.util.Base64 ile base64 işlemleri birçok implementasyon destekleyecek şekilde tasarlandı (başka yerde anlatılıyor)

# java 8 vs 9

- Java REPL (yada JSHELL yada Java Shell). 'Kulla' projesi altında geliştiriliyor.

- modülerlik. 'Jigsaw' isimli projesidir. artık her jar, kendi descriptor'unda hangi paketleri dışarıya açılacağını (dışarıdan göreülebilir olacağını) ve hangi modüllere depend ettiğini belirtebilmektedir.

- Process API geliştirmeleri. alt-process'leri yönetirken artık ok daha fazla API mevcuttur.

- Factory Methods for Collections. artık factory metodlar mevcut. örnek:

  > Set<Integer> ints = Set.of(1, 2, 3);

  > List<String> strings = List.of("1", "2");

- Reactive Streams (başka yerde anlatılıyor)

- Optional ve Stream API'lerindeki gelişmeler

- \@Deprecated (forRemoval=true , since="9") ile artık hangi versiyondan sonra bu metodun var olmayacağını dökümante edebiliyoruz.

- HTTP/2 ve websocket geldi. Eski sürümlerde üçüncü parti kütüphanelerle kullanılıyordu. javaee ve spring kendi içinde üçüncü parti kütüphaneleri gömülü getiriyor ve onları kullanıyordu. bu sebeple eski sürüm java kullanılsa bile, javaee veya srping kullanarak websocket ve http2 kullanıalbiliyordu.

# java 9 vs 10

- var list = new ArrayList<String>(); type safe olmayan nesneler tutulabiliyor

# modülerlik

- Java 9 ile artık "java.se" modülü jre içindeki kütüphaneleri barındırıyor.
- Java 9 ile java.se artık jaxb gibi JavaEE'ye ait olduğu düşünülen kütüphaneleri deprecated olarak işaretlendi.
- Java 9 ile jaxb gibi JavaEE'ye ait olduğu düşünülen kütüphaneler default classpath'te gelmiyorlar fakat JDK içerisinde yüklü geliyorlar. Yani development yaparken ilgili jar'ları hala bulabiliyoruz fakat projemizde ufak config yapmak gerekiyor.
- JDK 11 ile jaxb gibi javaee'nin olduğu düşünülen paketler jdk içinden tamamen kaldırıldı.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# ORM (yada Object to Relational Mapping)

ORM programlama dilinden bağımsız, veritabanı objelerinin programlamada haritalanmasının (mapping) genel ismidir.

# Persistence (yada süreklilik)

Bilişim dünyasında persistence, bir işlemin sürekliliğinin sağlanması kastedilir. işlemin sürekliliği olabilmesi için state'in (data'nın) bir yere kaydedilmesi gerekir.

# JPA (yada Java Persistence API)

java için ORM spesifikasyonudur.

# eclipselink (eski adı: toplink) vs Hibernate vs openJPA

Birer JPA implementasyonudur.

# JDBC (yada Java Database Connectivity) vs JPA

JDBC, java için database spec'idir. (driver olmadan bir işe yaramaz.) JPA kendi içinde JDBC kullanır. JDBC databaseye bağlanan ve üzerinde işlem yapmaya yarayan API'dir. Her database bunun implementasyonlarını (driver'larını) yapar (mysql, oracle...). Bunun üzerine ORM yeteneğini katarak JPA ortaya çıkmıştır.

# ojdbc
oracle database'sinin jdbc driver'ıdır.

# ODM (yada Object Document Mapping)

ORM relational databaseler için mapping yaparken, ODM sadece nosql'ler (relation olmayan databaseler) içindir.

# database Dialect vs database Driver

dialect türkçe anlamı: lehçe

Driver bir databaseye giderken soket üzerinden kullandığı erişimi sağlayan yazılımdır. örneğin bir sql komutunu şu ip'li databsede çalıtır dediğimizde bu işi halleder.

driver ise SQL versiyonudur. SQL dilinin birçok türevi ve versiyonu çıkmıştır. bazı database'ler birçok farklı SQL türevine ve versiyonuna destek verir. işte bu durumlar için Dialect özelliğini kullanırız.

bir spring uygulamasını jpa ile ayağa kaldırırken, hem dialect hemde driver vermemiz gerekir. eğer dialect vermezsek default dialect'i kullanacaktır.

# mybatis (yada eski adı:ibatis)
ibatis sonlandırıldı ve isim değişikliği ile mybatis ile geliştirilmelerine devam edildi.

mybatis veritabanı işlemleri yapmaya yarayan java kütüphanesi. SQL sonuçlarını java objelerine mapping yapabildiği için ORM aracıdır. fakat JPA implementasyonu diildir.

mybatis çok gelişmiştir:
- lazyload desteği var
- anotation desteği var
- mapping desteği var (orm)
- xml ile önceden query'ler tanımlanıp çağrıldığı gibi, runtime'da da query'ler dinamik yaratılabilmektedir.

örnek bir işlem:

```java
Reader reader = Resources.getResourceAsReader("SqlMapConfig.xml");
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);		
SqlSession session = sqlSessionFactory.openSession(); 

session.delete("Student.deleteById", 2); // "Student.deleteById" query is declared on xml
session.commit();
session.close();      
System.out.println("Record deleted successfully");
```

# jdbc driver types
jdbc'nin çalışma prensiplerini belirlemektedir. client tarafta URL girilirken type belirtilir. örnek oracle-JDBC url girerken şunu gireriz:

> jdbc:oracle:oci:@myhost:1521:inst1

burada "oci" oracle'ın belirlediği bir keyworddür. "oci", type-2'ye referans etmektedir.

- Type 1 driver – JDBC-ODBC bridge

- Type 2 driver – Native-API driver

  client atrafın direk database sunucusunun native client protokolünü kullanır. native protokolü desteklemek için saf java kullanılmayabilir. native client sistemde yüklü bir arkaplan servisi dahi kullanablir. bu tipin taşınabilirliği azdır.

- Type 3 driver – Network-Protocol driver (middleware driver)

- Type 4 driver – Database-Protocol driver/Thin Driver(Pure Java driver)

  ojdbc'de "thin" olarak geçmektedir. bu tipte bağlantılar %100 java kodu kullanır. db sunucusu ile java soketi açıp haberleşirler. %100 java olduklarından her tarafta kullanılabilirler.

# oracle DB version history

i, g, c keyword'leri tamamane rastgele verilmiştir. teknik anlamda hiçbir önemi yok.

| full name and version         | initial verson of serries | latest version of serries |
|-------------------------------|---------------------------|---------------------------|
| Oracle 7.2                    | 7.2.0                     |                           |
| Oracle 7.3                    | 7.3.0                     | 7.3.4                     |
| Oracle8 Database              | 8.0.3                     | 8.0.6                     |
| Oracle8i Database             | 8.1.5.0                   | 8.1.7.4                   |
| Oracle9i Database             | 9.0.1.0                   | 9.0.1.5                   |
| Oracle9i Database Release 2   | 9.2.0.1                   | 9.2.0.8                   |
| Oracle Database 10g Release 1 | 10.1.0.2                  | 10.1.0.5                  |
| Oracle Database 10g Release 2 | 10.2.0.1                  | 10.2.0.5                  |
| Oracle Database 11g Release 1 | 11.1.0.6                  | 11.1.0.7                  |
| Oracle Database 11g Release 2 | 11.2.0.1                  | 11.2.0.4                  |
| Oracle Database 12c Release 1 | 12.1.0.1                  | 12.1.0.2                  |
| Oracle Database 12c Release 2 | 12.2.0.1                  |                           |
| Oracle Database 18c           | 18.1.0                    |                           |
| Oracle Database 19c           | 19.0.0                    |                           |

Oracle OJDBC, jdk, jdbc spesifikasyonu sürümleri uyumu için burada resmi compability matrix table'lar mevcut:

https://www.oracle.com/database/technologies/faq-jdbc.html (archive date: 23/11/2019)

# jdbc url form examples

with username pass:

> jdbc:oracle:thin:ahmet/12345@//myhost:1521/mydb

without username pass:

> jdbc:oracle:oci:@myhost:1521:inst1

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# jdbc

```java
PreparedStatement ps = null;
try {
   String SQL = "Update Employees SET age = ? WHERE id = ?";
   ps = conn.prepareStatement(SQL);
   . . .
}
catch (SQLException e) {
   . . .
}
finally {
   pstmt.close();
}
```

Her açılan jdbc connection'ı için birçok statemen tanımlanabilir. statement'lerin birçok türevi vardır. statement objelerimizi bir kere oluşturduktan sonra dilediğimiz kadar üstüste aynı connection'da çağırabiliriz. statementler (tipine göre) gerektiğinde db-side caching'de kullanmaktadır. statement tipleri:

- Statement

```java
Statement stmt = con.createStatement();

stmt.executeUpdate("CREATE TABLE STUDENT(ID NUMBER NOT NULL, NAME VARCHAR)");
```

- PreparedStatement

```java
PreparedStatement pstmt = con.prepareStatement("update STUDENT set NAME = ? where ID = ?");
pstmt.setString(1, "ahmet");
pstmt.setInt(2, 111); 
pstmt.executeUpdate();
```

- CallableStatement

store prosedurleri çağırmak için kullanılır.

```java
CallableStatement cstmt = con.prepareCall("{call anyProcedure(?, ?, ?)}");
//Use cstmt.setter() methods to pass IN parameters
cstmt.execute();
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# tomcat variants

tomcat: servlets + jsp

tomee: tomcat + jsf + JPA + CDI

tomee-jax-rs: tomee + jax-rs

tomee+: tomee-jax-rs + jax-ws

detailed comparison:

|                                                      | Tomcat | TomEE | TomEE JAX-RS (~ Microprofile) | TomEE+ | TomEE PluME | OpenEJB |
|------------------------------------------------------|--------|-------|-------------------------------|--------|-------------|---------|
| Java Servlets                                        | +      | +     | +                             | +      | +           |         |
| Java ServerPages (JSP)                               | +      | +     | +                             | +      | +           |         |
| Java ServerFaces (JSF)                               |        | +     | +                             | +      | +           |         |
| Java Transaction API (JTA)                           |        | +     | +                             | +      | +           | +       |
| Java Persistence API (JPA)                           |        | +     | +                             | +      | +           | +       |
| Java Contexts and Dependency Injection (CDI)         |        | +     | +                             | +      | +           | +       |
| Java Authentication and Authorization Service (JAAS) |        | +     | +                             | +      | +           | +       |
| Java Authorization Contract for Containers (JACC)    |        | +     | +                             | +      | +           | +       |
| JavaMail API                                         |        | +     | +                             | +      | +           | +       |
| Bean Validation                                      |        | +     | +                             | +      | +           | +       |
| Enterprise JavaBeans                                 |        | +     | +                             | +      | +           | +       |
| Java API for RESTful Web Services (JAX-RS)           |        |       | +                             | +      | +           | +       |
| Java API for XML Web Services (JAX-WS)               |        |       |                               | +      | +           | +       |
| Java EE Connector Architecture                       |        |       |                               | +      | +           | +       |
| Java Messaging Service (JMS)                         |        |       |                               | +      | +           | +       |
| EclipseLink                                          |        |       |                               |        | +           |         |
| Mojarra                                              |        |       |                               |        | +           |         |

full comparison: http://tomee.apache.org/comparison.html

# tomcat version history

| version | jsp | websocket spec | servlet spec | java version                         | release date | Latest release | Latest version release date |
|---------|-----|----------------|--------------|--------------------------------------|--------------|----------------|-----------------------------|
| 2.0     |     |                |              |                                      | 1998         |                |                             |
| 3.0     |     |                |              |                                      | 1999         | 3.3.2          | 2004-03-09                  |
| 4.1     | 1.2 |                | 2.3          | 1.3 and later                        | 2002-09-06   | 4.1.40         | 2009-06-25                  |
| 5.0     | 2.0 |                | 2.4          |                                      | 2003-12-03   | 5.0.30         | 2004-08-30                  |
| 5.5     |     |                | 2.4          | 1.4 and later                        | 2004-11-10   | 5.5.36         | 2012-10-10                  |
| 6.0     | 2.1 |                | 2.5          | 5 and later                          | 2007-02-28   | 6.0.53         | 2017-04-07                  |
| 7.0     | 2.2 | 1.1            | 3.0          | 6 and later (web socket icin min 7 ) | 2011-01-14   | 7.0.96         | 2019-07-29                  |
| 8.0     | 2.3 | 1.1            | 3.1          | 7 and later                          | 2014-06-25   | 8.0.53         | 2018-07-05                  |
| 8.5     |     | 1.1            | 3.1          | 7 and later                          | 2016-06-13   | 8.5.43         | 2019-07-09                  |
| 9.0     |     | 1.1            | 4.0          | 8 and later                          | 2018-01-18   | 9.0.22         | 2019-07-09                  |

# servlet version history

| Servlet API version | Released       | Specification    | Platform                                                  | Important Changes                                                           |
|---------------------|----------------|------------------|-----------------------------------------------------------|-----------------------------------------------------------------------------|
| Servlet 4.0         | Sep 2017       | JSR 369          | Java EE 8                                                 | HTTP/2                                                                      |
| Servlet 3.1         | May 2013       | JSR 340          | Java EE 7                                                 | Non-blocking I/O, HTTP protocol upgrade mechanism                           |
| Servlet 3.0         | December 2009  | JSR 315          | Java EE 6, Java SE 6                                      | Pluggability, Ease of development, Async Servlet, Security, File Uploading  |
| Servlet 2.5         | September 2005 | JSR 154          | Java EE 5, Java SE 5                                      | Requires Java SE 5, supports annotation                                     |
| Servlet 2.4         | November 2003  | JSR 154          | J2EE 1.4, J2SE 1.3                                        | web.xml uses XML Schema                                                     |
| Servlet 2.3         | August 2001    | JSR 53           | J2EE 1.3, J2SE 1.2                                        | Addition of Filter                                                          |
| Servlet 2.2         | August 1999    | JSR 902, JSR 903 | J2EE 1.2, J2SE 1.2                                        | Becomes part of J2EE, introduced independent web applications in .war files |
| Servlet 2.1         | November 1998  | 2.1a             |                                                           | First official specification, added RequestDispatcher, ServletContext       |
| Servlet 2.0         | December 1997  | N/A              | JDK 1.1                                                   | Part of April 1998 Java Servlet Development Kit 2.0                         |
| Servlet 1.0         | December 1996  | N/A              | Part of June 1997 Java Servlet Development Kit (JSDK) 1.0 |                                                                             |

# Catalina
tomcat'in servlet container'ın ismidir.

# Jasper
tomcat'in jsp derleme motorudur. JSP derlenir ve bir servlet'e dönüştürülür.

# $CATALINA_HOME
Tomcat runtime dosyalarının bulunduğu dizindir.

# $CATALINA_BASE
birden fazla tomcat instance'ı aynı anda çalıştırılabilir. her instance'ın bulunduğu config'ler CATALINA_BASE içinde olmalıdır.

eğer CATALINA_BASE set edilmemişse; CATALINA_HOME değeri ona set edilecektir.

# eclipse tomcat config files
eclipse tomcat'i başlatırken config dosyaları için workspace içinde otomatik olarak "/eclipse-worksce/Servers/Tomcat v6.0 Server at localhost-config" isminde bir dizin oluşturuyor. bu dizindeki config'ler tomcat dizini içindeki config'leri override ediyor.

tomcat start edilirken ona zaten tüm config parametreleri (config dosyalarının path'leri, örnek server.xml) komut satırından geçilebiliyor. eclipse'te bu config dosyalarını, tomcat binary'sine otomatik olarak parametre geçiyor. yani gerçek tomcat dizinini override etmemiş oluyor. böylece tek bir tomcat dizini birden fazla eclipse workspace'i tarafından kullanılabiliyor.

# root dizinler

- bin: executable files and "start tomcat", "run as service" like scripts

- lib: jar available for all webapps

- logs

- work: sadece jsp dosyaları, servet'e çevrildiklerinde, burada o servlet'ler saklanır.

- conf: server.xml gibi config dosyalarının bulunduğu dizin

  - catalina.policy:  
    
    yetkilendirme tanımları bu dosyadadır. örnek:

    permission java.util.PropertyPermission "java.version", "read";

  - catalina.properties

    paket(java class paketleri) bazında ve jar bazında hangi projenin hangislerini okuyabileceğinin bilgisinin yer aldığı dosya.

  - server.xml

    sunucunun tüm ayarları buradan yapılabiliyor. detaylı anlatım aşağıda mevcut. bu dosyadan her war dosyasının içinde olamaz.

  - web.xml

    bu dosya her war içindeki web.xml parse edilmeden önce işletilir. daha sonra war içindeki web.xml okunur.

- webapps

  - docs: dökümantasyon içeren bir proje

  - examples: örnek jsp sayfaları ve kaynak kodlarını gösteren bir site

  - ROOT: contextpath'i olmayan bir proje. burada sadece tomcat'e hoşgeldiniz ve diğer apache.org projelerine linkler verilmiş bir site bulunmaktadır.

  - manager: tomcat üzerinde JVM memory detayları, yüklü olan projeleri context-path'leri gibi bir çok detay monitör edilebilir ve deploy/undeploy işlemleri yapılabilmesini sağlar.

  - host-manager: "Virtual Host" özelliğini monitör etmek için kullanılmaktadır. Virtual host birden fazla webapp klasörü yaratılabilmesini her her webapp içindeki projelerin birer domain-name'e karşılık gelmesini sağlamaktadır. Örneğin; google.com ve haberturk.com'a yapılan istekler aynı tomcat instance'ımıza gelecek ve fakat farklı webapp dizinlerindeki projelere yönlendirilebilir.

# Realm
realm türkçe kelime anlamı: diyar, krallık, alan, alem

A Realm is a "database" of usernames and passwords that identify valid users of a web application. this database includes also roles of users.

Tomcat içinde belirlediğimiz uygulamalar, güvenlik katmanlarında isterlerse bu kullanıcıları kullanabilirler. Böylece tüm uyguamalar için ortak kaynak belirlemiş oluruz.

Tomcat içinde gelen "manager" uygulaması, varsayılan olarak Realm'daki user'lara göre kullanıcıların login olup arayüzde işlem yapmasına izin vermektedir.

Realm kaynağı kulanmak için org.apache.catalina.Realm'dan türemiş bir implementasyona ihtiyacımız var. Tomcat içerisinde bunlar yüklü gelmektedir:

- JDBCRealm
  
JDBC jar'ı aracılığı ile veritabaına bağlanır. tabloları bizim oluşturmuş olmamız gereklidir.

/tomcat/conf/server.xml'de buna benzer bir tanımlamayı eklememiz gereklidir:

```xml
<Realm
    className="org.apache.catalina.realm.JDBCRealm"
    driverName="org.gjt.mm.mysql.Driver"
    connectionURL="jdbc:mysql://localhost/authority?user=dbuser&amp;password=dbpass"
    userTable="users" userNameCol="user_name" userCredCol="user_pass"
    userRoleTable="user_roles" roleNameCol="role_name"/>
```

veritabanında yapılan satır dğeişiklikleri tomcat'e anında yansımaktadır. fakat bir kullancının rolü değişirse, yada kullanıcı kaldırılırsa, kullanıcı logout olana kadar session'ı kullanabilecektir.

eğer servlet'lerde biri protected bir kaynağa erişmek isterse tomcat otomatik olarak org.apache.catalina.realm.JDBCRealm.authenticate() metodunu çağracaktır.

- DataSourceRealm

JNDI tanımı aracılığı ile veritabanına bağlanmaktadır.

```xml
<Realm
   className="org.apache.catalina.realm.DataSourceRealm"
   dataSourceName="jdbc/authority"
   userTable="users" userNameCol="user_name" userCredCol="user_pass"
   userRoleTable="user_roles" roleNameCol="role_name"/>
```

- JNDIRealm

JNDI tanımı aracılığı ile LDPA sunucusundan kullanıcı bilgilerini çeker.

- UserDatabaseRealm

JNDI racılığı ile XML'den kullanıcı bilgilerinini okunduğu realm'dır. varsayılan olarak XML dosyası /tomcat/conf/tomcat-users.xml'dir. örnek tomcat-users.xml:

```xml
<tomcat-users>
  <user name="tomcat" password="tomcat" roles="tomcat" />
  <user name="role1"  password="tomcat" roles="role1"  />
  <user name="both"   password="tomcat" roles="tomcat,role1" />
</tomcat-users>
```

- MemoryRealm

demo için geliştirilmiş bir implementasyondur. UserDatabaseRealm ile aynıdır (aynı xml'i okur), tek eksisi xml'de yapılan değişiklikler restart edilene kadar algılanmaz.

- JAASRealm

istek yapan kullanıcıları "Java Authentication & Authorization Service (yada JAAS)" ile onaylayan Realm'dır.

- CombinedRealm

birden fazla sub-real kullanabilmemize imkan tanıyan Realm'dır.

```xml
<Realm className="org.apache.catalina.realm.CombinedRealm" >
   
   <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
          resourceName="UserDatabase"/>
   
   <Realm className="org.apache.catalina.realm.DataSourceRealm"
          dataSourceName="jdbc/authority"
          userTable="users" userNameCol="user_name" userCredCol="user_pass"
          userRoleTable="user_roles" roleNameCol="role_name"/>
</Realm>
```

- LockOutRealm

CombinedRealm'dan türemiştir. kullanıcıları, fazla şifre denemesi isteği yaptıkları durumda onları engelleyebilmektedir.

# context path

comtext tomcat'te bir war dosyasına denk geliyor (server.xml'den de anlaşılacağı gibi).

comntext path; URL'de host ve port'tan sonra gelen web projesinin ilk seviye url'sidir.

Webapp altındaki her proje URL'den http://host/directoryName olarak çağrılırlar. tek istisna ROOT folder'ıdır. o direk http://host/ ile çağrılır. root içerisindeki bir web projesi, örnek /tomcat/webapps/ROOT/webapp1, http://host/webapp1 olarak çağrılır.

TOMCAT/WEBAPPS/demo#v1#myfeature/ projesi url'den bu şekilde erişilir: http://host/demo/v1/myfeature context.

\## (çift diez) örnek: foo##2.war sürüm olarak algılanmaktadır. sürüm numaraları url'ye (context path'e) yansıtılmaz.

/tomcat/conf/server.xml dosyası sadece tomcat restart edildiğinde işlenir, bu sebeple context'lerin server.xml'e yazılmaması önerilir.

# context.xml

bu dosya server.xml içindeki host elementinin içine yazılan kısmı taşıyabilir. bir sistemde birden fazla context belirteci olabilir. aynı sistemde birden fazla belirtec yazılmış olabilir. bunlar birbiri ile çakıştıklarında öncelik sırası parantez içerisinde verilmiştir (önceliği yüksek olan 1 numara):

- (1) /tomcat/conf/context.xml

- (1) tomcat/conf/server.xml içindeki context elementi

- (2) /tomcat/conf/[Engine_name]/[Host_name]/war-name.xml

- (2) /tomcat/conf/context.xml

- (3) war içindeki /META-INF/context.xml 

Tek istisna: tomcat/conf/server.xml içindeki context elementinde "override=true" yok ise; sistemin herhangi bir yerine yazdığımız context değeri algılanır.

# META-INF
Bu dizin war dosyalarının içindedir. war export edilirken, bu dizinin içindekiler tomcat/webapps/app1/ içerisine taşınır.

# server.xml

```xml
<Server>

  <Service name="MyService1">

    <Connector port="8443"/>

    <Connector port="8444"/>

    <Engine>

      <!-- default appBase: webapps -->
      <Host name="yourhostname" appBase="/webapps2"> 

        <!-- file1 path is: TOMCAT/webapps2/file1.war -->
        <Context path="/webapp1" docBase="file1.war" />

        <Context path="/webapp2"/>

      </Host>

    </Engine>

  </Service>

</Server>
```

- Görüldüğü üzere her bilgi __server__ içerisine yazılıyor. 

- örnekte 1 adet service içerisinde birden fazla connector (bunlar sadece port'u dinleyip yönlendirme yapmaya yarıyor), webapp1 vs webapp2'ye yönlendirme yapıyor.

- 2 ayrı port tek bir engin'e yönlenmiş durumda. webapp1 ve webapp1 bir adet __engine__'e bağlanmış durumdalar.

- __engine__ burada __Catalina__'ya denk geliyor. cataline ise bir __servlet container__'dır.

- Service, engine gibi gruplamalar log'lardan da takip edilebildiği için büyük kolaylık sağlamaktadır.

- 80'e gelen istekleri eğer client ssl bağlantısı kurma isteği yapıyorsa 443'e yönlendirebiliriz:

```xml
<Connector port="80" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="443" />
```

Bu connector tanımı yetmeyecektir. Çünkü son durumda 443'ün tanımı yoktur. 443'ün tanımını da yapmalıyız:

```xml
<Connector port="443"
           protocol="org.apache.coyote.http11.Http11Protocol"
           SSLEnabled="true" 
           scheme="https" 
           secure="true" 
           sslProtocol="TLS" 
           keystoreFile="/path/to/kestorefile" 
           keystorePass="my_keystore_password"/>
```

Bazı Connector parametreleri:

- address

  br sunucu birden fazla ip alıyor olabilir. bunlardan hangisinin o connector tarafından listening'de olacağını belirtir. default olarak tüm ip'ler dinlenir.

- maxPostSize

  post requestinin max boyutu. varsayılan 2 mb.

- scheme

  protokolün ismidir. url'deki değer değildir. default http.

- secure

  java kodumuzda request.isSecure() true/false dönüşü yapsın istiyorsak bu değeri true olarak set etmeliyiz.

- URIEncoding

  URL'nin encoding'idir. default ISO-8859-1.

- useBodyEncodingForURI

  eğer request'in header'ında "contentType" varsa, URIEncoding değerini hiçe sayar ve contentType'a göre url'yi parse eder. default değeri false.

Yukarıda protocol ile class ismi (implementasyon) belirtmezsek tomcat otomatik olarak bir implementasyon seçecektir. SSL standartır. bu sebeple bu implementasyonlar ssl protokolünün işleyişinde bir dğeişiklik yapmıyorlar, bunlar sadece configürasyonları farkettiriyor.

- JNDI

Direk \<server> içerisine bu tanımlama yapılabilir. bu şekilde tüm uygulamalar ismi ile JDNI'a erişebilir olur.

```xml
<GlobalNamingResources>
  <Resource name="UserDatabase" auth="Container"
            type="org.apache.catalina.UserDatabase"
            description="the user informations"
            factory="org.apache.catalina.users.MemoryUserDatabaseFactory"
            pathname="conf/tomcat-users.xml" />
</GlobalNamingResources>
```

Bu JNDI'ı kullanacak war dosyaları kendi web.xml'lerinde bunu belirtmek zorundalar:

```xml
<resource-ref>
    <description>
          database of tomcat
    </description>
	  <res-ref-name>
          UserDatabase
    </res-ref-name>
	  <res-type>
          org.apache.catalina.UserDatabase
    </res-type>
	  <res-auth>
          SERVLET
    </res-auth>
</resource-ref>
```

Yukarıdaki res-aut "CONTAINER" da olabilirdi.

- Environment variables

Direk \<server> içerisine bu tanımlama yapılabilir. bu şekilde tüm uygulamalar için environment variable atamış oluruz.

```xml
<Environment name="simpleValue" type="java.lang.Integer" value="30"/>
```

- catalina alternatives

catalina dışında bir container kullanmak istersek:

```xml
<Service name="MyService1" className="com.my.class.Name" >
```

Eğer className verilmezse default olarak org.apache.catalina.Service interface'si kullanılır.

- Listeners

Birçok event listener mevcut. Bunlar default olarak catalina'ya assign edilmiş durumdadır.

```xml
<Listener className="org.apache.catalina.startup.VersionLoggerListener" />
```

# shutdown

aşağıdaki satır jvm'in 8005'ten port dinlemesi ve SHUTDOWN string'i o porta yollandığı takdirde kendini kapatmasını belirtmektedir.

```xml
<Server port="8005" shutdown="SHUTDOWN">
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# jsp (yada JavaServer Pages)

jsp'de sayfalar, sunucu tarafta derlenip clienta gönderilir. her jsp sayfası, bir servlete çevrilir. servlet java sınıfıdır.

jsp dosyaları, java servlet sınıfına çevirirlirken:

jsp dosyası:

```xml
<html>
  <%
    double num = Math.random();
    if (num > 0.95) {
  %>
      <h2>You'll have a luck day!</h2><p>(<%= num %>)</p>
```

Java servlet sınıfı:

```java
import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;
public class ...Servlet extends HttpServlet {

  // Runs when the servlet is loaded onto the server.

  public void init() {

     ......

  }

  // Runs on a thread whenever there is HTTP GET request

  // Take 2 arguments, corresponding to HTTP request and response

  public void doGet(HttpServletRequest request, HttpServletResponse response)

        throws IOException, ServletException {

     // Set the MIME type for the response message

     response.setContentType("text/html");

     // Write to network

     PrintWriter out = response.getWriter();

     // Your servlet's logic here

     out.write("<html>\r\n  ");

     double num = Math.random();

     if (num > 0.95) {

        out.write("<h2>You will have a luck day!");

        ....

  }
```

# JSP ile single page application
JSP ile single page application yapısına uygun değildir. fakat eğer yapılmak isteniyor ise bir çok farklı yöntem uygulanabilir.

normalde jsp tüm sayfayı döner ve html'e o output yazılır. fakat biz eğer servlete isteği, js'te olduşturduğumuz manuel bir ajax işlemi ile yapar ve dönüş değerini manuel sayfanın bir kısmını güncelleyecek şekilde ayarlarsak o zaman single page applicaiton yapmış oluruz. aynı şey spring-mvc içinde geçerlidir.

# JSP debug
eclipce debug perspektifindeyken, variables view'ı jsp doayasında debug poıint koymamıza izin veriyor. runtime'da hangi değerlerin olduğunu da gösteriyor. bunun için eclipce'te WTP (yada web tools platform) plugin'i yüklü olmalıdır.

# JavaServer Pages Standard Tag Library (yada JSTL)
JSTL JavaEE'nin bir modülüdür.

jst jsp için core seviyede jsp tag'leri içerir. Gruplanmışlardır.

sadece ihtiyacımız olan grubu jsp dosyamıza import ederiz:

> <%@ taglib prefix = "c" uri = "http://java.sun.com/jsp/jstl/core" %>

- ## Core Tags
     ```jsp
     <c:set>
     <c:forEach>
     <c:when>
     ```

- ## Formatting tags
     ```jsp  
     <fmt:formatNumber>
     <fmt:parseDate>
     ```

- ## SQL tags
     SQL sorgusu çalıştırmayı ve bunu bir değere atayabilmemizi sağlar.
     ```jsp
     <sql:query>
     <sql:transaction >
     ```

- ## XML tags
     XML parse işlemleri yapmamızı sağlayan metodlar içerir.

- ## JSTL Functions
     Hazır temel fonksiyonlar içerir. Çoğu string işlemleridir.

# jsf (yada Java Server Faces)

jsf; jsp üzerine kurulu bir yapıdır. JSF'te, JSP gibi derleme ve servlet'in cevabı dönme işlemine ek olarak; altyapısı lifecycle'lar üzerinden hareket etmesini sağlamaktadır.

jsp'de her jsp dosyası bir class'a denk gelirken, jsf'te her jsf dosyası tek bir servlet üzerinden (faces servlet) dağıtılır.

jsf; MVC mimarisinde şu şekilde ayrılır:

- M: modellerimiz (veritabanı modleleri gibi)

- V: xhtml dosyalarımız

- C: FacesServlet ---> çünkü view'lardaki değerleri güncelleyecek olan kodlar, aynı zamanda modelleri güncelleyecek olan kodlar buradadır.

# primefaces vs icefaces vs richfaces vs myfaces

primefaces ve icefaces ve richfaces; jsf üzerine kuruludur. jsf tag'lerine ek kendi taglerini sunar.

myfaces; bir jsf implementasyonudur.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# front controller
genel bir server uygulama patternidir. bir server'a gelen istekleri yakalayan ilk sınıftır/servlettir. Bu servlet'in görevi ilgili yere bu isteği taşımaktadır.

# DispatcherServlet
Dispatch türkçe kelime anlamı: sevk etmek. yazılım dünyasında metoda/fonksiyona mesaj(parametre) yollama(sevk etme) anlamında kullanılır.

SpringMVC'de front controller'ın ismidir.

# FacesServlet
JSF için frontcontollerın ismidir.

# servlet
groupId: javax.servlet, artifactId: javax.servlet-api paketi servlet interface'lerini içeriyor. bu paket jdk içinde de geliyor. runtime sırasında javaee app server'ında bunu implemente eden sınıflar zaten çalışıyor. kod direk implementasyonları çağrıyor.

javax.servlet.Servlet interface'sinin birçok implementasyonu var: FacesServlet, GenericServlet, HttpServlet.

javax.servlet.Servlet şu metodları barındırıyor:
- destroy() servlet artık hiç kullanılmayacağı zaman çağrılıyor
-	init(ServletConfig config) uygulamamızın hayatı boyunca 1 kere çağrılıyor
- service(ServletRequest req, ServletResponse res) her request'te çağrılıyor
- getServletConfig() servlet ayarlarında verdiğimiz config'leri çekebilmemizi sağlıyor

1 servlet instance'ını birden fazla thread aynı anda kullanıyor olabilir. eğer hiçbir thread o instance'ı kullanmazsa o zaman servlet container bu servlet'i destroy edebilir. bu şekilde resource'ları boşaltmış olur. fakat hemen ardından gerekiyorsa yeni instance oluşturur. bu kararlar servlet container'a kalmıştır.

javax.servlet.http.HttpServlet ise javax.servlet.Servlet'ten extend eder ve bu metodları da içerir:
- doGet(HttpServletRequest req, HttpServletResponse resp)
- doHead(HttpServletRequest req, HttpServletResponse resp)
- doPost(HttpServletRequest req, HttpServletResponse resp)
- ...

# Context path
servlete erişmek için kullanılan URL'dir (domain hariç kısmı).

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# java'da assert kavramı

türkçe kelime anlamı: öne sürmek, idda etmek.

assert programlama dünyasında kullanılan genel bir mantıktır. assert java'da anahtar bir kelimedir. bu yüzden bir metod gibi kullanışı (syntax'ı) yoktur. java 1.4 ile gelmiştir. örnek kullanımı şu şekildedir: asssert( 3 == myNumber ); eger kod runtime sırasında bu satıra geldiyse ve condition false ise; satır AssertionError fırlatacaktır. eger condition true ise; kod hicbir sey yokmus gibi devam edecektir.

assert syntax'ı 2 şkilde kullanılır:

> assert ( 3 == myNumber) : "error: number is not 3" ;

ve

> assert ( 3 == myNumber);

condition sağlanmaz ise sağ taraftaki blok toString'e çevrilir ve AssertionError içerisine yazılır.

java da bir uygulama başlatırken assert keywordlu satırlar devre dışıdır. yani hiç çalıştırılmaz. bunu enable etmek için java uygulamasına en başta parametre geçmek gerekli. istege baglı olarak assertleri sadece belirli paketlerde enable yapabilir.

# assert kütüphaneleri

bazı kütüphaneler (junit gibi) assert metodları sunmaktadır. bu metodlar bildiğimiz java sınıflarıdır. özel bir syntax olma durumu söz konusu değillerdir.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# JUnit

test sınıfları verilecek aşağıdaki şekilde çağrılabilir:

```java
JUnitCore junit = new JUnitCore();
Result result = junit.run(testClasses);
```

Fakat eclipse'teki junit eklentisi @test anotation'ları içeren metodların sınıflarını otomatik olarak çağırmaktadır.

# junit 4 vs 5
5 inci sürüm ile büyük değişiklikler oldu.

## anotations
| purpose of anotation                                 | junit 4      | junit 5      |
|------------------------------------------------------|--------------|--------------|
| Declare a test method                                | @Test        | @Test        |
| Execute before all test methods in the current class | @BeforeClass | @BeforeAll   |
| Execute after all test methods in the current class  | @AfterClass  | @AfterAll    |
| Execute before each test method                      | @Before      | @BeforeEach  |
| Execute after each test method                       | @After       | @AfterEach   |
| Disable a test method / class                        | @Ignore      | @Disabled    |
| Test factory for dynamic tests                       | NA           | @TestFactory |
| Nested tests                                         | NA           | @Nested      |
| Tagging and filtering                                | @Category    | @Tag         |
| Register custom extensions                           | NA           | @ExtendWith  | 

# modülerlik
junit 5, 3 temel parçadan oluşuyor:
- JUnit Platform: API altyapısı
- JUnit Jupiter: API implementasyonları
- JUnit Vintage: JUnit 3 and JUnit 4 kodlaırnı çalıştırabilmek için gerekli modül

## min java
Junit 4 min java 5 isterken, junit 5, min java 8 istemektedir.

## test suite'ler

junit 4:

```java
import org.junit.runner.RunWith;
import org.junit.runners.Suite;
 
@RunWith(Suite.class)
@Suite.SuiteClasses({
        ExceptionTest.class,
        TimeoutTest.class
})
public class JUnit4Example
{
}
```

junit 5:

```java
import org.junit.platform.runner.JUnitPlatform;
import org.junit.platform.suite.api.SelectPackages;
import org.junit.runner.RunWith;
 
@RunWith(JUnitPlatform.class)
@SelectPackages("ExceptionTest.class", "TimeoutTest.class")
public class JUnit5Example
{
}
```

# junit 5 örnek kod

```java
junit 5 örnek test:

import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Disabled;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
 
import com.howtodoinjava.junit5.examples.Calculator;
 
public class AppTest {
     
    @BeforeAll
    static void setup(){
        System.out.println("@BeforeAll executed");
    }
     
    @BeforeEach
    void setupThis(){
        System.out.println("@BeforeEach executed");
    }
     
    @Tag("DEV")
    @Test
    void testCalcOne()
    {
        System.out.println("======TEST ONE EXECUTED=======");
        Assertions.assertEquals( 4 , Calculator.add(2, 2));
    }
     
    @Tag("PROD")
    @Disabled
    @Test
    void testCalcTwo()
    {
        System.out.println("======TEST TWO EXECUTED=======");
        Assertions.assertEquals( 6 , Calculator.add(2, 4));
    }
     
    @AfterEach
    void tearThis(){
        System.out.println("@AfterEach executed");
    }
     
    @AfterAll
    static void tear(){
        System.out.println("@AfterAll executed");
    }
}
```

```java
@RunWith(JUnitPlatform.class)
@SelectPackages("com.test.examples") //yada @SelectClasses( com.test.examples.ClassA.class )
@IncludePackages("com.test.example.packageB")
@ExcludeTags("PROD")
public class JUnit5TestSuiteExample
{
}
```

# JBehave

Java için BDD test sürecini işletmek için gerekli kütüphane. Temel olarak öncelikle; test için yapılacak işlemler story dosyalarına belirli formatlarda yazılıyor. Daha sonra Java içerisinde bu dosyalardaki her satıra (işleme) tekabül eden Java metodları yazılıyor. Örneğin;

story dosyasının bir satırında:

Sayfa "google.com" ‘dayken "lütfen aranacak kelimeyi yazın" yazacak.

java sınıfında:

```java
@When(Sayfa $URL ‘dayken $PRINTED_TEXT yazacak.)
public void checkWhatSiteHasPrinted(String URL, String PRINTED_TEXT){

     //do the test here
}
```

Daha sonra JBehave configürasyonları (çıktı rapor türü formatı gibi) yapılır. JBehave daha sonra story'leri run eder ve rapor çıktılarını istenilen dizine oluşturur.

JBehave kendi içinde JUnit'e depend eder. JBehave kendi içinde JUnit testlerini çağırır. Bu çağrılan junit-test story dosyalarını okur ve bunları işletir.

# testcontainers
birçok programlama dili için açık kaynaklı test kütüphanesidir. container'ları programatik ayağa kaldırmamızı sağlar. bu şekilde temel amaç test'lerden önce ilgili testin, container içinde koşmasını sağlamaktır.

isteğe bağlı; junit ile entegreli çalışabilir. bunun çin ekstra lib eklemek gerekli: group-id:org.testcontainers package-id:junit-jupiter.

```java
@Testcontainers
class MyTestcontainersTests {

     // will be shared between test methods
    @Container
    private static final MySQLContainer MY_SQL_CONTAINER = new MySQLContainer();

     // will be started before and stopped after each test method
    @Container
    private PostgreSQLContainer postgresqlContainer = new PostgreSQLContainer()
                                                              .withDatabaseName("foo")
                                                              .withUsername("foo")
                                                              .withPassword("secret");

    @Test
    void test() {
  
        String mySqlUrl = MySQLContainer.getJdbcUrl();

        assertTrue(MY_SQL_CONTAINER.isRunning());
        assertTrue(postgresqlContainer.isRunning());
    }
}
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# spring test

# @RunWith(SpringJUnit4ClassRunner.class)
JUnit spring'in özellikleri ile açılmalıdır. aksi durumda spring özellikleri çalışmaz. SpringRunner.class parametresi de SpringJUnit4ClassRunner'a referans ettiği için tamamiyle aynı işi görüyor.

# @ContextConfiguration(locations = {...})
ApplicationContext'in belirlenmesi için yapılıyor. parametre olarak xml dosyasının path'i verilebilir, yada @Configuration sınıfı/sınıfları verilebilir.

# @SpringBootTest
Eğer Junt testi içinde @Configuration kullanılmamışsa, "main (test olmayan paketler)" arasında @SpringBootConfiguration arar ve spring context'i ayağa kaldırır. böylece bean'ler test süresince kullanılabilir olur.

not: @SpringBootApplication içerisinde zaten @EnableAutoConfiguration vardır.

@SpringBootTest application'a argüman geçebilmemizi sağlamaktadır:

```java
@SpringBootTest(args = "--app.test=one")
```

@SpringBootTest, webEnvironment parametresi alabilir:

```java
@SpringBootTest(webEnvironment.MOCK)
```

webEnvironment aşağıdaki değerleri sunmaktadır:

- # MOCK (Default)
    ApplicationContext'i kaldırır fakat mock bir web environment'i oluşturur. yani gerçek bir server ayağa kalkmaz. Mock controller'lar olacağı için @AutoConfigureMockMvc (reactive olamayan server'lara bağlanmak için) yada @AutoConfigureWebTestClient (reactive olan server'lara bağlanmak için) gibi anotation'larla kullanılması önerilir.

    eğer claspath'te web dependency'leri yok ise; normal ApplicationContext'i init eder.

- # RANDOM_PORT
    Gerçek server'ı uygulamayı ayağa kaldırır. Rastegele bir port ile dışarıya açar.

- # DEFINED_PORT
    Gerçek server'ı uygulamayı ayağa kaldırır. port default port yada application.yml'de verilen porttur.

- # NONE
    ApplicationContext'i hiç web ortamlarını ignore ederek ayağa kaldırır.

If your test is @Transactional, it rolls back the transaction at the end of each test method by default. However, if you are using RANDOM_PORT or DEFINED_PORT which provides a real servlet environment, the HTTP client and server run in separate threads and, for that reason, they are separate transactions. Any transaction initiated on the server does not roll back in this case. 

# @WebMvcTest
@WebMvcTest aşağıdaki iki anotation'u devreye sokar: 

  - __@AutoConfigureWebMvc__

    sadece @Controller'ları ayağa kaldıracak şekilde spring context'i ayağa kaldırır. bu şekilde testlerin başlama hızı daha yüksektir. çünkü sistemin sadece bir kısmı ayağa kalkar.

  - __@AutoConfigureMockMvc__

    MockMvc bean'ini inject edebilmemiz sağlar. web slicing testingde server ayaa kalkmaz. dolayısı ile controller'lar normal-standart yntemlerle çağrılamaz. ancak bu işi "MockMvc" objesi yapabilir. MockMvc artık client api'mizdir.

Yukarıdaki iki anotation bilgilerinden yola çıkarak şunu söyleyebiliriz: eğer testlerimize @AutoConfigureWebMvc ve @SpringBootTest yazarsak (@AutoConfigureWebMvc yazılmamışsa) server full ayağa kalkar ve yine testlerimiz mockmvc ile yapabiliriz.

sadece 1 adet controller'ı ayağa kaldırmak için:

```java
@WebMvcTest(HomeController.class)
```

@WebMvcTest test örneği:

```java
@RunWith(SpringRunner.class)
@WebMvcTest(UserVehicleController.class)
public class UserVehicleControllerTests {

    @Autowired
    private MockMvc mvc;

    @MockBean // package: org.springframework.boot.test.mock.mockito
    private UserVehicleService userVehicleService;

    @Test
    public void testExample() throws Exception {
        given(this.userVehicleService.getVehicleDetails("sboot"))
                .willReturn(new VehicleDetails("Honda", "Civic"));
        this.mvc.perform(get("/sboot/vehicle").accept(MediaType.TEXT_PLAIN))
                .andExpect(status().isOk()).andExpect(content().string("Honda Civic"));
    }
}
```

bu tarz testlere "__slicing test__ (slice kelime anlamı: dilim)" denir. çünkü sadece sistemin bir kısmı kaldırırılır ve o kısımlar test edilir. bu test tipi, unit test'in bir türevidir.

slicing test için spring boot'ta bu anotation'lar sunulmaktadır:

__@WebMvcTest__ - for testing the controller layer
__@JsonTest__ - for testing the JSON marshalling and unmarshalling
__@DataJpaTest__ - for testing the repository layer
__@RestClientTests__ - for testing REST clients

# @DataJpaTest
full auto-configuration yapmayıp, sadece JPA ortamını ayağa kaldırıyor.

her test metodu sonrası işlemler geri alınır.

repo testleri entity ilişkilerinin doğru kurulup kurulmadığının ve özel yazılan query'lerin düzgün çalışıp çalışmadığını görebilmek için yapılır.

```java
@RunWith(SpringRunner.class)
@DataJpaTest
public class CityRepositoryTest {

    @Autowired
    private CityRepository repository;

    @Test
    public void should_find_all_customers() {

        Iterable<City> cities = repository.findAll();

        assertThat(cities).hasSize(10);
    }
}
```

@DataJpaTest, __TestEntityManager__ autowired edilebilmesini sağlar. TestEntityManager, EntityManager'i wrap etmez. ona alternatiftir. test için uygun olan metodları barındırır ve bazı EntityManager metodlarını barındırmaz.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# mockito
java kitaplığıdır
- metodlardan istediğimiz değerler dönmesini sağlamaktadır
- bunun yanında bir metoda kaç kez girildiğini tespit edebilmekte
- bir metod hangi parametre ile çağrıldığını görebilmekteyiz

# @Mock
mockito anotation'udur. İlgili nesnenin instance'sını oluşturmaz. onun yerine mock bir obje oluşturur.

asagidaki kullanım:

```java
@Mock
MyService myservice;
```

Bununla ayni işi görmektedir:

```java
MyService myservice = Mockito.mock(MyService.class);
```

Eğer anotation kullanılırsa tüm testlerden önce, anotation'un bulunduğu sınıfta asagidaki komutun bir kerelik çalıştırılması şarttır:

```java
MockitoAnnotations.initMocks(this);
```

Mockito, sadece mock olan instance'ların return değerlerini değiştirebilir. yani "new Person()" diyerek oluşturduğumuz bir sınıfın "run()" metodunu çağırdığımızda return değerini değiştiremez.

# @InjectMocks
İlgili objeyi oluşturur. fakat o objenin içinde başka sınıflara referans varsa o sınıfları mock olarak oluşturur.

Test edeceğimiz sınıfı @InjectMocks ile instance'ını oluştururuz. fakat test edeceğimiz sınıfın içindeki dependency'leri @Mock ile oluştururuz. örnek:

```java
public class ApplicationTest 
{
    @InjectMocks
    MyService myService;

    // "aClassInsideMyService" MyService içerisinde kullanılan bir sınıfı olsun.
    @Mock
    AClassInsideMyService aClassInsideMyService;
     
    @Mock
    AnotherClassInsideMyService anotherClassInsideMyService;
     
    @Test
    public void validateTest()
    {
        boolean saved = myService.save("hello");
        assertEquals(true, saved);
    }
}
```

# org.springframework.boot.test.mock.mockito.MockBean
spring içinde gelen bir anotation'dur. sadece mockito kütüphanesi için geliştirilmiştir. mock'lamak istediğimiz componentler bu anotasyonla inject etmeliyiz. spring bean'i olduğu için bu anotation şarttır. eğer mockito içindeki @Mock anotation'ını kullanırsak normal bir class olarak instance yaratmış oluruz.

MockBean'de bir bean instance'ı singleton ise; o zaman o bean'i mock edersek, tüm yazılım sürecinde o bean'i mock etmiş oluruz. yani junit test case'imizde o bean'i çağırmadıysak bile, onu çağıracak olan farklı thread'de bu durumdan etkilenmiş olacaktır. 

# @ExtendWith(MockitoExtension.class)
MockitoJUnitRunner ile aynı görevi görmektedir.

Junit 5 ile artık junit'e extension yazılabiliyor. Mockito'nun MockitoExtension'u bir junit 5 extension'udur. onu devreye almak için aşağıdaki gibi anotation'a eklemek gerekiyor:

```java
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class MyServiceTest {
  // tests
}
```

# @Rule
JUnit 5 ile gelen bir özelliktir. Extension gibi rule'larda junit akışına özellik katar. MockitoExtension kullanmak istemediğimizde, onun yerine aşağıdaki rule'u aktif etmemiz yeterli olacaktır:

```java
import org.junit.Rule;
import org.mockito.junit.MockitoJUnit;
import org.mockito.junit.MockitoRule;
 
public class ExampleTest {
 
    @Rule
    public MockitoRule rule = MockitoJUnit.rule();
 
    // tests
}
```

# @MockitoJUnitRunner
JUnit'in "runner" özeliği var. runner'lar junit test akışını değiştirebilirler ve junite özellik ekleyebilirler. birçok çeşit runner var. MockitoJUnitRunner bunlardan bir tanesi. MockitoJUnitRunner, @Mock gibi anotation'ların initialize edilmesini sağlıyor. bunu enable etmek için:

```java
import org.mockito.junit.MockitoJUnitRunner;
 
@RunWith(MockitoJUnitRunner.class)
public class ExampleTest {
    // tests
}
```

Mockito 2.2.20 öncesi "org.mockito.runners.MockitoJUnitRunner" sınıfı kullanılırken, bu sınıf artık "org.mockito.junit.MockitoJUnitRunner" olarak belirlendi. junit için geliştirilen sınıflar "org.mockito.junit.*" altına taşındı.

# stubbing

```java
public Student {

   public Solution solveProblem( Problem problem, int maxTime ){

   }
}
```

olsun. asagidaki kod ile fake data döndürebiliriz:

```java
Solution fakeSolution = new Solution();

fakeSolution.setSolution("Fake solution");

Mockito.when( student.solveProblem( Mockito.any(Problem.class), Mockito.anyInt() ) ).thenReturn(fakeSolution);
```

Yukarıda "student" bir mock instance olmalıdır. yani "new Student()" ile yaratılmış bir sınıf olamaz. mock(Student.class) olmalıdır.

Mockito bir proxy instance'ı yaratıyor. örnek olarak yukarıdaki student'i mock'layalım:

> Student student1 = mock(Student.class);

student1 artık bir mock sınıftır. student1 bir proxy'dir. artık bu sınıftan bir metod çağrıldığında öncesinde ve sonrasında input ve output'unu manipüle edebilecektir.

Mock'lama kütüphaneleri genel olarak 2'ye ayrılıyor:
- proxy based (example libs: mockito, EasyMock, jMock)
- bytecode manipulation (example libs: PowerMock)

# ArgumentCaptor
bir metoda geçilmiş parametreleri yakalayabilmemizi saglar. örnek:

```java
ArgumentCaptor<Problem> argumentCaptor = ArgumentCaptor.forClass(Problem.class);

Mockito.verify(student).solveProblem(argumentCaptor.capture());

//here do your tests which invokes solveProblem method

//end of the test check the variables passed to solveProblem method

if( argumentCaptor.getValue().getProblemDetails() == "2 + 2 = ?" ){

     //test success

} else {

    throw Exception("Test failed");
}
```

# verify
Asagidaki kod solve problem metodunun 1 kere çağrılıp çağrılmadığını kontrol ediyor.

```java
Mockito.verify(student, new Mockito.Times(1)).solveProblem( any(Problem.class), anyInt());
```

# answer
.thanReturn metodu sürekli aynı metodu döndürüyor. eğerki gönderdiğimiz nesnenin içindeki elemenalara göre  dönüşler almak istiyorsak aşağıdaki gibi kod yazmalıyız:

```java
Answer<Solution> answer = new Answer<Solution>() {

   @Override
   public Solution answer(InvocationOnMock invocation) {

    Problem arg = invocation.getArgumentAt(0, Problem.class);

    if (arg.getQuestion().stringValue() == "3+4=?") {

         Solution solution = new Solution();

         solution.setErrorCode(0);

         solution.setMessage("7");

         return solution;

    } else if (arg.getQuestion().stringValue() == "Steve Jobs kimdir?") {

     Solution solution = new Solution();
     solution.setErrorCode(1);
     solution.setMessage("Matematik haricinde soruya cevap verilemez.");
     return solution;
    }
   }
  };

Mockito.when(student.solveProblem(any(Problem.class), anyInt())).thenAnswer(answer);
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# AWT (Abstract Windows Toolkit) vs SWING

Java GUI kütüphanesi. hangi platformadaysanız, o platformun doğal kodundan (native code) GUI türetir. Java her yerde çalışır mantığı sebebi ile, AWT sadece tüm platformların ortam özelliklerini kullanmaktadır. Tüm platformlarda ortak GUI objeleri ve özellikleri az olduğundan, AWT çok sınırlı kalmaktadır.

AWT her platformda  göründüğünden, "Look And Feel" aynı olmamaktadır.

SWING ise kendi GUI objeleri içermektedir ve tüm platfrmlarda aynı görünüme ve davranışlara sahiptir.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# rest (yada Representational state transfer) vs restful

__rest__ yazılım haberleşme tekniği/mimarisidir. "__restful__" ise, 'sıfat' olarak türemiş bir eklimedir ve bu REST'i kullanan sistemler (uygulamalar) için kullanılır.

rest bir protokol değildir. rest bir protokol mimarisidir. temelde şu kuralların olmasına dayanır:
- sistem, client'ın herhangi bir platformda çalışabilecek şekilde tasarlanmış olmalıdır
- request'lerde sadece client taraf state(context) ve session bilgisi tutmalıdır. sunucuda tutulmaz.
- Uniform interface: her resource için CRUD (Create, update, delete...) metodları hazır olmalıdır
- cache; client yada server'da olabilir. ve mümkün oldukça tercih edilmelidir. 
- layered system: sunucularımız birçok katmandan meydana geliyor olabilir. load balancer, proxy, cache, ayrı microservisler... bunlar client tarafından bilinmemesi gereklidir. client tek bir endpoint'den tüm ihtiyaçlarını giderebilmelidir.

Eğer request/response'larımız bu kurallara uymuyorsa, sistem __restless__'dır.

Rest yapısı HTTP ile ortaya atılmıştır ve HTTP ile çok uyumludur. bu sebeple piyasada Rest kelimesi denilince herkesin aklına sadece HTTP gelmektedir. oysa bu doğru değildir.

REST mimarisinde geçen terimler ve buna denk gelen karşılıkları:

| Data Element            | Modern Web Examples                                     |
|-------------------------|---------------------------------------------------------|
| resource                | the intended conceptual target of a hypertext reference |
| resource identifier     | URL, URN                                                |
| representation          | HTML document, JPEG image                               |
| representation metadata | media type, last-modified time                          |
| resource metadata       | source link, alternates, vary                           |
| control data            | if-modified-since, cache-control                        |

# REST vs SOAP (yada Simple Object Access Protocol)

SOAP xml tabanlı bir istek atıyormuş gibi görünebilir, fakat aslında bir HTTP POST isteğidir. Gönderilen XML post isteğinin data bloğunda göderilir. SOAP bir protokoldür oysa REST protokollerde kullanılan bir tekniktir. Bu sebeple karşılaştırılması doru değildir. Fakat piyasada REST, sadece HTTP olarak algılandığı için bunun karşılaştırılması yapılıyor.

İstenirse JWT'nin tuttuğu bilgiler SOAP isteğinde tutulur ve SOAP mimarisi ile Restful bir sistem yapılır. Fakat piyasada kimse bunu tercih etmez çünkü best bractice olarak zaten rest sisteme HTTP requstleri çok uygundur.

SOAP mesajı POST Http'dir. payload bloğunda xml vardır. bu xml'in root'undaki element "Envelope"'tur. içinde "header" ve "body" vardır.

# SOA (yada Service-oriented architecture)

REST ve SOAP kümesini içine alır. RPC, SOA kümesi içinde değildir.

# raw of http request
bir http isteği TCP katmanında incelendiğinde şu şekilde görünmektedir:

```
GET /wx/in/kanpur/wx.php HTTP/1.0
Host: cdn.sstatic.net
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: keep-alive

```

Görüldüğü gibi özel bir formatı yoktur. Her bilgi farklı satırda yollanır. En sonda bilginin bittiğine dair fazladan bir satır sonu da olmalıdır.

örneğin nc (netcat) komutu ile tcp üzerinden raw isteği yollayabilir:

> nc www.google.com 80

komut satırı input bekleyecektir. aşağıdakiler girildiğinde karşı tarafa bilgi yollanacaktır:

```
GET /index HTTP/1.0
Accept: text/html
```

İki kez enter tuşuna basılıp satır sonu eklendiğinde; response komut satırında ekrana basılacaktır:

```
HTTP/1.0 404 Not Found
Content-Type: text/html; charset=UTF-8
Referrer-Policy: no-referrer
Content-Length: 1566
Date: Sat, 23 Mar 2019 10:11:18 GMT

<!DOCTYPE html>
<html lang=en>
  <meta charset=utf-8>
  <meta name=viewport content="initial-scale=1, minimum-scale=1, width=device-width">
  <title>Error 404 (Not Found)!!1</title>
  <style>
```

# Richardson Maturity Model

tam anlamıyla restful bir servis yazıyorsak 3 no'lu level'dayızdır. rest mimarisini kötü kurguladıysak 0 nolu durumdayızdır.

- Level-0 - Swamp of POX

  rest'i sadece data taşımak için kullanıyoruz. genelde SOAP, RPC benzeri altyapılar kullanıyoruz.

- Level-1 - Resources

  istek yaptığım endpoint'ler resource bazlı değişiyor ise bu leveldayızdır.

- Level-2 - HTTP Verbs

  resourcelerime erişirken post, get, delete gibi  istekleri aynı endpoint için kullanabiliyorsam bu leveldayızdır.

- Level-3 - HyperMedia Controls

  servisin dönüş değerleri; client'ın tekrardan yapacağı isteklerin URL'lerini içeriyor ise son level'dayızdır. buradaki amaç client tarafta daha az bilgi tutmaktır. örnek: doktor randevu boş saatleri servisten çekildi. dönüş değerinin içinde dolu saatlerin randevu almak için gerekli URL'si de olmalıdır.

level-3 response örneği:

```json
{
    "name": "Alice",
    "links": [ 
          {
            "rel": "self",

            "href": "http://localhost:8080/customer/1"
          }, {
            "rel": "customer.search",

            "href": "http://localhost:8080/customer/search"
          } ]
}
```
- "rel" relation kelimesinin kısaltmasıdır.
- "self" dönen bu response için hangi kaynağın çağrılması (request) gerektiğini belirtir.
- bu tarz response veren sistemlere "hypermedia-driven system" da adlandırılır.
- farklı bir örnek:
  mesaj'ı döndüren bir servisimiz olsun. X id'li mesajı çektik bize şöyle bir cevap dönebilir:

```json
{
    "text": "how are you",
    "links": [ 
          {
            "rel": "self",

            "href": "http://localhost:8080/message/x"
          }, {
            "rel": "delete",

            "href": "http://localhost:8080/message/delete/x"
          } , {
            "rel": "favorites",

            "href": "http://localhost:8080/message/favorites/x"
            "methods": ["put", "delete"]
          } ]
}
```
HATEOS için birçok implementasyon mevcut. Bu implementasyonlar bu dosyadaki birçok standardı belileyebiliyor. örnek:
- links, href, rel yerine ne yazılması gerektiği
- links, href, rel değerlerinin ne ve hangi formatta olacağı
- links, href, rel gibi hangi değerlerin olacağı

Yukarıdaki örnekte mesajımızı silme butonunu, yada favorilere ekleyip ekleme seçeneklerini sunup sunmayacağımıza client tarafta dinamik olarak karar veririz.

# Hypermedia As The Engine Of Application State (yada HATEOAS)

bu "Richardson Maturity Model" level-3 için kullanılan bir terimdir. client, dinamik olarak sayfanın state'ini (kısmen yada tamamını) network'ten gelen cevaplara/datalara göre oluşturmaktadır. bu da level-3 gibi bir sistemde en optimum yapılabilecektir.

# jax-ws

javaEE de SOAP web servisi spesifikasyonudur.

# jax-rs

javaEE'nin rest spesifikasyonudur.

# jax-ws vs jax-rs implementasyonları

javaEE'de default implementasyon kavramı yoktur. hangi suncuya atarsak jboss, tomcat kendi implementasonunu sunar. farklı implemnetason istersek biz implementasyon jar'larını yükleyip configürasyon yapmak gerekecektir.

| name       | jax-ws | jax-rs |
|------------|--------|--------|
| Apache CXF | yes    | yes    |
| axis       | yes    | no     |
| axis2      | yes    | yes    |
| Jersey     | no     | yes    |
| RESTEasy   | no     | yes    |

# wsimport

JDK içinde yüklü gelen komut satırı uygulaması. WSDL ile, SOAP web service client Java kodu generate etmemize yarıyor.

# eclipse GUI client generator

elipse IDE'de herhangi bir projeye sağ tıklayıp, New --> Web Service CLient --> diyip wsdl'iveriyoruz bize java kodu üretiyor. burada eclipse IDE arkaplanda axis'in generator'ını kullanıyor.

# axis vs axis2

axis'te büyük değişiklikler yapıldı ve yeni proje olarak fork edildi. artık rest'te destekliyor. "axis2" projenin yeni adıdır. axis2'nin yanına sürüm numarasını gelecektir.

# apache http client

sadece http client tarafını sunan java kütüphanesidir.

# JAXB (Java Architecture for XML Binding)

- Java içinde gelen XML kütüphanesidir.
- javax.xml.bind.* paketleri kümesini kapsar.
- Java 9 ile debrecated olarak işaretlendi, 10 ile tamamen kaldırıldı.
- marshalling ve unmarshalling yapar ve verilen xml şemasına göre Java objeleri oluşturur.
- marshalling işlemi sonrası bir xml oluşur. bu xml hem kolay okunabilirliği de sağlar, aynı zamanda üzerinde un-marshalling yapmadan önce değişiklikler de yapılmasını kolaylaştırır. oysa serializable'da bir nesne dosyaya dönüştürülmüşse artık değişiklik mümkün diildir.

# Jackson

asıl öncelikleri JSON olan, fakat ekstradan XML gibi birçok formatı ayrıştıran, üreten, işleyen bir Java Kütüphanesidir.

2.x'ten eski sürümler org.codehaus.# paketi altında dağıtılıyordu, 2.x sürümü ise com.fasterxml.* altında dağıtılıyor.

```java
@JsonPropertyOrder({"age", "id", "name"})
public class Person {
  
    @JsonProperty("_id")
    private String id;

    private String name;

    private int age;

    @JsonIgnore
    private String note;
}
```

Jackson 3 farklı alt projeden oluşuyor:

- Streaming (jackson-core)

  Burada xml/json derleme gibi işlemleri yapan core kodlar mevcut. alttaki tüm altprojeler bu projeye depend eder.

- Annotations (jackson-annotations) 

  sadece anotation'lar ayrı olarak bu projede barındırılıyor. anotation kullanmak istemeyenler bu projeyi classpath'te bulundurmak zorunda diil.

- Databind (jackson-databind)

  ObjectMapper/XmlMapper gibi sınıfıların bulunduğu paket.

Yukarıdaki tüm dependency'leri tek bir maven paketinden bulabiliriz:

```xml
<dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-xml</artifactId>
    <version>2.10.0</version> 
</dependency>
```

Yukarıdaki maven dependency'si sadece xml formatı için objectmapper türevini içerir. "jackson-dataformat-xml" yerine buradaki formatlardan birini tercih edebiliriz: https://github.com/FasterXML/jackson-dataformats-binary (archive date: 25/10/2019)

## ObjectMapper vs XmlMapper
ObjectMapper, json işleme metodlarının bulunduğu API. XmlMapper ise projeye sonradna eklendi. XmlMapper, ObjectMapper'dan türemiş bir sınıf. tüm metodları override edilmiş ve sadece xml işleme için kullanılmak için tasarlanmıştır.

## Modules
Jackson 3th parti module altyapısını destekler. moduller araya girerek birçok ek özellik katabilir. modülleri jackson'a register etmemiz gereklidir:

```java
ModuleX moduleX = new ModuleX();
objectMapper.registerModule(moduleX);
```

Eğer manuel registration yapmaz isek bu metod ile claspath'te bulunan tüm metodları oto register yapabiliriz:

```java
ObjectMapper.findAndRegisterModules();
```

Jackson wiki'lerinde "Core modules" kısmında, yukarıda belirttiğimiz 3 proje gösteriliyor: Streaming, Annotations, Databind. fakat bunlar birer modül gibi register etmek gerekmiyor.

Bazı modüller aşağıdaki repo'larda geliştiriliyor. her repo'nun içinde birden fazla modüle mevcut.
- https://github.com/FasterXML/jackson-modules-base (archive date: 25/10/2019)
- https://github.com/FasterXML/jackson-modules-java8 (archive date: 25/10/2019)

Bazı modüller:

- ## Jackson Module JAXB Annotations
  JAXB, Jackson'a alternatiftir. önceden jaxb kullanıyorsak, JAXB'nin anotation'larını bazı java bean'lerimize atmış olabiliriz. bunları Jackson'ın da algılamasını istiyorsan bu projeden yararlanmamız gerekir.

  ```xml
  <dependency>
    <groupId>com.fasterxml.jackson.module</groupId>
    <artifactId>jackson-module-jaxb-annotations</artifactId>
    <version>2.4.0</version>
  </dependency>
  ```

- ## jackson-datatype-jdk8
  jdk 8 ile gelen optional değerler için support sağlıyor. örnek: serialize edeceğimiz sınıfımızda bu değere destek verebiliriz:

  ```java
  class Person {
      private final String name;
      private final Optional<String> email;
  ```

- ## jackson-datatype-jsr310
  Java 8 ile gelen java.time.* kütüphanesinin serileştirmesine yardımcı olur.
 
  ```xml
  <dependency>
      <groupId>com.fasterxml.jackson.datatype</groupId>
      <artifactId>jackson-datatype-jsr310</artifactId>
  </dependency>
  ```

# gson

java için java objelerini json'a çevirip tekrar java objesine çevirme kütüphanesidir.

# RPC (yada Remote procedure call)

Uzak makinede yada aynı makinede farklı processler arasında metod çağırıp işletme mekanizmasıdır. bu bir consept'tir. protokol dğeildir. herkes uzaktaki bir metodu çağrıp dönüş alabilir. genelde programlama dilleri kendi protokollerini/standartlarını kullanıyor. bu sebeple cros-language değilledir.

# Remote Method Invocation (yada RMI)

Java'nın kullandığı RPC'dir.

# XML-RPC

bir çeşit rpc standardıdır.

# wsdl içinde geçen terimler

wsdl 2.0 sürümü http isteklerini kısmen desteklemektedir.

aşağıdaki her tanımın "name" isminde property'si mutlaka olmalıdır.

tüm wsdl xml'inin root elementi < definition > etiketindedir.

| 1.1       | 2.0       | aciklama                                                                                                                                       |
|-----------|-----------|------------------------------------------------------------------------------------------------------------------------------------------------|
| port      | Endpoint  | gidilecek olan isteğin URL'sidir (path ile bilikte)                                                                                            |
| service   | service   | her endpointi birer binding'le eşleştiren mappingdir. örnek: X servisi A binding'i ile eşleşir.                                                |
| binding   | binding   | operation'lar kümesidir. + istek hakkında meta bilgiler içerir                                                                                 |
| portType  | Interface | operation'lar kümesidir. + her operation içinde gidip gelecek olan dto'ları da tanımlamaktadır. + error durumunda dönecek dto tanımı burdadır. |
| operation | operation | her metod bir operation'dur.                                                                                                                   |
| message   | (yok)     | bir request yada response'un tüm dto'dur. her message bir type kümesidir. message etiketi içinde her type "part" isimli etiket ile tanımlanır. |
| types     | types     | her dto bir type'tır. type tüm request yada response olmak zorunda diildir. bir kısmı da olabilir.                                             |

# Subset WSDL (yada SWSDL)

sadece bir metod kümesini kapsar. swsdl alınıp client üretilirse, swdl içindeki metodlar çağrılabilir.

# marshalling

marshalling işlemi bir nesnenin farklı bir makineye parametre olarak geçilebilmesi için byte dizisi olarak (dosyaya yazılabilir halde oluyor doğal olarak) taşınması işlemidir. Kelime ve temel bilgisayar biliminde aslında "serialize" ile aynı şeye denk gelmektedir. fakat java dünyasında bu iki işlem birbirinden farklıdır.

# java dünyasında marshalling

java dünyasında marshalling işlemi sonucu üretilen çıktıda java sınıfının içindeki codebase + set edilmiş değeler tutulmaktadır. oysa serialize işleminde sadece sınıfın set edilmiş değerleri tutulmaktadır. marshalling işlemi java standratlarında belirtilmiştir. Sadece RMI işleri için kullanılır. 

# codebase

- RMI uzaktan java metodu çağırır. dönüşünde ise bir sınıf alır. dönüşte alacağı sınıfı client bilmeyebilir. client sadece o sınıfın interfacesini bilir. fakat dönecek implementasyonu bilemez. böyle durumlarda RMI çağırdığı metoddan dönen codebase bilgisine bakar. codebase sınıfın id'sini barındırır. eğer aynı id'de bir sınıf localde varsa; client localdeki sınıfı kullanır. fakat eğer locaklde yoksa; uzakdan o sınıfı download eder.

- codebase kelimesi yazılım dünyasında soruce-code'un tümüne verilen isimdir. genelde generated-file'ları barındırmaz. sadece insanların yazdığı kodların tümüne denir.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Nesne eşitliği

# Nesne eşitliğini bulma

Java'da == ifadesi iki nesnenin referasnlarının aynı olup olmadığına bakar. eğer karşılaştırılan nesneler primitive ise (int, boolean...), sadece değerleri karşılaştırılır.

Java'da her nesne, object sınıfından türemiştir ve equals(Object) metodu içerir. BU metod ile iki obje karşılaştırılabilir. BU karşılaştırmada metodunu yazılımcı override ettiği için istediğini döner. fakat asıl yapılması (beklenen) dönüş; sınıfın içindeki unique değerlerin kontrol edilerek dönüş almaktır. Tabi sadece unique değerler karşılaştırılarak olmaz, zira karşılaştırılan sınıflarda aynı olmalıdır.

Eğer equals metodu override eilmez ise; oject sınıfındaki metoda göre refernasları aynı olan sınfılar için true dönüşü alırız. Yani; override edilmezse == 'e denk geliyor.

Equals ile benzer mantıkta olan hashCode() bir integer ile unique bir değer döndürmeli. Bu değer equals ile aynı görevi görmelidir. Fakat hastable gibi tablolarda, bir sınıfın hash değerini saklamak gerekir diye bu metod hazır olmalıdır.

new Integer(5) = new Integer(5); --> false vermektedir. refernasları yeni obje oldugu icin farklı.

Integer.valueOf(5) == Integer.valueOf(5) --> valueOf metodu Integer objesi dondurmektedir. normalde false olması beklenmektedir. fakat true vermektedir. çünkü; Integer sınıfı kendi icinde initialize olurken static olarak 1'den 256'ya kadar olan sayılar için birer Integer objesi saklamaktadır. bunlar cunku genelde cok kullanılan sayılardır. valueOf metodu bu sayılar haricinde "new Integer()" calıştırıyor. fakat bu sayılardan ise hızlı olsun diye bunlardan donduruyor. bazı jvm'ler 256'dan daha fazla saklamaktadır.

java'da aynı string'ler aynı değeri göstermektedir. bu sebeple == equals yerine kullanılmaktadır. fakat new String("text") her zaman yeni bir referansla obje yaratmaktadır. bu sebeple bunlarda == kullanılamaz. new String("text").intern() metodu varolan jvm 'deki stringlere referans etmemizi sağlıyor. bu şekilde bellekten tasarruf etmiş oluyoruz.

# object (yada nesne yada tr:obje) vs instance
instance, bir class'tan türetilmiş, bellkete ayrı bir referansı olan yapıdır. object ise instance'ın tipidir. yani; int bir primitive iken, User sınıfından türemiş, "ahmet" instance'ı bir objedir.

bu başlıkta ve bu notlarda, obje ve nesne terimlerini kullanırken doğru olmasına hiç dikkat edilmedi. ikiside birbiri yerine kullanılmıştır.

# java stack yapısı
stack; sadece thread'e bağlı değerleri tutan veri yapısıdır. her thread için ayrı stack vardır. main thread'de buraya dahildir. primitive değerler ve objelerin referansları, stack deposunda tutulur. fakat objeler heap'te tutulur.

thread'de (stack'te) her metod, kendi içinde ona pass edilen tüm verileride tutuyor. yani stack içinde her metod için ayrı bir bölge var. bu sebeple;

```java
metod1(){

     User user1 = new User("ahmet");

     metod2(user1);

     print( user1.name ); --> burasi ekrana ahmet basacaktır.

}

metod2(User user){

    // burada; metod2 bölgemizde; sadece user diye bir variable var.
    
    user = new User("Ayse");  //bu satırda user variable'nin üzerine yeni bir variable atamış oluyoruz. sadece metod2 bölgesinde bir değişiklik yaptık. eski instance yaşamaya devam ediyor.

}
```

# call by value (yada pass by value) vs call by reference (yada pass by reference)
genel programlama dillerinde kullanılan terimlerdir.

Java primitive ve objeler için (yani her zaman) için call-by-value yöntemini kullanır. burada bir konuyu netleştirelim: java'da objenin value'si geçilirken, aslında objenin heap'teki referansı geçilir. buraya kadar herşey normal. fakat geçilen bu referans'ın kopyası (clone'u), stack içindeki sadece o metoda ait yerde tutulur. yani hem dallandığımız metod içerisinde hemde metodu çağırdığımız metod içerisinde 2 adet kopya olmuş olur.

yani; 'reference' değilde, 'referance value' yollamış oluyoruz. aslında reference yollanıyor fakat kopyası yollanıyor. yukarıdaki kod örneğinde bu kopya değerinin üzerine yeni objeminizin (Ayse) adresini yazıyoruz.

# java debugger features
eclipse üzerinde debug mode'dayken iki buton sunar:

- drop to frame
  
  o anda bulunduğumuz metodun tekrardan işletilmesini sağlıyor. bunun için:
  - o metodun içinde yaratılmış bütün kaynakları (string, int...) yok ediyor
  - debug noktasını metodun en başına taşıyor

  bu durumda metodun aldığı parametrelerin referanslarında değişiklik yapmışsak, o değişiklikler kalmaya devam ediyor.

- step return

  o anda bulunduğumuz metodun sonlanmasını sağlıyor. debug noktası bulunduğumuz metodu çağıran metoda gidiyor. artık next diyip kodu devam ettirdiğimizde, akış tekrar ilgili metoda girmeyecektir.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# stringbuilder vs stringbuffer

aynı işi gören iki kütüphanedir. tek farkı stringbuffer'ın thread safe olmasıdır. bu da stringbuilder'ı daha performanslı yapıyor.

# string vs stringbuilder

compiler "b" + "a" gibi satırları stringbuilder ile yapıyor ve bu şekilde memory'den kazanmamızı sağlıyor. fakat derleyici %100 her zaman stringbuffer'a çeviremeyebiliyor.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Java Collections

Türeme sırası aşağıdaki gibidir.

Iterable ->interface

Collections ->interface

List ->interface

ArrayList ->Class

# LinkedList vs ArrayList

List'ten türemiş bir diğer sınıf LinkedList'tir. ArrayList ile ortak arayüzü kullandıklarından kullanım farkı yoktur, fakat algoritmaları gereği hız ve bellek kullanımları farklıdır. LinkedList üzerinde her eleman bir sonraki elemanın referansını tutar. bu sebeple araya eklenene değerler hızlıca eklenip silinebilir. oysa ArrayList'te araya ekleme ve silmeler çok maliyetlidir.

# Iterator

Iterator'dan türetilen sınıflar Iterator dönen bir metod içerir. BU metoddan dönen değerler for-each döngüsü ile dönüldüğünde değerler silinebilir hale gelir. Aksi halde; iteratorsız, direk collection'ı dönersek ve döngü içerisinde eleman silersek, collection algoritma yapısı gereği hata alırız. Collection yapıları; objeleri tutmak için belli algoritmalar kullanır.

# Map

Map interface'si hiçbir yerden türememiştir. Map<Class1, Class2> şeklinde tanımlanır. Her class1 çeşidinde bir objeye karşılık, class2 çeşidinde bir obje vardır. Key-value şeklinde tutar. Map'te tüm value'ları almak ve tüm key'leri almak için bir metod vardır. Bu metodlar'dan dönen değerler kullanılarak for döngüleri yapılabilir.

Map sınıfından türetilmiş sınıfllar aynı interfaceden türedikleri için ortak özellikler sunarlar. fakat algortimaları gereği hızları ve döngü esnasında verdiği değerlerin sıraları farklıdır.

- HashMap: döngü sırasında hangi elemanı vereceğinin garantisi yoktur.

- TreeMap: döngü sırasında elemanları sırası ile verir (burada sıra şu şekilde bulunur: bir metod referans verilir. bu metoda 2 eleman paramtre dönderdiğinde hangisinin önce yada sonra olduğu bulunur).

- LinkedHashMap: map.put(object) metodunun işlediği sıra ile döngü sırasında elemanlar iterate edilir.

# EnumMap

Sadece enum değerleri kabul etmektedir. alabileceği  değerler kısıtlı sayıda olduğundan hızlı çalışmaktadır.

# Set

Set, Collectiondan türemiştir. Set içerisinde dublicate nesne olamaz.

# unmodifiable collections

List<Character> immutablelist = Collections.unmodifiableList(list);

bu şekilde varolan bir listeyi editlenemeyecek bir liste olarak kopyasını oluşturuyoruz. Bu kopya listede add(obj) gibi metodlar hala mevcuttur. fakat liste elemanlarında editleme yapılmak istendiğinde unsupportedoperationexception fırlatılmaktadır. bu sınıf genelde bir yere listeyi göndermek fakat değişiklik yapılmasının riskli olduğu düşünüldüğü durumlarda kullanılmaktadır.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# immutable types

- tersi mutable'dır.

- immutable‘ın türkçe kelime anlamı: durağan, sabit, değişmeyen.

bir nesnenin içindeki refernas değişken değiştirilemez olduğunda bu nesne immutable tipinde demektir. örneğin unmodifiable collections'lar immutable'dır. çünkkü içindeki referans değişkenler (liste elemanları) değiştirilemezler. burada karıştırılmaması gereken nokta;

List<Character> immutablelist = Collections.unmodifiableList(list); //immutable yaptık

immutablelist.add("yeni_deger"); //burası hata vermeli

immutablelist = list2; //burası hata vermemeli. çünkü immutable-list kavramı nesnenin kendisinin bir özelliğidir, nesnenin referansı konu dışıdır.

User nesnesi içindeki TC değişmemeli (kanun gereği kesin olduğunu varsayarsak); User immutable mı olur?  Hayır. Çünkü User içindeki ad, soyad her zaman değişebilir. User nesnesinin içindeki hiçbir değişken değiştirilemez olursa ancak immutable olur.

# Immutability avantajlari

- Istedigimizde getter'lardan bu objeyi döndürürüz

- multitread uygulamalarda guvenlik saglar

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Properties Class of Java
Java Map sınıfından türetilmiştir. Properties dosyalarına tekabül eden (bu mantıkta çalışmalar için) özel tasarlanmıştır.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# System Environments from Java

- Java kodları içerisinden sistemin environment değerleri (PATH, JAVA_HOME gibi) çağrılabilmektedir: System.getenv();

- Benzer mantıkta java programına yada JVM argümanarına parametre geçilebilir: "java -Dmyparam1=myvalue1 -jar myapp.jar". Bu parametreleri kod içerisinden almak için System.getProperties("myparam1") kullanılır.

- program argümanları ise; main'e string args[] ile geçilen paramerelerdir.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# lambda expression (yada tr:lamda ifadeleri)
Kalkülüs (yada eng:calculus) hesap anlamına gelektedir. __"lambda calculus (yada λ-calculus)"__ matematikte fonksiyonların ifade edilmesi için bir çeşit syntax'tır. programlama dillerindeki aynı yapıdır.

lambda programlama dünyasında anonim fonksiyon yaratmak için kullanılan özel bir syntax ismidir. örnek lamdba expression:

> (param1) --> { print(param1) }

lambda, programlama dünyasında anonim fonksiyon anlamına gelmemektedir. fakat anonim fonksiyon yaratmak için kullanılır. anonim fonksiyon için tek yol bu diildir. örneğin javascriptte şu şekilde de anonim metod yaratılabilir:

> function(param1){ print(param1) }

Yani; lambda expression kullanılmadan da anonim metod yaratılabiliyor.

javascript'te "lambda expression" terimi yerine; "arrow function expression" kullanılır.

# java dilinde lamda
java 8 ile hem lamda expression hemde fonksiyon arayüz (yada function interface) özelliği gelmiştir.

```java
@FunctionalInterface //bu notasyon isteğe bağlı. hiçbir özelliği yok. ama atılması öneriliyor. cünkü normal interface'ler ile aynı syntax'ı var asagidaki kodun. farkını okuyan görebilmeli.
interface MyInterface {

    MyResultObj myMethod(int myParam);
}
```

ile yukarıda tanımlama yaptık. asagida da kullandık:

```java
MyInterface myInterface = realParam -> {

            System.out.println(realParam);
};

myInterface.myMethod(3);
```

myMethod'u implemente etmiş olduk. interfacede myMethod gibi sadece bir metod olabilir. daha fazla olamaz. bu sebeple metodu implemente ederken hiç "myMethod" string'ini hiç kullanmadık.

- myMethod iki adet parametre alsaydı, kullanım kısmında şu satır olacaktı:

  > MyInterface myInterface = (realParam, realParam2) -> {

- myMethod metodumuz isterse parametre döndürebilir. doğal olarak dönüş parametresi kullanım ksımında myInterface.myMethod(3) ‘teki myMethod metodundan dönüyor olacaktı.

- Interface ‘ler extend edebilirler.

- kullanım kısmında; System.out.println(3);  etrafındaki süslü { } parantezler yazılmayayabilir (tek satırlı kodlar için geçerli.)

- java.util.Function altında birçok hazır fonksiyon interfaceleri tanımlanmıştır. örnek: BiConsumer<T,U>, Consumer<T> gibi… Bunlar hazırdır. Çünkü; çoğu zaman genellikle fonksiyon interfaceleri 1-2-3 parametre alır ve bir parametre döner yada dönmez. Bunlar için sürekli yeni fonksiyon interface tanımlaması yapmamız gerekir. bu sebeple hazırları oluşturulmuştur. örnekler:

  - Consumer (tüketici) yani herhangi bir paramtre alır ama hiçbir şey dönmez

    ```java
    @FunctionalInterface
    public interface Consumer<T> {
        void accept(T t); // t-> {}
    }
    ```

    Consumer'a alternatif olan diğer birçok örneği tabloda toplarsak:
    
    (T, U, R herhangi bir class'ı temsil eder)

| interface adı  | aldıgı parametrelerin tipi | döndürğü parametre tipi |
|----------------|----------------------------|-------------------------|
| Consumer       | T                          | void                    |
| BiConsumer     | T U                        | void                    |
| Function       | T                          | R                       |
| BiFunction     | T U                        | R                       |
| UnaryOperator  | T                          | T                       |
| BinaryOperator | T T                        | T                       |
| Predicate      | T                          | boolean                 |
| BiPredicate    | T T                        | boolean                 |
| Supplier       | void                       | T                       |
| ToIntFunction  | T                          | int                     |
| DoubleConsumer | double                     | void                    |
| ObjIntConsumer | Object int                 | void                    |

# lambda vs closure
lambda closure ile aynı anlama gelmiyor. çoğu yerde aynıymış gibi yansıtılıyor. lambda bir syntax. closure ise return edilen bir fonksiyon aracılığı ile farklı scope'tan değer değiştirmemize yarayan metotdur. lambda desteği olan yazılımda mutlaka closure olabileceği için bu iki terim aynıymış gibi kullanılıyor.

# metod referansları
tanımlama kısmında, implemente etmiş olduğumuz metod zaten başka bir yerde zaten var ise, başka yerdekini direk referans edebiliriz. örnek;

```java
MyInterface myInterface = AnotherClass::otherMehod; //otherMehod is static method

MyInterface myInterface = anotherObj::otherMehod; //anotherObj is an instance

MyInterface myInterface = AnotherClass::new; //refers the constructor method
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# java stream
java 8 ile gelmiştir.

lamda'ya bağımlı olan (onu kullanarak yapılan) bir özelliktir. bu özellik java programlama dilinden gelmemiştir. java'daki kütüphaneler kendi içlerinde hazır, işe yarar interfaceleri bulundurmaya başlamışlardır. bu interfacelere genel olarak stream denilmiştir. Collection'dan türemiş tüm sınıfılar için işlemler ortak olduğundan, tüm stream kütüphaneleri ortak olarak java.util.stream paketi altında toplanmıştır. böylece tüm collection yada bir kütüphanede herkes ortak/bilindik metodları kullanabilmektedir. isteğe bağlı kendi stream interfacelerimizi yazabiliriz.

Java'ının içinde bulunan Stream tanımına bakarsak daha iyi karayabiliriz:

```java
public interface Stream<T> extends BaseStream<T, Stream<T>> {

   Stream<T> filter(Predicate<? super T> predicate);

   LongStream mapToLong(ToLongFunction<? super T> mapper);

   //yukarıdaki gibi birçok metod daha burada...

}
```

Yukarıdaki tanımlamada Stream<T> sınıfı sade basit bir interface. içindeki metodlarda implemente edilmeyi bekleyen metodlar. metodlar dikkat edilirse lambda fonksiyonu kabul ediyor. işte bu yüzden Stream, lambda teknolojisine dayalı bir kütüphane.

Şimdi ise örnek kullanımına bakalım:

```java
//en temel stream örneği. collectionlar artık stream metodlarını içermektedir.

List names = Arrays.asList("Ali","Veli","Selami");

Stream stream = names.stream(); //burada bir Stream implementasyonu dönmektedir. bu implementasyon  java.util.List tarafından hazırlanmış durumda.

stream.forEach(name -> {

    System.out.println(name);

});

names
    .stream()

    .filter(name -> name.length() == 4)

    .forEach(System.out::println);



//java.io içerisinde bazı sınıflarda stream döndüren metodlar gelmiştir.

Path dir = Paths.get("/var/log");

Stream pathStream = Files.list(dir); //list java 8 ile gelen yeni bir metod'dur.

//dizi içeriğini alarak direk hazır stream döndüren metodlar vardır. önceden dizi oluştumaya gerek kalmıyor.

IntStream intOf = IntStream.of(1, 2, 3); 

IntStream intRange = IntStream.range(1, 10); 

DoubleStream doubleOf = DoubleStream.of(1.0, 3.5, 6.6); 

```

En son örnekte görüldüğü gibi sadece java.util.stream.Stream yok. Bunun gibi biçok stream çeşidi var. örnek: java.util.stream.DoubleStream. Bunun gibi kendi stream'lerimizi de yazabiliriz.

Stream interfacesinde olan tüm metod imzalarından görüldüğü gibi çoğu metod yine Stream döndürüyor. Bu kolaylık olsun diye tasarlanmış bir yapı. böylece üstüste metod çağırmak istediğimizde her defasında stream'i tekrar çekmeye gerek kalmıyor.

java.util.stream.Stream içindeki ir kaç metoda detaylı bakalım:

```java
// collect: bir önceki stream'den dönen listedeki elemanları, collect'e parametre olarak verdiğimiz metoda yollar. ve dönen değeri döndürür.
List number = Arrays.asList(2,3,4,5,3);
Set square = number.stream().map(x->x*x).collect(Collectors.toSet());

// map: return değerinde olan elementler ile yeni bir liste oluşturuyor. daha sonrasında bu listeyi collect'te verdiğimiz metod'a parametre geçiyoruz.
List number = Arrays.asList(2,3,4,5);
List square = number.stream().map(x->x*x).collect(Collectors.toList());

// filter: map gibi yeni elemenlar döndürmüyor. sadece filtreden true dönen elemanları içeren yeni bir liste oluşturuyor.
List names = Arrays.asList("Reflection","Collection","Stream");
List result = names.stream().filter(s->s.startsWith("S")).collect(Collectors.toList());

// sorted
List names = Arrays.asList("Reflection","Collection","Stream");
List result = names.stream().sorted().collect(Collectors.toList()); 

// forEach: her eleman için fonksiyon çağırır
List number = Arrays.asList(2,3,4,5);
number.stream().forEach(y->System.out.println(y));

// reduce
// not: range 1, 2, 3 elementlerinden oluşan bir liste yaratıyor.
// recude metodu kümülatif işlemler yapmamızı sağlıyor.
// reduce önce 1 ve 2'yi bizim yolladığımız fonksiyona atıyor. daha sonra sonucu "3" ile yine bizim yolladığımız parametreye yolluyor. ve en sonda sonucu döndürüyor.
// yani; şu işlemler sırası ile oluyor:

// (1,2) -> 1+2   (buradan 3 geliyor)
// (3,3) -> 3+3   (buradan 6 geliyor)

// OptionalInt=6 olarak dönüyor.

OptionalInt reduced = IntStream.range(1, 4).reduce( (a,b) -> a+b  );

// Match operations
List<Notification> notificationList = Arrays.asList(notification1, notification2, notification3, notification4);

// noneMatch: her elementi kontrol eder. Belirtilen kriter listede hiçbir elemanda bulunmuyor ise true döndürür.
boolean isNoneMatch = notificationList.stream().noneMatch(notification -> notification.getTitle().contains("a"));

// allMatch Belirtilen kriter listede tüm elemanlarda bulunuyor ise true döndürür.
boolean isAllMatch = notificationList.stream().allMatch(notification -> notification.getTitle().contains("a"));

// anyMatch Belirtilen kriter listede herhangi bir elemanlarda bulunuyor ise true döndürür.
boolean isAnyMatch = notificationList.stream().anyMatch(notification -> notification.getTitle().contains("a"))
```

# intermediate vs terminal operations
filter() gibi metodlar yeni bir stream objesi döndürür, bu sebeple intermediate olarak nitelendirilir. oysa terminal operation metodları, Stream.forEach gibi, stream değilde, herhangi farklı bir obje döndürür.

intermediate metodlar 2'ye ayrılır:
- stateless

  bir önceki stream'den hiçbir state tutumazlar. örnek: filter and map.

- stateful

  örnek: sorted

# parallel vs serial
Collection sınıfı içinde stream() and parallelStream() metodları vardır. sadece buna göre stream'lerin paralel yürütülüp, yürütülmeyeceğine karar verilir.

örnek:

```java
List number = Arrays.asList(2,3,4,5);
number.parallelStream().forEach(y->System.out.println(y));
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# groovy language syntax
groovy syntax başlığı gradle grovvy kullandığı için önemli.

groovy her sınıfa otomatik olarak aşağıdaki paketleri import eder. Bu sebeple print gibi metodlar direk çağrılıyor. bu durumun groovy'nin syntax'ı ile bir bağlantısı yoktur.

```
import java.lang.*

import java.util.*

import java.io.*

import java.net.*

import groovy.lang.*

import groovy.util.*

import java.math.BigInteger

import java.math.BigDecimal
```

# special characters calls metods
"technologies" instance'ı bir liste ise;

```
technologies = technologies - 'Grails' // removes an element form list

technologies << "Groovy" //adds an element to list
```

her işaret spesific bi metodu çağrıyor. yani; technologies liste objesinde - işareti minus isimli metodu execute ediyor. biz de yaptığımız sınıfta minus metodunu - işareti ile çağırabiliriz. << gibi diğer karakterler:

> +

a.plus(b)

> a[b]

a.getAt(b)

> -

a.minus(b)

> a[b] = c

a.putAt(b, c)

> *

a.multiply(b)

> a in b

b.isCase(a)

> /

a.div(b)

> <<

a.leftShift(b)

> %

a.mod(b)

> \>>

a.rightShift(b)

> **

a.power(b)

> \>>>

a.rightShiftUnsigned(b)

> |

a.or(b)

> ++

a.next()

> &

a.and(b)

> --

a.previous()

> ^

a.xor(b)

> +a

a.positive()

> as

a.asType(b)

> -a

a.negative()

> a()

a.call()

> ~a

a.bitwiseNegate()

# closure

```java
class MyClass {

    def str1 = 'Merhaba'

}

static void main(String[] args) {

      def str1 = "Hello";

      def clos = { param -> println "${str1} ${param}" } //this is closure

      clos.call("World"); //prints "Hello World"

      // now We are changing the value of the String str1 which is referenced in the closure

      str1 = "Welcome";

      clos.call("World"); //prints "Welcome World";

      clos("World"); // yukarıdaki satıri ile (call metodu ile) aynı görevi görüyor.

       clos.setDelegate(new MyClass() ); // we change the context of closure.

       clos("World"); //prints Merhaba World

 

     def myClosure2 = { println it }; // closure sadece 1 parametre alıyorsa, parametre tanımı yazılmak zorunda değildir. değişkenin ismi "it" olur.

     def myClosure3 = { String param -> println "${str1} ${param}" }; // closure'larda, istenirse parametre tipi verilebilir.

   }
```

# DSL support
> a b c d

yukarıdaki kod satırı bunu yapıyor:

> a(b).c(d)

# sadece java ile farklılık gösteren kısımlarla bir örnek sınıf:

```java
class Example {

static void main(String[] args) {

//def keyword

def x = 5;  //def keywordu javadaki Object'e denk geliyor. def istenirse kullanılır.

// range

def range = 5..10;

println(range); //prints 5 6 7 8 9 10

println(range.get(2)) //prints 7 . noktalı vişrgül kullaılmayabilir. yeni satır yapmak yeterli.

//for in statement

for(int i in array) {

         println(i);

}

// for statement

for(emp in employee) {

         println(emp);

}

} //end of main method

//default parameter (if parameter will not pass than default value will be used)

static void sum(int a,int b = 5) {

      //method code here

}

} //end of class
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# optional
java 8 ile gelmiştir. nullpointer kontrollerinin gerekmediği daha temiz kod yazılabilmesini sağlamaktadır.

```java
String message = null;

Optional<String> opt = Optional.ofNullable(message); // ofNullable null değer alırsa nullpointer fırlatmaz.


opt.filter(m -> m.length() > 5) // filter, filtreleme yapmamızı sağlayan ek bir metoduddur
      .ifPresent(System.out::println); // eğer filtre sonucundaki değeler null değilse, bu kod bloğu işletilir. böylece null kontrolü yapmamış oluyoruz.
```

Bu şekilde if(message ==null) gibi sorgular yazmayız.

- Optional<Double> empty = Optional.empty();

  boş bir Optional nesnesi oluşturur
  
- Optional<String> of = Optional.of("Merhaba");

  of metodu null değer alırsa nullpointerexception fırlatır
  
- Optional<Integer> ofNullable = Optional.ofNullable(null);

  ofNullable null değer kabul eder hata fırlatmaz.

- ifPreset metodu
  
  Preset kelime anlamı: mevcut

  eğer opt içindeki değer null değilse ifPresent metodu koşar.

  ```java
    opt.ifPresent(num -> {
        Double karesi = Math.pow(num , 2);
        System.out.println("Sonuç: " + karesi);
    });
  ```

- orElse

  ```java
  Integer numara = null;

  Optional<Integer> opt = Optional.ofNullable(numara);

  int result = opt.orElse(0); //opt null ise 0 döndürür.
  ```

- orElseThrow

  opt null ise parametrede geçeceğimiz exception'u fırlatır.

  ```java
  int result = opt.orElseThrow(RuntimeException::new);
  ```

- orElseGet

  orElse ile aynı mantıkta çalışmaktadır. tek bir obje yerine fonksiyon parametre alması. eğer opt null ise; parametre geçtiğimiz fonksiyonumuzun döndürdüğü değeri döndürür.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Nashorn
java ile yazılmış, javascript motorudur.

js komutu ile javascript dosyası execute edilebiliyor (node.js teki gibi).

# java'dan js çağırma örneği:

- js kodu:

```js
var fun1 = function(name) {

    print('Hi there from Javascript, ' + name);

    return "greetings from javascript";

};
```

- java kodu

```java
ScriptEngine engine = new ScriptEngineManager().getEngineByName("nashorn");

engine.eval(new FileReader("script.js"));

Invocable invocable = (Invocable) engine;

Object result = invocable.invokeFunction("fun1", "Peter Parker");

System.out.println(result);

System.out.println(result.getClass()); //prints java.lang.String
```

# javascript tarafından java kodu çağırma örneği:

- java kodu:

```java
static String fun1(String name) {

    System.out.format("Hi there from Java, %s", name);

    return "greetings from java";

}
```

- js kodu:

```js
var MyJavaClass = Java.type('my.package.MyJavaClass');

var result = MyJavaClass.fun1('John Doe');

print(result);
```

# object types

js tarafından java'ya obje parametresi geçerken;

- çervilebilen değerler (json standardındakiler) java.lang içindeki String, int, boolean gibi sınıflara çevriliyor.

- objeler java tarafından bilinmeyen objeler ise (örneğin bir json objesi) ; o zaman "jdk.nashorn.internal.scripts.JO4" Sınıfına cast ediliyor. Bu sınıftan get("myJsValue") gibi metodlarla sınıf objelerini çekebiliyoruz.

- MyJavaClass.fun2(new Date()); gibi genel olarak kullanılabilecek sınıfları "jdk.nashorn.internal.objects.NativeDate" gibi sınıflara çeviriyor.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Orika
object to object mapper for java runtime.

örnek: 

```java
mapperFactory.classMap(Source.class, Dest.class);
MapperFacade mapper = mapperFactory.getMapperFacade();
Source src = new Source("abc", 99);
Dest dest = mapper.map(src, Dest.class);
```

Yukarıda "Source" class ve "Dest" class'ında aynı isimde property'ler olmalı. eğer farklı property'leri map edecek isek;

```java
mapperFactory.classMap(Source.class, Dest.class).field("nom", "name").field("surnom", "nickname").register();
```

# Dozer
orika'ya alternatif ve nerdeyse aynı kod API'si olan kütüphane. Dozer, reflection'lardan yararlanarak mapping yaparken, Orika mapping yapılacak objeyi bytecode'a çevirir ve sonrasında mapping yapar.

# JMapper vs modelmapper vs MapStruct
orika ve dozer'a alternatif kütüphanelerdir.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Jeasy
java için birçok birbirinden bağımsız kütüphaneler geliştiren projenin ismidir.  

j-easy github ve www.jeasy.org'u kullanırlar. 

# easy-random
Jeasy'nin bir kütüphanesidir.

easy-random'un API'sine bir java sınıfı veririz, easy-random bu java sınıfının içindeki değerleri random bilgilerle doldurulmuş (değerleri set edilmiş) şekilde döndürür. 

4.0 sürümü öncesi, projenin ismi random-beans'tı. 4.0 ile easy-random yapıldı. Aynı sürümde io.github.benas paket ismindeki kodlar, org.jeasy altına taşındı.

Bu kütüphane test yazımında büyük kolaylık sağlar.

örnek:

```java
EasyRandom easyRandom = new EasyRandom();
Person person = easyRandom.nextObject(Person.class);
```

Opsiyolenl olarak, random olacak bilgilerin aralıklarını vs verebiliriz:

```java
EasyRandomParameters parameters = new EasyRandomParameters()
   .seed(123L)
   .objectPoolSize(100)
   .randomizationDepth(3)
   .charset(forName("UTF-8"))
   .timeRange(nine, five)
   .dateRange(today, tomorrow)
   .stringLengthRange(5, 50)
   .collectionSizeRange(1, 10)
   .excludeField(named("age").and(ofType(Integer.class)).and(inClass(Person.class)));

EasyRandom easyRandom = new EasyRandom(parameters);
```

############################

############################
# UNIX-LIKES
############################

############################

# apparmor vs selinux
birbirlerine alternatif __Linux kernel security module (yada LSM)__'leridir. dosyalara erişimi kısıtlarlar.

"Subject vs Principal vs User" başlığında da anlatıldığı gibi; her security context'inde:

- obje; erişilecek kaynaktır. LSM için: dosya ve dizin.
- subject; objeye erişmek isteyen process'tir. LSM için: OS üzerinde çalışan yazılımlar.

# discretionary access control (yada DAC) vs mandatory access control (yada MAC)
discretionary kelime anlamı: isteğe bağlı

mandatory kelime anlamı: zorunlu

apparmor ve selinux yüklü olmayan *nix sistemlerde, standart *nix dosya koruması vardır. bu koruma DAC grubuna girer. çünkü DAC dosya sahibinin erişimi isteğe bağlı kısıtlayabildiği kontrol mekanizmalarına denir.

MAC ise; sistem admini tarafından verilen kurallar ile kısıtlama getirilen güvenlik mekanizmalarına denir.

Bu durumda apparmor vs selinux MAC grubundadır. Fakat ek olarak DAC yetenekleri de sunarlar.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# dns ve host ayarları

/etc/resolv.conf dosyasında dns tanımları vardır:

nameserver 8.8.8.8
nameserver 8.8.4.4

Bu dosya birçok yazılım tarafından aynı anda editlemekte ve okunmaktadır. okuyanlar arasında "resolver" uygulaması da vardır.

Herkesin paralel okuması veya buraya yazılması durumuna çözüm getirmek için "resolvconf" yazılımı geliştirildi. diğer tüm uygulamalar (vpn client, network manager...) her dns değişiminde "resolvconf" uygulamasına bilgi göndermesi beklenir. Fakat "resolvconf" yazılımı sonradan geliştirildi. hala onu tanımayan başka yazılımlar var ve bu sebeple "resolvconf" her zaman tam olarak başarıyı sağlayamıyor.

Son kullanıcı resolv.conf dosyasını editlememeli. /etc/network/interfaces dosyasını editlemelidir.

örnek:

```
dns-nameservers 12.34.56.78 12.34.56.79
```

network manager (root olarak çalışan yazılım ve önyüz uygulamaları (önyüz uygulamarına örnek: nmcli, nmtui) asagidaki dns ayarlarını kendice override eder:
- dhcp ayarlarındaki dns'leri
- resolv.conf'taki dns'leri
- /etc/dhcp/dhclient.conf'teki dns'leri

NetworkManager GUI'den son kullanıcının belirlediği ayarları buraya kaydeder:

> /etc/NetworkManager/system-connections/name-of-connection

örnek:

> "/etc/NetworkManager/system-connections/Wired connection 1".

dosya içeriği örneği:

```
[802-3-ethernet]
duplex=full
mac-address=XX:XX:XX:XX:XX:XX

[connection]
id=Wired connection 1
uuid=xxx-xxxxxx-xxxxxx-xxxxxx-xxx
type=802-3-ethernet
timestamp=1385213042

[ipv6]
method=auto

[ipv4]
method=auto
dns=208.67.222.222;
ignore-auto-dns=true
```

Artık tüm network manager gui'leri doğru bilgiyi gösterecektir.

# /etc/hosts

default örnek dosya içeriği:

```
cat /etc/hosts
127.0.0.1	localhost
127.0.1.1	machibe-id

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouter
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# library path

çalıştırığımız program, kütüphaneleri tararken, taradığı dizinler arasına yeni bir dizin eklemek istersek bu path parametresinden yararlanabiliriz:

```bash
export LD_LIBRARY_PATH="/list/of/library/paths:/another/path"
./program
```

bu standart bir path değeri olduğundan her sistem bunu okur.

java'da özel olarak ikinci bir yöntemde sunulmuştur:

```bash
java -Djava.library.path=/path/to/my/dll -cp /my/classpath/goes/here MainClass
```

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# ubuntu-restricted-extras

bu paket ubuntu repolarında duruyor fakat lisans sebepleri gereği ile default yüklü getirilemiyor. içerisinde şunları barındırıyor:

- adobe flash player

- mp3 codec ve diğer codec'ler

- microsoft TrueType core fontları

- icedtea plugin

- unrar

# repositories
Ubuntu'da 4 ana repository var:

| repository name | open source | supported by canonical |
|-----------------|-------------|------------------------|
| main            | yes         | yes                    |
| universe        | yes         | no                     |
| Restricted      | no          | yes                    |
| Multiverse      | no/yes      | no                     |

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# root of linux distros

- debian (deb based)

  - SteamOS (gnome masaüstü de yüklü geliyor. bu şekilde normal linux uygulamaları da çalıştırılıyor.)

  - Raspbian (Raspberry üzerinde çalışması için tasarlanmış. lxde yüklü.)

  - mxLinux (sadece desktop sürümü olan. içerisinde son kullanıcı birçok için paket yüklü geliyor. bu sebeple çok kolay kulanımı var. xfce masaüstünü kullandığı içinde hafif.)

  - kali (yada eski adı:BackTrack) (güvenlik testleri için geliştirilmiş tool'lar içeriyor)

  - tails (yada The Amnesic Incognito Live System) (tüm bağlantılar tor üzerinden yapılır ve gizliliği amaçlar)

  - pardus (tübitak tarafından geliştiriliyor. eskiden pisi paket yöneticisi kullanırdı fakat daha sonradan deb'e geçti.)

  - KNOPPIX (temel amacı live cd ile çalışmak. çok hafif.)

  - ubuntu

    - mint

    - elementary (sadece masaüstü sürümü mevcut. son kullanıcı için kolaylatırılmış ayarlar barındırıyor.)

    - deepin

    - zorin

    - ubuntu studio (ubuntu'nun multimedia uygulamaları yüklü gelen türevi)

- fedora (rpm based)

  - Mandrake

  - Red Hat Enterprise Linux (yada RHEL) (ticari)

    - centOS (yada Community Enterprise Operating System) (community yönetiyor. RHEL'den hiçbir farkı yok. RHEL gibi bir ticari OS'u temel aldığı için üstünede paketler free olunca herkes tarafından özellikle tercih sebebi oluyor.)

    - Oracle Linux (ticari)

    - scientific Linux (akademik çalışmalarda kullanılması için tasarlandı. 2019'da geliştirmesi durduruldu ve CentOS'a geçip ona destek verecekleri açıklandı.)

- arch (Pacman paket yöneticisi). sistem kurulumunda sadece ihtiyaç olan paketleri seçtirebilmesi konusunda çok çok esnek.

  - Manjaro

- Gentoo (package manager: Portage) arch gibi sistemin paketlerine kadar kullanıcnın kendisi kuruyor. arch'a göre daha fazla teknik bilgi gerektiriyor.

  - Sabayon

- opensuse (rpm based)

  - SUSE. enterprise.

- PCLinuxOS (end user friendly. sadece masaüstü versiyonu mevcut. RPM based.) 

- Mandriva (yada eski adı:Mandrake) (rpm based)
  
  - mageia

  - OpenMandriva

- Puppy (liveCD ile çalışabilmek için çok hafif tasarlanmıştır)

- Slackware

- nixOS (nix package manager as default)

- Alpine (package manager: apk (yada Alpine Package Keeper) )

- solus (paket yöneticisi: eopkg (pisi türevidir)) (sadece son kullanıcı için masaüstü sürümü mevcuttur.)

distrowatch.com'dan bir OS'un detay sayfasına bakıldığında, temel yazılımlar için (browser, office...) yüklü olan güncel paket sürümleri gibi tüm detaylar dahi bulunmaktadır.

distrotest.net sitesi gerçek makinaya tarayıcı üzerinden vnc ile kullanma imkanı sağlıyor.

# ReactOS
microsoft windows dosyalarını yürütebiliyor ve ona benziyor. linux tabanlı bir OS değildir. sıfırdan yazılmış bir OS çekirdeği kullanılıyor.

# ubuntu netboot
ubuntu türevi değildir. ubuntu'nun standart iso'sundan farklı olarak GUI ve birçok paketi yüklü getirmez. son kullanıcılar arasında "minimal iso" yada "mini.iso" olarakta adlandırılır. bu iso ubuntu repo'larına kurulum sırasında bağlanarak indirme yapar. tabi güncel paket kuracağı için update işlemine gerek kalmaz.

Ubuntu 18.04 ile standart iso ile kurulum sırasında yeni bir seçenek sunuyor: "minimal installation". bu seçenek yukarıdakinden tamamen bağımsızdır. bu standart masaüstü bileşenlerini ve utility'lerin kurulmasını fakat vlc, libreoffice, oyunlar gibi ekstra paketlerin kurulmamasını sağlıyor. normal installation ile arasındaki fark (kurulmayan tam paket listesi) https://bazaar.launchpad.net/~ubuntu-core-dev/ubuntu-seeds/ubuntu.bionic/view/head:/desktop.minimal-remove

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Portage

paket yönetim sistemidir. komut satırı uygulaması: __emerge__'dür.

# dnf (yada Dandified YUM) vs yum (yada "Yellowdog Updater, Modified")

rpm (yada Redhat Package Manager) paket yönetim sisteminin komut satırı uygulamalarıdır. dnf yum'un türevidir. fedora'nın birçok türevinden kullanılıyor.

# yum groupinstall vs yum install

yum paketleri grup halinde barındırabiliyor. örneğin "graphic user interface" isimli bir grup varsa, bu grubun içinde gui için gerekli tüm paketler mevcuttur. tek komut ile tümünü kurabiliyoruz.

# zypper

rpm paket yöneticisi. Suse tarafından kullanılıyor. __ZYpp (or libzypp)__ paket yöneticisinin ismi, onu yöneten komut satırı uygulamasının ismi: __zypper__.

# deb paket yönetim sistemi

# apt-get

debian paket yöneticisi için komut satırı uygulamasıdır. "sudo apt-get install chat"

# apt-cache

debian paket yöneticisinin source-list'i ile ilgili işlemlerin yapılmasını sağlayan komut satırı uygulaması. örnek: "sudo apt-cache search chat"

# apt

apt son kulanıcı için geliştirilmiş daha basitleştirilmiş hem apt-cache hemde apt-get komutlarını basitleştirip farklı bir arayüzde sunuyor.

# purge vs remove

apt-get'e geçilen iki parametrede uygulamayı silmemizi sağlar. purge ise configuration dosyalarını da siler. burada bahsi geçen config dosyaları /home içindeki dosyalar değil. bahsi geçen config'ler /etc içindeki konfiglerdir ( /etc: config files for all users. example /etc/appname/ ).

purge seçeneği "synaptic package manager"'de "Tamamen kaldır" seçeneğine tekabül ediyor.

# autoremove vs remove

remove yerine autoremove kullanılırsa, silinen ilgili paketin yüklemiş olduğu ve diğer paketler tarafından kullanılmayan dependency'ler(paketler) de sistemden silinir. genelde bu paketler çok ufak olduğunda tekrar ihtiyaç olması ihtimaline karşı pek kimse autoremove kullanmıyor.

# apt-get update

Paket listelerini güncellemek. liste /etc/apt/sources.list (text bazlı dosya) dosyasındadır.

# apt-get upgrade

kurulu paketleri günceller.

# apt-get dist-upgrade

işletim sistemini günceller. 

# upgrade vs dist-upgrade

sources.list dosyasına baktığımızda içinde bu tarz url görebiliriz: "http://archive.ubuntu.com/ubuntu xenial-security". dikkat edilirse; xenial (ubuntunun bir sürümünün ismi) yazıyor. işte "upgrade" komutu run edildiğinde xenial için desteklenen en son sürüm vlc, firefox ve diğer paketler kuruluyor. yani vlc'nin en son sürümü kurulacak diye bir durum söz konusu diildir. fakat "dist-upgrade" sources.list dosyasının bu url'lerini de günceller. işte işletim sistemi yükseltme farkı budur. işletim sistemi de paketler topluluğudur. bu bakış açısı ile "xenial" kelimesi sources.list'te olmasaydı tüm sistem sürekli yükselirdi.

# apt-get clean

/var/cache/apt/archives/ içinde bulunan .deb uzantılı dosyaları siler. ".deb" dosyaları tekrar kurulma ihtimaline karşı hazır tutulur.

# apt-cache search paket_adı 

programı aramak

# apt-cache show paket_adı

program hakkında bilgi almak

# repository

sources.list dosyasındaki her url bir repository'dir. repository paketlerin dışarıdan indirilmesi için açılan sunucudur.

# ppa (yada Personal Package Archive)

paketlerin dışarıdan indirilmesi için açılan Launchpad sunucularıdır. bir ppa sunucusunda birden fazla paket çeşidi indirilebilir. sadece bir paket olmak zorunda diildir.

apt-add-repository ppa:group-name/sub-name ile ppa kurulabilir. eklenen ppa source.list'e eklenmez. ppa farklı bir yerde tutulur: "/etc/apt/sources.list.d" dizininde dosyalar halinde tutulurlar. 

# dpkg
deb dosyaları üzerinde direk işlem yapabilmemizi sağlayan komut satırı uygulamasıdır.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# .desktop dosyaları
Birçok linux dağıtımında ".desktop" uzantılı dosyalar mevcuttur. Bunlar normal birer text dosyasıdır. Run edildiklerinde, içindeki bilgilere göre bir komut çalıştırırlar. örnek .desktop dosyası içeriği:

```ini
[Desktop Entry]

Version=1.0

Type=Application

Name=Firefox

Comment=Internet Web Browser

Exec=/usr/bin/firefox.bin

Icon=firefox.jpeg
```

Desktop dosyalarının executable yetkisi varsa; dosya yöneticisi ekranda gösterirken .desktop uzantısını gizler. onun yerine "name" değerini ekranda gösterir. Executable yetkisi olmayan dosyalarda hala ".desktop" uzantısı görülür. 

# Link dosyaları
Unix-like'ların tümünde standarttır. Link dosyaları o dizindeyken orjinal dosyanın tüm özelliklerini döndürürler. Örneğin link'in boyutu 60 mb olabilir. Çünkü Link sadece orjinal dosyanın referansını tutarak, o dizindeymişçesine davranmasını sağlayabilir.

Link dosya sisteminin bir özelliğidir. Oysa desktop file manager'in bir özelliğidir.

# "open with" kısayolları
nautilus'teki "open with" seçenekleri birer desktop dosyalarıdır. /usr/share/applications, /home/user-name/.local/share/applications gibi birçok dizin içerisinde bulunurlar. gnome masaüstü initialize olurken bütün bu dizinleri gezer ve bu kısayolları menüde gösterir. kısayolların içinki "exec" komutuna %U "open with" parametresi ile birlikte açılacak dosyanın aresini gönderir. örneğin scapcraft uygulamaları portable'dır. fakat sistemde yüklü gibi gözükmelerini sağlamak için bir dizinde bütün snap uygulamalaırın desktop dosyaları bulundurur. işletim sistemine kurulmuş olan snap, bu dizini file manager'ların config dosyalarına ekler. artık nautilus her başladığında bu dizini de tarayacaktır.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# wine (yada Wine İs Not Emulator)
windows executable dosyalarının unix-like'larda yürütmeye çalışan yazılım.

wine ile çalıştırılan bir executable, sistem çağrısı yaptığında çalıştırdığı metod, posix'te denk gelen en yakın metoddur. bu sebeple wine %100 stabil çalışamamaktadır. çünkü sistem çağrıları metodları, windowsun sistem çağrı metodları ile %100 aynı şekilde çalışamamaktadırlar.

wine yukarıdaki sebepten bir emülatör değildir. emülatör olsaydı, sistem çağrıları metodları windows'unki ile birebir aynı şekilde implemente edilmeleri gerekecekti.

örneğin android emülatörleri cpu işlemlerini masaüstü pc'de geçekleştirdiğinde birebir cpu çevrimi yapmaktadır.

wine; aynı windows 7'nin, "windows vista uyumluluk modu" mantığı ile çalışmaktadır.

# playonlinux
wine ile windows programı yüklendikten sonra, yüklenen proramın düzgün çalışabilmesi için windows'a denk gelen dizinlere dll atmak gibi birçok ek işlev gerekebiliyor. bu işlevler her program için toplanmış ve çözümleri internette aık kaynak olarak paylaşılmaktadır. playonlinux uygulaması bunları son kullanıcıya otomatik yapıyor.

mac ve BSD için ayrı fork'lar üretilmiştir: PlayOnMac and PlayOnBSD.

# dll (yada Dynamic-link library)
microsoft'un shared-library konsepti için implementasyonudur. dll dosyaları ms-windows için portable kütüphanelerdir. bunun içindeki metodlar herhangi bir programlama dili ile windows üzerinde çalıştırılabilir.

# CrossOver
playonlinux ile aynı görevi yapan ticari bir yazılımdır.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Filesystem Hierarchy Standard (FHS)
POSIX'ler için dizin standarttır. asagida bazı dizinler verilmiştir. iligli olanlar gruplandırıldı.

__

/dev device files. everthing is file on linux konusu. example: hdd partitions.

/Proc is a special virtual directory like /dev. Baska başlıkta detaylı anlatılıyor.

__

/media mounted removable devices (cd-rom, usb)

/mnt temporary mounted volumes (mounted iso)

/cdrom cd-rom mount point. it is not linux standart. because linux use /media.

/misc automatic mounted device , like archive files (like .iso), or mounted remote filesystems

__

/lib shared libraries /lib32 /lib64 gibi dizinler olabilir. çünkü aynı isimde executable'lar aynı sistemde olabilir. bu dizinde aynı zamanda kernel-modülleri de vardır.
bazı OS'larda /lib /usr/lib'e linklenmiş durumdadır. bu tarz linklemeler birçok dizin için yapılmaktadır.

/usr apps own files.

/sbin system-binary'den gelmektedir. Utilities used for system administration (and other root-only commands). mostly recovering, booting, repairing things...

/bin command line based executable apps

/usr/bin commands for end user, GUI apps 

/usr/sbin sistem açıldıktan sonra kullanılabilecek yönetimsel komutlar  buradadır. boot, recover, repair için olmayan fakat yönetimsel komutlar bu dizindedir.

/usr/local/sbin kullanıcı tarafından yüklenen sistemsel uygulamalar

/opt optional'dan gelmektedir. 3rd addons, or other system optional softwares.

__

/var app data for all users except config files (because config files are stored on /etc). the files inside tese directory are grouped like: log files (/var/log), crash dumps (/var/crash), files which are sent to printer (/var/spool), 

/etc config files for all users. example /etc/appname/.

/home/username user spesific home folder

/root root user's home folder

__

(others - gruplanamayanlar)

/lost+found hata durumlarında bazı dosyalar dosya sisteminde yok olabiliyorlar. fakat bu dosyalar tekrar kurtarılabilmeleri için eğer yapılabiliyorlarsa bu dizin altında linkleniyorlar.

/srv data to be served by the system for protocols such as, ftp, www

/tmp temporary files for all apps.

/boot boot files (example: grub)



* MacOS dizin yapısı
MacOS'ta POSIX'lerdeki gibi bir yapı vardır. Bazı istisnalar şunlardır:

/Applications --> uygulamaların ve kendi datalarının tutulduğu dizindir. her uygulama kendi isminde bir klasörde tutulur.

/Users --> linux'taki /home dizinidir. sadece ismi farklıdır.

/Volumes --> mount edilen tüm bölümler buradadır.

/var/root --> linuxtaki /root dizini.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# linux üzerinde yetki
linux üzerinde dosyalar üzerindeki haklar kullanıcı, grup ve diğerleri olarak 3 grupta belirlenebilmektedir. 

bir dosya için permission tanımlaması yaparken sadece owner, grup ve others olarak yapılabilir. bu sebepten eğer bir dosyaya, 2 farklı grubun hakkı olması isteniyorsa, yeni grup yaratılıp, o gruba yetki atanmalıdır.

1 kullanıcı birden fazla gruba mensup olabilir.

chown; owner değiştirme, chmod ise permission değiştirme için unix'lerde kullanılan komut satırı uygulamalarıdır. örnek:

> chmod 730 myfile.txt

yada farklı bir formatta yetkiler sırası ile verilir:

> chmod rwx-wx--- file.txt

Yukarıdaki ilk 4'lü (rwx-) dosyanın owner'ı için geçerli permissionlardır. ikinci dötlü ise dosyanın grubundaki user'lara uygulanacak permissionlardır. Son dörtlü ise "others" için geçerli olacak yetkilerdir.

"ls -la" komutu ile buldunduğumuz dizindeki dosyaları yetkileri ile beraber görebiliriz.

chmod'un aldığı sayısal parametre'ye unix'lerde "mode" olarak isimlendirilmektedir. mode şu şekilde belirlenir:

4 "read",

2 "write",

1 "execute"

0 "no permission"

her biri owner, grup, other için yanyana koyulur. aşağıdaki örnekler aynı anlama gelir:

> chmod u=rwx,g=rx,o=r myfile

> chmod 754 myfile

> chmod rwxr-xr-- myfile

Bazı mode'ların sembolik tanımlamaları da vardır. örnek: 

- a+wx

  777 ile aynı anlama gelir.

- a-wx

  r--r--r-- ile aynı anlama gelir

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# superuser (yada root)
yetkisi tam olan bir kullanıcıdır.

# su komutu
'Super User' ve 'substitute(vekil) user' ve 'switch user'ın kısaltmalarından gelmektedir.

"su" komutu, kullanıcı logout/login yapmadan komut satırından diğer kullanıcılara geçiş yapmamıza yarar. "su -c" komutu ile sadece o vereceğimiz komutu run etmemizi sağlar.

başka kullanıcı ile işlem yaparken "exit" komutu ile eski kullanıcıya dönüş yapabiliriz.

sadece 'su -' komutu o anda root user'ı olmamızı sağlar. 'su abc' komutu ise; abc kullanıcısı olmamızı sağlar.

# 'sudo abc' ( kısaltması)
"SuperUser Do" kısaltmasından gelmektedir.

"abc" komutunu başka kullanıcı yetkileri ile (kullanıcı ile değil!) işletmemiz sağlar. sudo komutunun geliştirildiği ilk zamanlar sadece superuser yetkileri ile işlem yapılması sağlanıyordu. bu sebeple ismi "SuperUser Do" kısaltmasıdır. fakat daha sonra herhangi bir kullanıcı yetkileri ile işlem yapabilmek için tasarlanmıştır. default olarak superuser yetkileri ile işlem yapılabilmesini sağlar.

sudo komutunu çalıştıran kullanıcının, sudo çalıştırmaya yetki verilmiş olmalıdır (sudoers dosyası aşağıda anlatılıyor). sorulacak şifre o andaki user'ın şifresidir.

ubuntu, komut satırını kapatıp açana kadar yada belirli bir süreliğine tekrar şifresiz sudo komutu üzerinden komut yürütmemize izin verir. bu 2 özellik sudo'nun özelliğidir.

"sudo -i" ile sürekli olarak root yetkileri ile işlem yapmamızı sağlar.

# gksudo command
gksudo komutu $HOME dizinini /root olarak ayarlıyor. bu şekilde çalışan komut satırı uygulamasının config dosyaları kendini /root altına atıyor. oysa sudo ile çalıştırılsaydı config dosyaları /home/current-user-name altında root yetkileriyle dosyalarda bulunuyor olacaktı. yetki sorunları meydana gelecekti. Aynı zamanda (özellikle) X oturumu dosyalarında da yetkilendirme sorunu olabiliyor. Bu sebeple grafik arayüzü uygulamalarını ilgilendiren bir konu. BU sebeple gnome 'gksudo', KDE uygulamaları ise 'kdesudo' komutunu kullanıyor.

# Ubuntu root user 
Ubuntu'da varsayılan olarak root kullanıcı ile giriş yapılmıyor. fakat kulanıcının root yetkileri mevcut. /etc/sudoers dosyasında hangi kullnıcıların kendi oturum şifrelerini bildiği takdirde root yetkileri ile komut çalıştırabileceklerini gösteriyor. işte sudo burada devreye giriyor. root kullanıcımızın bir şifresi olmamasına rağmen root yetkileri ile işlem yaptık. bu sudo komutunun bir özelliğidir. oysa ubuntuda "su" komutunu veridğimizde root kullanıcısı şifresi sorar, ubuntu'da (varsayılan olarak) root kullanıcı şifresi olmadığından root'a hiçbir zaman geçiş yapamayız. su genelde çoğu linux sisteminde kullanılan bir komut iken; sudo bazı dağıtımlarda kullanılır.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# Terminal (yada uçbirim)
kelime anlamı:

1. Otobüs, uçak vb. taşıtların yolcularını ilk aldığı veya son bıraktığı yer.
2. Bir veri iletişim ortamında veri giriş çıkışını sağlayan donanım birimi veya donanım birimleri topluluğu.

text input/output environment. Bir sistemin yönetilebilmesi için giriş ve çıkışları olan parçadır/modüldür.

# Konsol (yada console)
türkçe sözlükte: "işletmen uçbirimi" olarak belirtilmiştir. yani bir terminal'dir. fakat işletmen, yani operatör (Bilgisayar vb. teknik aletleri işleten kimse) için geliştirilmiş bir terminaldir.

# Sanal konsol
İşletim sistemlerindeki komut satırı uygulamaları birer "sanal konsol"dur. komutu yazan yazılımcı/programcı için geliştirilmiş konsol.

# Video oyun konsolu
Digital ortamda oyun oynayabilmek için tasarlanmış konsoldur.

# shell (kabuk)
shell, işletim sisteminde son kullanıcı için, işletim sistemine erişmesi için sunulan arayüzüdür. Bu arayüz Gnome, KDE olabilirken, sadece komut satırı masaüstleri yada sadece komut satırı uygulamasıda bir "kabuk"'tur. çünkü işletim sistemine erişmemiz için bir arayüz sunarlar.

# unix shell
bu terim; *nix sistemlerde, komut satırı yorumlayıcıları kapsar.

# Shell Command Language (yada sh yada Bourne shell)
programming language + __"command line interpreter"__ ( dili yorumlayan yazılım) described by the POSIX standards. bir spesifikasyondur. implementasyon değildir.

"command line interface" ile "command line interpreter" kısaltmaları aynıdır. fakat ikisi farklı kavramlardır.

# bash (yada Bourne-Again SHell)
Bir "sh" implementasyonudur. 

Geliştirildikten sonra sh standartlarınında dışına çıkmıştır. isteğe bağlı sh uyumlu modda çalışabilir. "sh uyumlu mod"da çalıştığında hem bash hemde sh özelliklerini barındıracak şekilde script'leri run eder.

Bash'in pazar payı yüksek olduğundan; Çoğu unix-like sistemde /bin/sh uygulaması çalıştırıldığında, aslında bash çalıştırılır. /bin/sh sadece bir sembolik bir linktir (kısayol). bin/sh sadece bash'i değil, sistemde tanımlı olan default sh implementasyonunu çağırır.

# Z shell (yada Zsh)
sh implementasyonudur.

# diğer shell'ler
fish, dash, Xiki Shell (yada xsh), KornShell...

MacOs bash kullanmaktadır.

# Oh My Zsh
sadece zsh için konfigürasyonlar community tarafından bu proje altında dağıtılmaktadır. bu konfigürasyonlar ile interpreter olan zsh, son kullanıcı için çok daha fazla yeteneğe sahip oluyor. bu özellikler terminal'den bağımsızdır.

oh-my-zsh bilgisayara kurulduğunda istenirse root izinli bir dizinine, yada istenirse de $HOME/.oh-my-zsh/ dizinine kuruluyor. burada birçok script mevcut. Bu script'lerin devreye girebilmesi için de $HOME/.zshrc dosyasında (bu dosya zsh tarafından execute ediliyor) bir referans (basit bir script çağırma sarırı) mevcut. yani oh-my-zsh tamamiyle taşınabilir durumda. $HOME/.oh-my-zsh/ dışında hiçbir yere kurulum yapılmıyor. $HOME/.oh-my-zsh/ dizini bir setup'tan değil, "git" aracılığı ile çekiliyor.

# Terminal Emulator (yada CLI yada command line interface)
shell yada alternatiflerini kullanabilmemiz için GUI yazılımlarıdır.  

"Terminal" unix-like dünyasında bir device dosyasıdır. Bu dosyaya yazma işini "Gnome terminal" gibi yazılımlarla; yani "terminal emulator"'larla yaparız.

Terminal Emulator içerisine komutlar yazdığımızdan, "Terminal Emulator"a eş anlamlı olarak CLI de kullanılmaktadır.

unix ve benzeri sistemlerde herşey dosyadır ve terminalde bir dosyadır. bir komutun çıktısı ve girdisi dosyadan okunacak şekilde basittir. Oysa powershell bir script dilidir. üst seviyeli API aracılığı ile linuxta yapılabilen birçok şeye imkan sunar.

# piyasadaki bazı terminal emulatörler

| name                            | notes                                                                                                                                                                                                                                   |
|---------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| xterm                           | X Windows System içerisinde standart gelen bir komut satırı uygulamasıdır.                                                                                                                                                              |
| UXTerm                          | xterm'in bazı karakter seti desteği eklenmiş paketinin ismidir.                                                                                                                                                                         |
| GNOME Terminal                  | Gnome desktop projesinin bir parçası olan terminal yazılımıdır. Uygulama açıldığında GUI'deki title'ı sadece "terminal"'dir. fakat bu son kullanıcıya kolay olması amaçlı bu şekilde tasarlanmıştır. orjinal ismi "gnome terminal"'dir. |
| Terminator                      | java ile yazılmış açık kaynaklı bir terminal yazılımıdır.                                                                                                                                                                               |
| macOS için terminal             | MacOs içerisinde gömülü gelen terminal yazılımının özel bir ismi yoktur. direk olarak "terminal" olarak isimlendirilmektedir.                                                                                                           |
| iterm                           | sadece macOS için geliştirilen terminal yazılımıdır. proje uzun zamandır güncellenmediğinden __iterm2__ isimli proje hayata geçirilmiştir.                                                                                              |
| Guake                           | gnome için masaüstünde panelden açılabilen komut satırı yazılımıdır.                                                                                                                                                                    |
| Konsole                         | KDE projesinin parçası olan komut satırı yazılımıdır.                                                                                                                                                                                   |
| Terminology                     | enlightment masaüstü projesi içinde gelen terminal yazılımıdır.                                                                                                                                                                         |
| upterm (eski adı: Black Screen) | web altyapısı üzerine kuruludur. sonlanmıştır (yıl 2019).                                                                                                                                                                               |
| hyper (eski adı: HyperTerm)     | web altyapısı üzerine kuruludur. hyper uygulaması, HyperTerminal ile karıştırılmamalıdır. HyperTerminal microsoft windows için çok farklı amaçta geliştirilmiş bir yazılımın ismidir.                                                   |
| tilix                           |                                                                                                                                                                                                                                         |
| terminus                        |                                                                                                                                                                                                                                         |
| alacritty                       |                                                                                                                                                                                                                                         |
| putty                           | ssh, için tasarlanmıştır. uzak masaüstündeki shell'i interpreter olarak kullanır. mintty projesi buradan birçok alıntı kod içermektedir.                                                                                                                      |
| KiTTY                           | putty projesinin forkudur.                                                                                                                                                                                                              |
| mintty                          | aşağıdaki başlıklarda açıklanmıştır                                                                                                                                                                                                     |

# Cygwin vs MinGW (yada Minimalist GNU for Windows)

açık kaynaklı bazı linux komut satırı uygulamaları, windows için tekrar derlenerek windows tarafında kullanılabilmektedirler. bunlar hazır paket olarak, tek uygulama altında "Cygwin" ismi ile windowsa yüklenebilmektedirler.

Cygwin, unix'in sistem çağrılarını ve kütüphanelerinin simüle edilip (arada bir katman var) programların çalıştırılmasını sağlarken, MinGW de ise böyle bir katman yoktur.

Cygwin wine'ın mantığı ile aynı değildir. wine direk windows executable'larını, linux'ta çalıştırırken, Cygwin linux executable'ı çalıştırmaz. Cygwin, UNIX programlarının Cygwin için derlenmiş halini çalıştırır. bunu yaparken, bazı kütüphaneleri ve sistem çağrılarını simüle eder.

# MSYS
Minimal SYStem'ın kısaltmasıdır.

MSYS bir unix programının windows ortamında derlenebilmesi için gerekli tüm tool'ları barındırır. örnek:
- make komutu
- configure komutu
- bash (interpreter, terminal GUI uygulaması değil!)
- git (kodların çekilebilmesi için kullanılacaktır)

MSYS2, MSYS'nin gelişmişidir.

# mintty
windows için açık kaynaklı terminal emulator'dır. ms-windows'un komut satırı ile hiçbir bağlantısı yoktur. aşağıdaki paketler opsiyonel olarak mintty ile entegreli çalışabilir:
- MSYS
- MSYS2
- git'in ms-windows setup'ı ile opsiyonel olarak yüklenen __git-bash__
- cygwin

# termux
- android için açık kaynaklı terminal emulator'dır.
- android işletim sistemi biraz farklı bir dizin yapısı kullandığı için apt-get ile kurulan komut satırı uygulamaları bu terminalde düzgün şekilde çalışamayabiliyor. benzer şekilde bu uygulama root olmayan cihazlarda çalışmak üzere tasarlandı. bu sebeple apt ile kurulan uygulamalar storage'ye kuruluyor. dolayısı ile komut satırı uygulamaları bu sebepten düzgün çalışamıyorlar. çünkü normalde o uygulamalar root yetkisi ile sistem kurulucak şekilde tasarlanmıştır. kurulum yöntemi farklı olunca, çalışmasında da sorunlar olabiliyor.
- android üzerinde her uygulamanın kendi user'ı var. bu uygulamaya sandbox yaptırmayı kolaylaştırıyor. uygulama bir yetki istediğinde, aslında kullanıcıya yetki veriliyor. her app'in bir user olmasının birbirinin dosyalarına erişememelerini de sağlıyor. bu sebeple; termux üzerinde çalıştırdığımız her komutta bunu değerlendirmemiz gerekiyor.

# CTRL+ALT+F1
Linux'ta GUI masaüstü ekranı açıkken buna basıldığında, tüm ekranda konsol ekranı açılır. arkaplanda varsayılan olarak 6 adet ekran açıktır. 7inci ekran GUI'nin kendisini (X or wayland) açmış olan session'dır.

CTRL+ALT+F1 ile ilk konsole ekranı açılırken, CTRL+ALT+F2 ile ikincisini açabiliriz.

Eğer GUI ekranında diilsek, yani konsol'daysak, ALT+FX ilx X'inci session'a geçebiliriz. ALT+→ ve ALT+← ile bir önceki veya bir sonraki session'lara gidebiliriz.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# komut satırı path değişkenleri

işletim sistemi aşağıdaki dosyaların içindeki komutları sırası ile işletir.

/etc/profile  --> her login sonrası (tüm user'lar için) çalıştırır.

~/.profile -> her login sonrası bu home klasörünün sahibi olan user için bu dosyadaki komutlar çalıştırılır.

~/.bashrc  --> shell uygulaması başlatıldığında, ilk olarak bu dosyanın içindeki komutları sırası ile çalıştırılır. örneğin 'bash' komutunu çalıştırdığımızda buradaki kodlar tekrar çalıştırılır.

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

• • • • • • • • • • • • • • • • • • • • • • • •

# bash

# shebang (yada sha-bang yada hashbang yada pound-bang yada hash-pling)
bir terminal emulator'a bir sciprt dosyasını çalıştırmasını istediğimizde:

> /path/my_script

bu script'i hangi interpreter ile çalıştıracağını bilemez. dolaysı ile my_script'in tepesine shebang kouyulur:

```bash
#!/bin/sh
```

\#! karakterleri sonrasında aslında execute edilecek interpreter'ın executable'ının path'ini yazıyoruz. Örneğimizdeki script sh programına parametre olarak geçilecek. yani asağidaki kod çalıştırılacak:

```sh
/bin/sh <dosyamızın içeriği buraya>
```

bash, bir sh implementasyonudur. fakat daha sonraki zamanlarda bazı dğeişikliklere uğradı. bu sebeple script dosyamızın üzerine /bin/sh veya /bin/bash yazmamış çok şeyi değiştirir. /bin/sh bir kısayol dosyasıdır. dolayısı ile farklı makinede farklı bir implementasyona referans ediyor olabilir.

başka örnek:

```sh
#!/usr/bin/env python
```

env komutu pyhon komutu çalıtırmaktadır. çoğu sistemde env, /usr/bin içerisinde olduğundan bu shebang ile sıkça karşılaşırız. env kullanmasaydık şunu da yazabilirdik:

```sh
#!/usr/bin/php
```

Eğer shebang tanımı yok ise, o anda script'i execute eden interpreter direk olarak kendi dilinde scripti yürütecektir.

Script dosyaları çalıştırıldıklarında, çalıştırılan dosyanın her satırı gerektiğinde okunur ve sadece ilgili satır okunur. yani sh dosyası çalışırken o dosyayı dğeiştirsek, çalıştırılan kodda bu durumdan etkilenecektir.

## function return value

fonksiyonlar exit code 0 ise başarılı diilse başarısız kabul edilir. bu sebeple || && gibi syntax'lardan yararlanabiliriz. örnek:

```sh
myFunc(){
  return 1; # this is the exit code. 
}

# if we call it
myFunc myParam1 myParam2 || echo "this is an error"

# or

myFunc myParam1 myParam2 || { echo "this is an error"; echo "not good"; }
```

fonksiyonlar değer return etmez. Birkaç kaçamak yol uygulanabilir:

- ortak parametre kullanımı

  myFunc kendi için return edeceği değeri environment variable'lara özel bir isimli bir variable'a atar. daha sonra myFunc'u çağıran fonksiyon bu değeri environment variable'larından okur.

- __subshell__ ve echo aracılığı ile 

```sh
myFunc(){
  echo "abc"
}

RETURN_VALUE=$(myFunc "myParam1" "myParam2")
echo $RETURN_VALUE
```

- exit code

exit code bir ufak bir tamsayı (çok ufak limitli). string döndürmek için bu yöntem kullanılamaz.

```sh
myFunc(){
  return 0
}

myFunc "myParam1" "myParam2"
RETURN_VALUE=$?
echo $RETURN_VALUE
```

## positional parameters

> my_bash_script_file.sh param1 param2

gibi komut çağrıldığında script dosyası içinde:

> $0

çağrılan scope'a göre dönüşü değişir.

/path/to/my_bash_script_file.sh

Eğer çağrılan bir script dosyası değilde bir fonksiyon olsaydı burada fonksiyon ismi dönecekti.

Eğer hiçbir fonksiyon yada script dosyası değilse; yani direk terminalimizden $0 yazarsak, "bash", "zsh" gibi dönüşler alırız.

> $1

param1

> $2

param2

> $3

boş

> ${12}

9'dan sonraki parametreleri ancak bu şekilde çekebiliyoruz.

> $@ veya $*

$0 hariç tüm parametreleri döndürür: param1 param2

> $#

$0 hariç parametre sayısını dönüdürür: 2

## $* vs $@

```sh
printAll(){
    for word in $* # or $@
    do 
        echo "$word";
    done
    # prints:
    # arg
    # 1
    # arg
    # 2

    for word in "$*"
    do 
        echo "$word";
    done
    # prints:
    # arg  1 arg  2 arg  3

    for word in "$@"
    do 
        echo "$word";
    done
    # prints:
    # arg  1
    # arg  2
    # arg  3
}

printAll "arg 1" "arg 2"
```

# bash dili

> command1 ; command2

ile bölünen kodlar sırası ile ne olursa olsun çalıştırılırlar. ; yerine "yeni satır" karakteri kullanılabilir. aynı görevi görecektir.

> command1 && command2

command1 başarılı dönerse command2 çağrılır.

> command1 || command2

command1 başarılı dönmezse command2 çağrılır.

> ls | grep abc

| işareti kendinden önceki komutun çıktısını sonrakine girdi olarak aktarır.

> myVar=$(command param1 param2)

çalıştırılan komutun çıktısını myVar'a atar.

> $

non-root user olduğunu gösterir

> \#

root user'ı olduğunu gösterir

> export MY_VARIABLE='Hello'

daha sonraki satırlarda kullanabilmek için değişken tanımlıyor. kullanımı için $MY_VARIABLE yazılması yeterlidir. bu değer komut satırından ve komut satırının çağırdığı diğer komutlar tarafından kullanılabilir. eğer komut satırından başlatılan uygulamalar bu değeri görmesi istenmiyor ise; export komutu yerine bash syntax'ı (bash'in default özelliği) kullanılmalıdır: MY_VARIABLE='Hello' yazılması yeterlidir ( = etrafında boşluk olamaz)

> env MY_VARIABLE='Hello' my_command

env önce değişkeni tanımlar ve ardından komutu değişkeni görebileceği şekilde komutu çalıştırır.

> bash

yeni bir bash oturumu açar. yeni oturum yeni pencerede açılmaz çünkü zaten komut satırı penceresinde olduğumuzdan oradan devam eder. yeni session açma isteğimiz environment değerlerinden ve bulunduğumuz dizinden çıkıp varsayılan dizine geçişimiz olabilir. "bash -c komut" komutu yeni açılan session'da çalıştırmasını sağlar.

bash komutu sonrası; export ile belirlenen değişkenler silinmez. fakat bash'in syntax'ını kullanarak belirlediğimiz değişkenler silinir.

> type

alacağı parametrenin tipini döner. örneğin; "if" alırsa bunun bir komut satırı statement'i olduğunu döner. "pwd" alırsa bunun komut satırı programına gömülü bir program olduğunu döner. "vlc" alırsa external bir program olduğunu döner. gibi..

> ./file-name

path'te tanımlı olan dosyalara bakmadan o anda bulunanan dizindeki dosyayı execute eder. dosya sh ise script yürütülür, executable binary ise işletim sistemi execute eder. executable olup olmayacağı yetkilerle alakalı bir konudur. eğer executable dosya değil ise; komut satırındayken tab tuşu o dosyayı otomatik tamamlamaz.

filename önüne bulunduğumuz directory belirteci girilmezse linux sadece path'e bakar, bu sebeple filename dosyası execute edilmez.

> komut > dosya

komutun çıktısını dosyaya yazdırır. dosya eğer varsa içeriğini siler ve dosyanın başlangıcına yazar.

```sh
> file  ## redirects stdout to file
1> file ## redirects stdout to file
2> file ## redirects stderr to file
&> file ## redirects stdout and stderr to file
2>&1    ## redirects stdout to stderr. normalde beklenen "2>1" olmasıdır. fakat "2>1" olursa; o zaman "1" dosya ismi olarak algılanır. arada bir belirteç olması gerekmektedir. bu sebeple 1'in önüne "&" işareti konulması standartlara eklenmiştir.
```

> komut >> dosya

\> ile aynıdır. tek farkı dosyanın içeriğini silmez ve sonundan yazmaya devam eder.

> komut < dosya

dosyanın içeriğini komutun system.input'una yollar.

# string

aşağıdakilerin hepsi birbirine eşittir:

```sh
'aa''bb''cc'
'aabbcc'
'aabb''cc'
'aa'bbcc
"aa"bb'cc'
```

String'ler tırnak içine alınabilir. Alınmasındaki fayda şudur: eğer string içierisinde boşluk varsa ve bu stringimizi tırnak içine almadıysak diğer programlar tarafından birden fazla parametre olarak algılanacaktır. bu sebeple;

```sh
$MY_ENV
```

gibi değişkenler çoğu durumda tırnak içine alınır. çünkü eğer değişken içerisinde boşluk varsa, değişkenin tek parametre (tek string) olarak tanımlatmak isteriz. bunu yapmamamız için bazı istisnai durumlarda olabilir.

Hardcode girilmiş stringlerimizi de mutlaka tırnak içine almalıyız. yoksa bu gibi karışıklıklar olabilir:

```sh
echo $HOMEabc
echo $HOME'abc'
```

Yukarıda ilk satır, HOMEabc isimli değişkeni ekrana basarken, aşağısındaki satır HOME değişkeninin yanına abc'yi birleştirerek ekrana basar.

çift tırnak ve tek tırnak sabit olan string'lerimiz için (örnek: "abc") önemli değildir. fakat değişkenleri basarken önemlidir. örnek:

```sh
echo "$HOME"
# prints /home/user1

echo '$HOME'
# prints $HOME
```

## __builtin (internal) command__
bu komutlar birer program diildir. bu komutlar terminal emulator'ların sunduğu bir özellik değildir. bu komutlar interpreter'ın (bash, zsh gibi) sunduğu keyword'lerdir/özelliklerdir. örneğin "which echo" yazdığımızda sonuç alamayız. çünkü echo bir builtin command'dır.

Bazı terminal'ler yada OS'ler shell builtin'leri ile aynı isimde programlar eklerler. bu durumda override eden (ki muhtemelen shell override edemeyecek) program çalışacaktır. Dolayısı ile komutlara aynı parametre yollasak bile farklı ortamlarda farklı sonuçlar alabiliriz.

"bash-builtins" komutu bize bash'in internal komutlarını listeler. bu liste aşağıdaki gibidir:

alias, bg, bind, break, builtin, case, cd, command, compgen, complete, continue, declare, dirs, disown, echo, enable, eval, exec,  exit,  export,  fc,  fg,  getopts, hash, help, history, if, jobs, kill, let, local, logout, popd, printf, pushd, pwd, read,  readonly,  return,  set,  shift,  shopt,  source, suspend,  test,  times,  trap,  type, typeset, ulimit, umask, unalias, unset, until, wait, while

isimleri ilginç fakat bunlarda builtin'dir:

> :

exit 0 (saglikli) donus yapan bos bir uygulamadır

> .

source ile aynı görevi görür. parametre olarak source edilecek dosyayı alır.

> [

çoğu yazılımcı bunu syntax sanar oysa değildir. __"test"__ komutu ile aynı görevi görür.

# komut satırı uygulamalarının help/manuel açıklamaları
"man pwd" ile pwd'nin manuel dosyasını ekrana bastırırız. her manuel'de SYNOPSIS (türkçe kelime anlamı: özet) başlığı vardır. Bu başlıkta komut satırının parametrelerinin nasıl yollanacağı açıklanır.

SYNOPSIS'in %100 bir standartdı yok. birçok firma kendi standardını resmi sitesinden yayınlıyor. fakat her uygulama bunlara uymuyor ve firmalar arası ufak farklar mevcut. örnek bir SYNOPSIS standartları standardı: https://www.ibm.com/support/knowledgecenter/en/STAV45/com.ibm.sonas.doc/sonas_manpages_syntax.html

örnek SYNOPSIS ve anlamları:

> command-app [options] <file1> [<dir1>]... param {a|b|c}

- "options" başlığındaki parametrelerden birini alacak anlamına gelir.
- options'taki [] işareti, bu alanın (options alanının) opsiyonel olduğunu gösterir. yani yollanması zorunlu diildir.
- file1 zorunlu bir alandır. çünkü [] içinde diil.
- file1 <> içine alınmış çünkü bir değeri ifade ediyor.
- dir1 opsiyoneldir ve ... birden fazla parametre yanyana olabilir anlamını kazandırır.
- "param" <> içine alınmamış. çünkü bir değeri ifade etmiyor. harcode bir string. yani son kullanıcı buraya sadece "param" yollayabilir.
- {a|b|c} a veya b veya c parametresi alır. bazı standartlarda {} yerine () kullanılır. c'nin altı çizli olsaydı c default değer (yani son kullanıcı o parametreyi yollamazsa) alınacak değer anlamına gelir.

- kalın yazılmış kelimeler:
  - <> alınmayan (sabit/hardcode string'leri)
  - komutun kendisi

italik yazılan kelimeler:
  - <> içerisine alınan değerlerdir

# coreutils
açık kaynaklı c ile yazılmış, hiçbir dependency gerektirmeyen en temel komut satırı uygulamalar grubudur. tümü bir git repository'sinde düzenli olarak geliştirilir.

# bazı komut satırı uygulamaları + shell buildin'ler

## tty
TeleTYpewriter'ın kısaltmasıdır. stdout'a, stdin (stream) dosyasının full path'ini döner.

örnek "tty" çıktımız /dev/pts/0 olsun. aynı komut satırında "read my_variable" komutunu verirsek, komut satırı stdin'den bizim bir değer girmemiz ve bu değeri ekrana basıp aynı zamanda my_variable'a atayacaktır. read komutu bu işi görür. biz hiçbir değer girmezsek ve farklı bir terminal session'ında "echo hello > /dev/pts/0" yazarsak, diğer session'daki read komutuna "hello" string'i gider.

her açtığımız terminal session'ı (ssh olsun, local terminallerimiz olsun) hepsi farklı stdin' sahiptir. bu sebeple her açtığımız terminal'de tty değerleri genelde bu şekilde ilerler: /dev/pts/0, /dev/pts/1, /dev/pts/2

## pseudoterminal master (yada PTM) vs pseudoterminal slave (yada PTS)
terminal interpreter'lar (ssh, xterm, gnome terminal...) bir terminal session'ı açtıklarında bir pts ve ptm dosyası oluştururlar. bunlar device dosyalarıdır.

terminolojik olarak bakıldığında; terminal interpreter'lara __pseudoterminal (yada pty yada pseudo-tty yada pseudotty)__ denir.

## which

farklı path'lerde aynı isimde birçok dosya olabilir. örneğin; "which vlc" bize hangi dizindeki vlc'yi execute edeceğini gösterir.

## where

paramatre aldığımı komutun nerelerde olduğunu listeler. which tek bir dizin dönerken, where birden fazla dönebilir.

## source command

command'ı execute eder. fakat yeni shell variable'leri kullanır. normalde ./eecute dediğimizde path veriable'larımız orada da tanımlı olurdu. fakat source'da böyle değil. source komutu yerine bu şekilde de kullanım aynı görevi görecektir: ". command" 

## echo

parametre aldığı string'i stdout'a yollar.

echo -e "hello \n \a" 'da bulunan -e parametresi stdout'a yollanacak string parametresindeki \n ve \a nın özel karakterler olduğunun algılanmasını sağlar. yani; \n satır sonu \a ise beep sesi çıkaracaktır. özel karakterlerin tüm listesi:

```
\a      alert (bell)
\b      backspace
\c      suppress further output
\e      escape character
\f      form feed
\n      new line
\r      carriage return
\t      horizontal tab
\v      vertical tab
\\      backslash
\0nnn   the character whose ASCII code is NNN (octal).  NNN can be 0 to 3 octal digits
\xHH    the eight-bit character whose value is HH (hexadecimal).  HH can be one or two hex digits
```

-n paramtresi echo komutunun sonuna satır sonu karakteri eklemesini sağlar.

echo çoğu sistemde built-in komut'tur. -n ve -e parametreleri çoğu komut satırı interpreterında default olarak zaten echo komutuna yollanır.

-E parametresi, escape karakteri --> \ ile belirtilen string'lerin özel karakterler olarak algılanmamasını sağlar.

## printf

parametre aldığı string'i stdout'a yollar. echo'ya göre ektra bazı özellikleri vardır.

## pwd

(Print Working Directory) Bulunduğunuz dizinin ismini verir.

## hostname

Makinanın ismini verir.

## whoami

(Who Am I?) Sisteme giriş yaparken yazdığınız kullanıcı isminizi verir.

## uptime

Makinanın ne kadar süredir açık olduğu bilgisini verir.

## cd abc

(Change Directory) abc path'ine gider. cd bir komut satırı uygulaması değildir. komut satırı uygulamasının bir özelliğidir.

## mkdir abc

(Make Directory) bulunduğu dizinde abc isminde klasör oluşturur

## grep xyz abc

abc dosyasındaki, xyz string'inin oldugu satırları dondurur

## ls

bulunduğu dizindeki dosyaları listeler

## top

çalışmakta olan process'lerin detaylı listesi

## history

komut satırında daha önce verilen komutların listesini çıkartır.

## cat dosya.txt

prints the file

## nano file.txt

basit text editor

## vim

__vi__ editoründen esinlenerek yapıldığı için bu ismi almıştır.

__gvim__; gtk penceresi içine gömülmüş bir terminalde vim çalıştırılmaktadır. ek olarak toolbar butonları bazı komutları yerine getirmk amaçlı sunmaktadır. bu tarz birçok vim forku mevcuttur.

__vim-gnome__ ve __vim-gtk__ farklı bağımlılıklarla derlenen iki benzer fakat gvim tarzı forklardır.

__vim-tiny__ vim'i tüm özelliklerini barındırmayan bir forkudur. komut satırından __vi__ yada __vim.tiny__ olarak çağrılır. ubuntu ve türevlerinde bu paket yürklü gelmektedir. 

vim'in birçok modu var:
- insert mode
- normal mode
- visual mode

vim'in hangi modda olduunu en aşağıdaki panelde yazmaktadır. vim ilk açıldığında insert modda başlar. insert modda klavyeden girilenler, dosyayı düzenlemek için kullanılır.

ESC tuşu ile normal moda geçiş yapılır.

Normal mod'dayken de sağa sola gidilebilir. bunun için sağa sol yerine, h j k l tuşları (yada farklı tuşlar konfigüre edilebilir) kullanılabilir.

normal mod'da, 4 karakter sağa gidilecek ise; 4 ardından da "l" karakterine basılır.

notmal mod'da sırası ile c,4,l tuşlarına basıldığında ise 4 karater sağa gider, ardından da otomatik insert moda geçeriz. c karakteri bunu yapar.

normal mod'dayken insert mode'a geçiş yapmak için i tuşuna bsmalıyız. eğer a tuşuna basarsak bizi insert tuşuna alır fakat imleci bulunan karakterin sağına atar.

normal moddayken komut girebiliriz. bunun için normal moddayken yada insertt mod'dayken : tuşuna basmalıyız. ardından da komutumuzu gireriz. örnek:

> :q

vim'i kapatır.

> :q!

değişiklikleri kaydetmeden kapatır

> :wq

değişiklikleri kaydederek çıkar.

> :w

sadece değişiklikleri kaydeder. vim'i kapatmaz.

visual mode'a geçiş yapabilmek için v tuşuna basılmalıdır. v tuşuna basıldıktan sonra karakter grubu seçimi yapabiliriz. burada hem mouse supportu var, hemde yine ghjk karakterleri ile sağa sola gidip seçim yapabiliyoruz. 4 ardından da "l" tuşuna basarsak, 4 karakter sağa doğru seçim yapılmış olur gibi...

## neovim

komut satırından __nvim__ ile çağrılır. vim forkudur. çok gelişmiş özelliklere sahiptir.

## emacs

bu terim; genişletilebilir komut satırı text editörlerine verilene genel bir isimdir. tek başına bir uygulama değildir. mutlaka kendini emacs olarak belirten bir türevini kurmak gereklidir. "GNU Emacs", "XEmacs (yada eski adı:Lucid EMacs)"), yada "remacs" kullanılmalıdır.

komut satırından "emacs" diye çağrıldığında sistemde yüklü olan bir emacs editorü (yukarıda yazanlardan biri) çağrılır.

emacs, vim'e göre çok daha gelişmiş bir yapıya sahiptir. fakat vim'e göre konfigürasyonu daha zordur.

## more dosya.txt

prints the file. fakat ek olarak komut satırı ekrana sığmayan kısımları boşluk tuşuna basarak devamlı parça parça okumamıza olanak verir.

## head dosya.txt

print some of first lines of file.

## tail dosya.txt

prints some of last lines of file.

## head -n 5 dosya.txt

prints the first 5 lines

## tail -n 25 dosya.txt

prints the last 5 lines

## ls | grep abc

(| işareti kendinden önceki komutun çıktısını sonrakine girdi olarak aktarır.)
grep komutu; ls'nin output'unda sadece "abc" içeren satırları döndürür.

## ls | more

ekrana sığacak şekilde dosya isimlerini listeler. sığmayanları boşluk tuşuna basarak görebiliriz.

## less

more ile aynı görevi görüyor. less daha eski yılların bir projesi.

## netstat

socket listeleme programı

## nc

açılımı: netcat. komut satırı uygulaması ile bir porttan direk tcp soketi açılabilir gibi hızlı network kontrolleri yapmamızı sağlıyor.

## cat

dosya okuma, dosyayı başka bir dosyanın sonuna direk ekleme gibi işlemler sağlar

## ln

- kısayol oluşturur.
- "ln -s" parametresi symbolic link (yada soft link) oluşturur.
- "-s" parametresi geçilmezse hard link oluşturur.
- posix'teki dosya sistemleri her 2 türkdeki link çeşididini de destekler.
- soft link, dosyanın path'ine işaret ediyor. dolayısı ile; link ettiğimiz dosyanın adı/path'i değişirse, linkimiz artık çalışmaz hale gelir. 
- hard link ise; dosyanın içeriğine direk link ediyor. dosya ismi değişirse, linkimiz hala doğru yere referans etmeye devam eder.

  (dosyanın içeriği ile dosyanın adresi farklı göstergelerdir)

## man
 
   man vlc

   aldığı ilk parametre farklı bir programdır. ilgili programın manuel page'sini gösteriyor.

   posix'lerde her uygulama kurulduğunda manuel dosyalarını /usr/share/man/tr/i386 (yada /usr/local/man) gibi dizininlere atar. bu dizinler OS'tan OS'a değişiklik göstermektedir.

   man programı bu dizinleri kurcalar ve bize ilgili programın manuel'ini gösterir.

   manuel dosyalarında şu şekilde bir tanım görürüz:

   > command [ A ] file ...

   - A burada köşeli parantez içinde olduğu için opsiyonel parametre olduğunu temsil eder.
   
   - file ise zorunlu bir parametredir.

   - üç okta ondan bir önceki parametreden sonsuz adet alabildiğini belirtir. yani file1'in yanına; file2, file3 şeklinde dilediğimiz kadar dosya atabiliriz.

   ## section

   man sadece komutların doc'larını diil, system call gibi birçok fonksiyonunda doc'unu göstermektedir. bunlar bazı kategorilere ayrılmış durumda. kategori listesi bu şekilde:

   - 1 - User commands (Programs)
         
     Those commands that can be executed by the user from within a shell.
 
   - 2 - System calls
     
     Those functions which wrap operations performed by the kernel.
 
   - 3 - Library calls
     
     All library functions excluding the system call wrappers (Most of the libc functions).
 
   - 4 - Special files (devices)
     
     Files found in /dev which allow to access to devices through the kernel.
 
   - 5 - File formats and configuration files
     
     Describes various human-readable file formats and configuration files.
 
   - 6 - Games
     
     Games and funny little programs available on the system.
 
   - 7 - Overview, conventions, and miscellaneous
 
     Overviews or descriptions of various topics, conventions and protocols, character set  standards, the standard filesystem layout, and miscellaneous other things.
 
   - 8 - System management commands
   
     Commands like mount(8), many of which only root can execute.

   örnek:

   "man 1 read" komutu read komutunun doc'unu gösterecektir. fakat "man 2 read" read system call'unun doc'unu gösterecektir.

   örnek2:

   https://linux.die.net/man/2/read (archive date: 26/10/2019) sayfası bize read'in system call'unun doc'unu gösteriyor.

## httpie

   wget ve curl'a alternatif modern bir komut satırı http client uygulaması. modern uygulamaların strest testlerinde dahi kullanılabilir. komut satırından "http" olarak çağrılmaktadır.

## http-prompt

   httpie kullanan fakat komut satırında otomatik tamamlama sunan bir komut satırı uygulamasıdır. interaktif çalışır. komtu satırına "http-prompt" yazıldığında interaktif moda geçer.

## ldd

   ldd lib.so ile lib.so dosyasının link ettiği diğer bağımlılıklarını görüyoruz. bu şekilde programa tanıtacağımız lib dosyasının sistemimizde ihtiyaç duyduğu bağımlılıkları görebiliriz.

## update-alternatives

   /etc/alternatives/ ve /var/lib/alternatives/ dizinlerini düzenler. bu dizinde her amaç için (örnek x-www-browser, editor) hangi programın işletim sisteminde varsayılan olarak açılacağı bilgisi vardır. örneğin /etc/alternatives/java bir symbolic link'tir ve java'nın executable dosyasına link eder.

# alias

komut satırı dünyasında alias bir komutun yerine kullanılan keyworddür. örneğin;

> alias clr="clear"

komutu ile artık istediğimiz zaman "clr" komutu ile "clear" komutunu çalıştırmış oluruz.

> unalias clr

komutu ile alias silinir.

## dd

dd komutu cp ile yapılabilecek herşeyi yapar fakat ekstrasında bazı ek özellikler sunar. sunduğu özellikler özellikle disklere (partititonlara) yazıp okumayı kolaylaştırmaktadır. partitionlar ve diskler linuxta birer dosya olduğu için "cp" komutu ile de aynı işler yapılabilir. fakat dd bu iş için biçilmiş kaftandır.

iso formatı partition bilgilerini de tutmaktadır. bir red-hat linux iso'sunu direk dd ile çok basit şekilde bir device'a (usb'ye) aktarabiliriz. artık bu usb bootable bir OS olacaktır.
